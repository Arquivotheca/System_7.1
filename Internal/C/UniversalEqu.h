/*
	File:		UniversalEqu.h

	Contains:	low-level equates for accessing the Universal ROM information

	Written by:	Craig Prouse

	Copyright:	© 1993 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		 <1>	11/10/93	fau		first checked in

*/

#ifndef __UNIVERSALEQU__
#define __UNIVERSALEQU__


/* private low-memory globals for Universal info */

enum {
	AddrMapFlags = 0x0DD0,				// RAM copy of the machine’s BasesValid flags
	AddrMapFlags1 = 0x2400,
	AddrMapFlags2 = 0x2404,
	UnivROMFlags = 0x0DD4,				// RAM copy of the machine’s ExtValid flags
	UnivROMFlags1 = 0x2408,
	UnivROMFlags2 = 0x240C,
	UnivInfoPtr = 0x0DD8				// points to the machine’s ProductInfo record
};



// --------------------------------------------------------------------------------------------
//	DecoderInfo Record
//
//	This record contains information pertaining to the memory decoder
//	of a particular machine.
//
//	If you change the DecoderInfo record, bump the version up by 1.
//--------------------------------------------------------------------------------------------

#define DecoderInfoVersion 1


// This record actually precedes the DecoderInfo record below. Normally accessed only
// from assembly language using negative offsets, a pointer to this information can
// also be generated by subtracting the size of this record from the address of the
// DecoderInfo record.

struct DecoderInfoPrivate {
	unsigned long	defaultBases;
	unsigned long	defaultBases1;
	unsigned long	defaultBases2;
	unsigned long	defExtFeatures;
	unsigned long	defExtFeatures1;
	unsigned long	defExtFeatures2;
	unsigned char	avoidVIA1A;
	unsigned char	avoidVIA1B;
	unsigned char	avoidVIA2A;
	unsigned char	avoidVIA2B;
	long			checkForProc;
	unsigned char	addrMap;
	unsigned char	decoderInfoVers;
	unsigned char	filler [2];
};


struct DecoderInfo {

	void *			ROMAddr;
	void *			DiagROMAddr;
	void *			VIA1Addr;
	void *			SCCRdAddr;
	void *			SCCWrAddr;
	void *			IWMAddr;
	void *			PWMAddr;
	void *			SoundAddr;
	void *			SCSIAddr;
	void *			SCSIDackAddr;
	void *			SCSIHskAddr;
	void *			VIA2Addr;
	void *			ASCAddr;
	void *			RBVAddr;
	void *			VDACAddr;
	void *			SCSIDMAAddr;
	void *			SWIMIOPAddr;
	void *			SCCIOPAddr;
	void *			OSSAddr;
	void *			FMCAddr;
	void *			RPUAddr;
	void *			OrwellAddr;
	void *			JAWSAddr;
	void *			SonicAddr;
	void *			SCSI96Addr1;
	void *			SCSI96Addr2;
	void *			DAFBAddr;
	void *			PSCAddr;
	void *			ROMPhysAddr;
	void *			PatchROMAddr;
	void *			NewAgeAddr;
	void *			Unused31Addr;

	void *			SingerAddr;
	void *			DSPAddr;
	void *			MACEAddr;
	void *			MUNIAddr;
	void *			AMICAddr;
	void *			PrattAddr;
	void *			SWIM3Addr;
	void *			AwacsAddr;
	void *			CivicAddr;
	void *			SebastianAddr;
	void *			BARTAddr;
	void *			GrandCentralAddr;
	void *			Unused44Addr;
	void *			Unused45Addr;
	void *			Unused46Addr;
	void *			Unused47Addr;
	void *			Unused48Addr;
	void *			Unused49Addr;
	void *			Unused50Addr;
	void *			Unused51Addr;
	void *			Unused52Addr;
	void *			Unused53Addr;
	void *			Unused54Addr;
	void *			Unused55Addr;
	void *			Unused56Addr;
	void *			Unused57Addr;
	void *			Unused58Addr;
	void *			Unused59Addr;
	void *			Unused60Addr;
	void *			Unused61Addr;
	void *			FooAddr;
	void *			Unused63Addr;

	void *			Unused64Addr;
	void *			BarAddr;
	void *			Unused66Addr;
	void *			Unused67Addr;
	void *			Unused68Addr;
	void *			Unused69Addr;
	void *			Unused70Addr;
	void *			Unused71Addr;
	void *			Unused72Addr;
	void *			Unused73Addr;
	void *			Unused74Addr;
	void *			Unused75Addr;
	void *			Unused76Addr;
	void *			Unused77Addr;
	void *			Unused78Addr;
	void *			Unused79Addr;
	void *			Unused80Addr;
	void *			Unused81Addr;
	void *			Unused82Addr;
	void *			Unused83Addr;
	void *			Unused84Addr;
	void *			Unused85Addr;
	void *			Unused86Addr;
	void *			Unused87Addr;
	void *			Unused88Addr;
	void *			Unused89Addr;
	void *			Unused90Addr;
	void *			Unused91Addr;
	void *			Unused92Addr;
	void *			Unused93Addr;
	void *			Unused94Addr;
	void *			Unused95Addr;
};
typedef struct DecoderInfo DecoderInfo;


enum DecoderKinds {
	UnknownDecoder,
	MacPALDecoder,
	BBUDecoder,
	NormandyDecoder,
	GLUEDecoder,
	MDUDecoder,
	OSSFMCDecoder,
	VISADecoder,
	OrwellDecoder,
	JAWSDecoder,
	MSCDecoder,
	SonoraDecoder,
	NiagraDecoder,
	YMCADecoder,
	djMEMCDecoder,
	HMCDecoder,
	PrattDecoder,
	HHeadDecoder
};


enum BasesValidFlags {
	ROMExists,
	DiagROMExists,
	VIA1Exists,
	SCCRdExists,
	SCCWrExists,
	IWMExists,
	PWMExists,
	SoundExists,
	SCSIExists,
	SCSIDackExists,
	SCSIHskExists,
	VIA2Exists,
	ASCExists,
	RBVExists,
	VDACExists,
	SCSIDMAExists,
	SWIMIOPExists,
	SCCIOPExists,
	OSSExists,
	FMCExists,
	RPUExists,
	OrwellExists,
	JAWSExists,
	SonicExists,
	SCSI96_1Exists,
	SCSI96_2Exists,
	DAFBExists,
	PSCExists,
	ROMPhysAddrExists,
	PatchROMExists,
	NewAgeExists,

	SingerExists = 32,
	DSPExists,
	MACEExists,
	MUNIExists,
	AMICExists,
	PrattExists,
	SWIM3Exists,
	AwacsExists,
	CivicExists,
	SebastianExists,
	BARTExists,
	GrandCentralExists
};


// This macro is equivalent in part to the assembly language TestFor macro,
// although it only works for features listed in DecoderInfo. It requires a
// BasesValidFlag (enumerated above) and returns a boolean value. Example:
//		if (TestForBaseAddr(GrandCentralExists)) { }

#define TestForBaseAddr(bvFlag)								\
	((1 << ((bvFlag) & 0x1F) &								\
	((bvFlag) < 32 ? *(unsigned long *) AddrMapFlags :		\
	((bvFlag) < 64 ? *(unsigned long *) AddrMapFlags1 :		\
	((bvFlag) < 96 ? *(unsigned long *) AddrMapFlags2 :		\
	0)))) != 0)


// This macro is used to conveniently recover a base address from the DecoderInfo
// table in one easy-to-read operation. Assuming that the corresponding BasesValid
// flag is true, the base address can be recovered directly by its field name in
// the DecoderInfo record. The macro handles all the arcane offsets, casts, and
// dereferences. Example:
//		void *gcBase = GetUnivInfoBaseAddr(GrandCentralAddr);

#define GetUnivInfoBaseAddr(fieldName)						\
	(((DecoderInfo *) (*(unsigned long *) UnivInfoPtr		\
	+ (**(ProductInfo **) UnivInfoPtr).decoderInfoPtr))		\
	->##fieldName)



//--------------------------------------------------------------------------------------------
//	ProductInfo Record
//
//	This record contains information specific to a particular machine.
//	The lowmem UnivInfoPtr is a pointer to this data structure.
//
//	If you change the ProductInfo record, bump the version up by 1.
//--------------------------------------------------------------------------------------------

#define ProductInfoVersion 1


struct ProductInfo {

	long			decoderInfoPtr;				// offset to address decoder info
	long			ramInfoPtr;					// offset to RAM bank base/size info
	long			videoInfoPtr;				// offset to built-in video info
	long			nubusInfoPtr;				// offset to NuBus slot info
	unsigned short	hwCfgWord;					// value to load into hwCfgFlags
	unsigned char	productKind;				// unique ID of this product (boxFlag value)
	unsigned char	decoderKind;				// unique ID of associated address decoder
	unsigned short	rom85Word;					// value to load into ROM85
	unsigned char	defaultRSRCs;				// default ROM resource configuration
	unsigned char	productInfoVers;			// version number of ProductInfo record

	unsigned long	basesValid;					// valid flags for base addresses  0-31
	unsigned long	basesValid1;				// valid flags for base addresses 32-63
	unsigned long	basesValid2;				// valid flags for base addresses 64-95
	unsigned long	extValid;					// valid flags for external features  0-31
	unsigned long	extValid1;					// valid flags for external features 32-63
	unsigned long	extValid2;					// valid flags for external features 64-95
	unsigned long	viaIDMask;					// mask for VIA1/2 port A/B inputs
	unsigned long	viaIDMatch;					// value to match to identify this product
	long			via1InitPtr;				// offset to VIA1 initialization info
	long			via2InitPtr;				// offset to VIA2 initialization info

	long			sndControlPtr;				// offset to low level sound vector table
	long			clockPRAMPtr;				// offset to low level clock/PRAM vector table
	long			adbDebugUtilPtr;			// offset to low level ADB/DebugUtil vector table
	long			powerManagerPtr;			// offset to low level Power Manager vector table
	long			intHandlerPtr;				// offset to low level interrupt handler setup table

	unsigned short	cpuIDValue;					// expected contents of CPU ID register
	unsigned short	filler;
	long			iconInfoPtr;				// offset to icon info table
};
typedef struct ProductInfo ProductInfo;


#endif __UNIVERSALEQU__
