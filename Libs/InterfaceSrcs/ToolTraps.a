;
;	File:		ToolTraps.a
;
;	Contains:	ToolTraps is the Pascal/QuickDraw-ToolBox trap interface.
;				It defines all the names declared external in the interface
;				code, and implements them by trapping with the "auto-pop" bit
;				set to remove the extra return address on the stack
;				before dispatching.  Most of this file was generated by the
;				program "MakeTTraps".
;
;	Copyright:	© 1984-1992 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM3>	10/28/92	SWC		Changed INCLUDEs to a LOAD of StandardEqu.d.
;		 <7>	  7/6/92	DCL		Added Support for new synonyms.
;		 <6>	  2/4/91	JL		Put the SetClikLoop Entry Point back in.
;		 <5>	 1/29/91	stb		dba: change SetClikLoop glue to use Pascal conventions for
;									returninug the boolean result
;		 <4>	 11/5/90	dba		moved obsolete stuff to the bottom of this         file
;		<3+>	 11/5/90	dba 	move obsolete stuff to the bottom of this file
;		<3>		 10/2/90	JAL		Removed old commented out routines.  Fixed up SetClikLoop,
;
;	6 Jan 87	KLH SetClikLoop no longer needs to preserve D2.
;	16 Mar 87	KLH added GetGrayRgn.
;	18 May 87	KLH TEFromScrap glue used VAR ptr = 0, trashing low memory.
;	10 Jun 87	KLH TEToScrap gets TEScrpLength as 0000xxxx (CLR high word).
;	12 Jun 87	KLH GetItemStyle has glue to fix ROM bug.
;	*** MPW 3.0d2 ***
;	*** MPW 3.0a1 ***
;	6 Apr 88	KLH Removed GetAlrtStage, ResetAlrtStage, GetDblTime & GetCaretTime
;					done with multiple inlines.
;	*** MPW 3.0a2 ***
;	9/24/90 	dba Fixed GetIndString for negative numbers (large numbers) and 0.
;--------------------------------------------------------------------

				LOAD	'StandardEqu.d'


obsoleteGlue	equ 	0		; stuff conditionalized by this can be moved to a separate file

;FUNCTION HandToHand(VAR theHndl: Handle): OSErr;

HandToHand		PROC EXPORT

				MOVE.L	4(SP),A0			;ptr to handle
				MOVE.L	(A0),A0 			;the Handle
				_HandToHand
				MOVE.L	4(SP),A1			;ptr to handle to be returned
				MOVE.L	A0,(A1) 			;return the new handle
				MOVE	D0,8(SP)			;return error
				MOVE.L	(SP)+,(SP)			;pop off the return addr
				RTS

;FUNCTION PtrToXHand(srcPtr: Ptr; dstHndl: Handle; size: LongInt): OSErr;

PtrToXHand		PROC EXPORT

				MOVE.L	(SP)+,D1			;save return address
				MOVE.L	(SP)+,D0			;the size
				MOVE.L	(SP)+,A1			;existing handle
				MOVE.L	(SP)+,A0			;srcPtr
				MOVE.L	D1,-(SP)			;restore return address
				_PtrToXHand
				MOVE.W	D0,4(SP)			;error code
				RTS 						;return

;FUNCTION PtrToHand(srcPtr: Ptr; VAR dstHndl: Handle; size: LongInt): OSErr;

PtrToHand		PROC EXPORT

				MOVE.L	12(SP),A0			;src pointer
				MOVE.L	4(SP),D0			;size
				_PtrToHand					;make a new handle and copy ptr in
				MOVE.W	D0,16(SP)			;error code
				MOVE.L	8(SP),A1			;address of handle
				MOVE.L	A0,(A1) 			;return new handle
				MOVE.L	(SP)+,A0			;return addr
				ADD 	#12,SP				;pop off args
				JMP 	(A0)				;return

;FUNCTION HandAndHand(hand1,hand2: Handle): OSErr;

HandAndHand 	PROC EXPORT

				MOVE.L	8(SP),A0			;source handle
				MOVE.L	4(SP),A1			;other source handle
				_HandAndHand				;concats hndl in A0 to H in A1
				MOVE	D0,12(SP)
				MOVE.L	(SP)+,A0			;return addr
				ADDQ	#8,SP				;pop off args
				JMP 	(A0)				;return

;FUNCTION PtrAndHand(ptr1: Ptr; hand2: Handle; size: LongInt): OSErr;

PtrAndHand		PROC EXPORT

				MOVE.L	4(SP),D0			;length of ptr
				MOVE.L	8(SP),A1			;handle
				MOVE.L	12(SP),A0			;ptr
				_PtrAndHand 				;concat ptr to handle
				MOVE	D0,16(SP)			;return error
				MOVE.L	(SP)+,A0			;return addr
				ADD 	#12,SP
				JMP 	(A0)

;PROCEDURE DialogCut(dialog: DialogPtr);
;PROCEDURE DialogPaste(dialog: DialogPtr);
;PROCEDURE DialogCopy(dialog: DialogPtr);
;PROCEDURE DialogDelete(dialog: DialogPtr);

DialogPaste		PROC EXPORT

				EXPORT	  DialogCut
				EXPORT	  DialogCopy
				EXPORT	  DialogDelete
				EXPORT	  DlgCut			; obsolete old procedure name
				EXPORT	  DlgCopy			; obsolete old procedure name
				EXPORT	  DlgDelete			; obsolete old procedure name
				EXPORT	  DlgPaste			; obsolete old procedure name

DlgPaste
				BSR.S	StdCheck
				_TEPaste

adios			MOVE.L	(SP)+,(SP)			;pop return/argument
				RTS

DlgCut
DialogCut		BSR.S	StdCheck
				_TECut
				BRA.S	adios

DlgCopy
DialogCopy		BSR.S	StdCheck
				_TECopy
				BRA.S	adios

DlgDelete		
DialogDelete	BSR.S StdCheck
				_TEDelete
				BRA.S	adios

StdCheck		MOVE.L	8(SP),A0			;get dialog ptr
				TST 	EditField(A0)		;see if edit is open
				BMI.S	noDice
				MOVE.L	(SP)+,A1			;pop return for stdcheck
				MOVE.L	TEHandle(A0),-(SP)	;pass text edit handle
				JMP 	(A1)

noDice			MOVEM.L (SP)+,D0/A0-A1		;get real return addr
				JMP 	(A0)				;return

; FUNCTION TEGetScrapLength: LongInt;

TEGetScrapLength	PROC EXPORT

				export	TEGetScrapLen			; obsolete old procedure name
TEGetScrapLen
				CLR.L	4(SP)
				MOVE.W	TEScrpLength,6(SP)		;low order word of longInt is len
				RTS

; FUNCTION TESetScrapLength(length: LongInt);

TESetScrapLength	PROC EXPORT
				
				export	TESetScrapLen			; obsolete old procedure name
TESetScrapLen
				MOVE.W	6(SP),TEScrpLength		;low order word of longInt is len
				MOVE.L	(SP)+,(SP)				;pop arg
				RTS

;---------------------------------------------------------------
;
;		FUNCTION TEFromScrap: OSErr; EXTERNAL;
;
;---------------------------------------------------------------
;	orig glue called GetScrap with VAR ptr = 0, which didn't blow up call,
; but trashed low memory for future use. Also noErr now returned if call OK.
; KLH 5/18/87
;	credit to Tom Taylor for recognizing that scrap could be larger than
; the TERecord allows. Changed glue to prevent crashes due to this. 3/24/88

TEFromScrap  PROC EXPORT

			CLR.L		-(SP)					; temp VAR offset: LONGINT
			SUBQ		#4,SP					; room for GetScrap function
			CLR.L		-(SP)					; Handle = NIL => get size only
			MOVE.L		#'TEXT',-(SP)			; what else...
			PEA 		12(SP)					; VAR offset
			_GetScrap
			MOVE.L		(SP)+,D0				; GetScrap function return
			ADDQ		#4,SP					; dummy offset gone in case we branch
			BMI.S		@error
			CMP.L		#32001,D0
			BLO.S		@continue				; scrap too large?					<4>
			MOVE.W		#teScrapSizeErr,D0		; Tom Taylor memorial error
			BRA.S		@error
@continue
			CLR.L	   -(SP)					; temp VAR offset: LONGINT
			SUBQ		#4,SP					; room for GetScrap function
			MOVE.L		TEScrpHandle,-(SP)		; pass text edit as destHandle
			MOVE.L		#'TEXT',-(SP)			; what else...
			PEA 		12(SP)					; VAR offset
			_GetScrap
			MOVE.L		(SP)+,D0				; GetScrap function return
			ADDQ		#4,SP					; get rid of dummy offset
			BPL.S		@noError				; flags from func rtn still valid
@error
			CLR.W		TEScrpLength			; if error, no scrap length?
			BRA.S		@done
@noError
			CLR 		4(SP)					; noErr
			MOVE.W		D0,TEScrpLength 		; stuff the length
			moveq		#noErr,d0				; no error happened					<4>
@done
			MOVE.W		D0,4(SP)				; error
			RTS

;---------------------------------------------------------------
;
;		FUNCTION TEToScrap: OSErr; EXTERNAL;
;
;---------------------------------------------------------------
; TEScrpLength is a long word (somebody was planning ahead). The
; Text Edit routines in the ROM do only a MOVE.W to & from it, so
; here we also treat it as only a word (Can’t count on what that
; upper portion might be). This works OK for the present Text Edit
; world in which Inside Mac maintains you cannot have a lenght of a
; text edit record over 32K. This glue however, was accessed by the
; MPW shell which had no such limitation. The EXT.L D0 it had after
; grabbing the length could then extend to a large negative number
; which could trash the system depending upon what call followed it.
; 10 June 87 - KLH.

TEToScrap	PROC  EXPORT

			MOVE.L		TEScrpHandle,A0 		; get text edit
			_HLock

			SUBQ		#4,SP
			MOVE.W		TEScrpLength,-(SP)		; low word of length			<4>
			CLR.W		-(SP)					; high word of length			<4>
			MOVE.L		#'TEXT',-(SP)			; what else...
			MOVE.L		(A0),-(SP)				; handle
			_PutScrap
			ADDQ		#2,SP					; get rid of high word
			MOVE.W		(SP)+,4(SP) 			; return error

			MOVE.L		TEScrpHandle,A0 		; get text edit
			_HUnLock

			RTS

;PROCEDURE SetClikLoop (userProc: ProcPtr; hTE: TEHandle)
;
; We stuff our ProcPtr directly into the TERec. Our ProcPtr makes room for 
; the Pascal Boolean result, calls the userProc, and puts the result into 
; D0 so TEClick knows whether to abort.
;
; We store the real ProcPtr at a fixed location: 20(A5). 
; This means that there can only be 1 clickloop in use at any 1 time. 
; KLH could have built some linked list structure for this, but deemed it 
; not necessary.
SetClikLoop		PROC  EXPORT

                MOVE.L  (SP)+,D0			;return address
                MOVE.L  (SP)+,A1			;text edit record handle
                MOVE.L  (SP)+,20(A5)		;put clikLoop address into the
											;	global space reserved for clikLoop

                MOVE.L  (A1),A1				;deref hTE
                LEA     AsmClikLoop,A0
                MOVE.L  A0,teClikProc(A1)	;point hTE's clikLoop to me
                MOVE.L  D0,A0
                JMP     (A0)		        ;go home

AsmClikLoop									;click loop entry for 64K ROMs.
                CLR.B   -(SP)		        ;leave room for Pascal BOOL rslt
                MOVE.L  20(A5),A0
                JSR     (A0)
                MOVE.B  (SP)+,D0	       	;TRUE to continue click loop
                RTS

;PROCEDURE SetWordBreak (userProc: ProcPtr; hTE: TEHandle)

SetWordBreak	PROC EXPORT

				MOVE.L	(SP)+,D0				;return address
				MOVE.L	(SP)+,A1				;text edit record handle
				MOVE.L	(SP)+,24(A5)			;global space reserved for wordbreak
				MOVE.L	(A1),A1 				;deref hTE
				LEA 	AsmWordBreak,A0 		;D2 save routine
				MOVE.L	A0,teWordBreak(A1)		;point hTE's clikLoop to me
				MOVE.L	D0,A0
				JMP 	(A0)					;go home

AsmWordBreak
				CLR.B	-(SP)					;leave room for result
				MOVE.L	A0,-(SP)				;ptr to text
				MOVE.W	D0,-(SP)				;the index
				MOVE.L	24(A5),A0
				JSR 	(A0)					;global space reserved for this
				TST.B	(SP)+					;pop off Boolean result
				RTS 							;and set cc's

;PROCEDURE GetIndString(VAR theString: str255; strListID: INTEGER; index: INTEGER);
;
;gets the STR# resource with ID strListID and returns in theString the index-th
;string in the string list.

GetIndString	PROC EXPORT

				LINK	A6,#0

				;get the string list
				SUBQ	#4,SP					;room for result handle
				MOVE.L	#'STR#',-(SP)			;theType
				MOVE.W	10(A6),-(SP)			;strListID
				_GetResource
				MOVE.L	12(A6),A1				;ptr to where to return the str
				CLR.B	(A1)					;assume empty
				MOVE.L	(SP)+,D0				;handle to string list
				BEQ.S	gsret					;if empty, just quit
				MOVE.L	D0,A0					;get handle in A0
				MOVE.L	(A0),A0 				;deref it
				MOVE.W	(A0)+,D0				;get the number of strings
				MOVE.W	8(A6),D1				;the index
				BEQ.S	gsret					;index of 0 						<dba 9/24/90>
				CMP.W	D0,D1					;is index larger than count?
				BHI.S	gsret					;yes, just quit 					<dba 9/24/90>
				MOVEQ	#0,D0					;will keep track of length of strs

gsLoop			SUBQ.W	#1,D1					;decrement the index
				BEQ.S	gsCopy					;found the one we are looking for
				MOVE.B	(A0)+,D0				;get length of this one
				ADD.L	D0,A0					;skip over this string
				BRA.S	gsLoop					;and go on to next

gsCopy			MOVE.B	(A0),D0 				;get the length of this string
				ADDQ	#1,D0					;add one for the length byte
				_BlockMove						;copy it into the string

gsret			UNLK	A6
				MOVE.L	(SP)+,A0				;return addr
				ADDQ.L	#8,SP					;pop off parms
				JMP 	(A0)					;return

;PROCEDURE GetIndPattern(VAR thePat: Pattern; patListID: INTEGER;index: INTEGER)
;
;gets PAT# resource with ID patListID and stuffs into thePat the index-th
;pattern in the list.

GetIndPattern	PROC EXPORT

				LINK	A6,#0

				;get the string list
				SUBQ	#4,SP					;room for result handle
				MOVE.L	#'PAT#',-(SP)			;theType
				MOVE.W	10(A6),-(SP)			;patListID
				_GetResource
				MOVE.L	12(A6),A1			;ptr to where to return the pat
				MOVE.L	(SP)+,D0			;handle to string list
				BEQ.S	gpret				;if empty, just quit
				MOVE.L	D0,A0				;get handle in A0
				MOVE.L	(A0),A0 			;deref it
				MOVE.W	(A0)+,D0			;get the number of patterns
				MOVE.W	8(A6),D1			;the index
				BEQ.S	gpret				;no such thing as negative index		<4>
				CMP.W	D0,D1				;is index larger than count?
				BHI.S	gpret				;yes, just quit							<4>

gpLoop			SUBQ.W	#1,D1				;decrement the index
				BEQ.S	gpCopy				;found the one we are looking for
				ADDQ	#8,A0				;skip over the pattern
				BRA.S	gpLoop				;and go on to next

gpCopy			move.l	(a0)+,(a1)+			;first 4 bytes							<4>
				move.l	(a0),(a1)			;second four bytes						<4>

gpret			UNLK	A6
				MOVE.L	(SP)+,A0			;return addr
				ADDQ.L	#8,SP				;pop off parms
				JMP 	(A0)				;return

;PROCEDURE ScreenRes(VAR scrnHRes, scrnVRes: INTEGER);

ScreenRes		PROC EXPORT				;untested

				MOVE.L	(SP)+,A0
				MOVE.L	(SP)+,A1		;get scrnHRes address
				MOVE.W	ScrVRes,(A1)
				MOVE.L	(SP)+,A1		;get scrnVRes address
				MOVE.W	ScrHRes,(A1)
				JMP		(A0)

;PROCEDURE SetFractEnable(fractEnable:BOOLEAN);

SetFractEnable	PROC EXPORT

			CMP.W	#$3FFF,ROM85			;is it numMac ROM?
			BHI.S	@99
			_SetFractEnable autoPop			;the trap will return to caller
@99
	 		MOVE.L	(SP)+,A0
			MOVE.B	(SP)+,FractEnable
			MOVE.L	MinusOne,LastSpExtra	;note that widths are invalid
			JMP (A0)

;	GetItemStyle has a bug in the ROM: We get a ptr to a Style (byte). The
; ROM does a MOVE.W to this location, trashing other things and not returning
; the correct value. 12 June 87 - KLH
;
; PROCEDURE GetItemStyle(menu: MenuHandle; item: INTEGER; VAR styleVal: Style);

GetItemStyle	PROC	EXPORT
				SUBQ.L	#2,SP			; Make room for dummy Style VAR
				MOVE.L	12(SP),-(SP)	; move up MenuHandle
				MOVE.W	14(SP),-(SP)	; move up item
				PEA 	6(SP)			; new VAR address points to dummy.
				_GetItmStyle
				MOVE.W	(SP)+,D0		; Style as word in D0.
				MOVE.L	(SP)+,A0		; return address
				MOVE.L	(SP)+,A1		; REAL VAR address
				MOVE.B	D0,(A1) 		; we did it!
				ADDQ.L	#6,SP			; clean up orig menu & item.
				JMP 	(A0)			; RTS

;----------------------------------------------------------------------

	if obsoleteGlue then

;----------------------------------------------------------------------

;PROCEDURE SetDAFont(fontNum: INTEGER);

SetDAFont		PROC  EXPORT

				MOVE.L	(SP)+,A0			;return addr
				MOVE.W	(SP)+,DlgFont		;set new dlg font
				JMP 	(A0)

;FUNCTION GetMaskTable: Ptr;

GetMaskTable	FUNC EXPORT

				_GetMaskTable
				MOVE.L A0, 4(A7)			;move pointer from A0 onto stack
				RTS

; FUNCTION GetGrayRgn: RgnHandle;

GetGrayRgn		FUNC EXPORT

				MOVE.L	GrayRgn,4(SP)
				RTS

;----------------------------------------------------------------------

	endif

;----------------------------------------------------------------------

		END
