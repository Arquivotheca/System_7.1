;
;	File:		OSTraps.a
;
;	Contains:	Interfaces to register based traps
;
;	Copyright:	© 1984 - 1990, 1992 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM7>	 11/10/92	CSS		Update from Reality:
;									<16>	10/16/92	DTY		Add BlockMoveData.
;	   <SM6>	 11/6/92	SWC		Changed PackMacs.a->Packages.a.
;	   <SM5>	10/28/92	SWC		Changed INCLUDEs to a LOAD of StandardEqu.d.
;	   <SM4>	10/22/92	CSS		Changed a short branch to word branch.
;	   <SM3>	 9/21/92	RB		Changed a short branch to word branch.
;		<15>	  7/6/92	DCL		Added Support for new synonyms.
;		<14>	 6/12/91	LN		Removed #includes for private interfaces from public interfaces.
;									Changed #include 'HardwareEqu.a' to #include
;									'HardwarePrivateEqu.a'
;		<13>	12/14/90	dba		<JDR> move VInstall and VRemove to the obsolete section
;		<12>	 12/3/90	JDR		<dba> Shorten glue for InsTime, RmvTime, PrimeTime and move them
;									to the obsolete section; get rid of InsXTime glue since no one
;									ever used it.
;		<11>	11/28/90	JDR		<KIP> There is no glue for calling _InsXTime and I need to use
;									it, so I've added it.
;		<10>	 11/4/90	dba		shortened some of the routines that use LINK to get a parameter
;									block by doing a MOVE.L SP,A0 instead of a LEA
;									-paramBlockSize(A6),A0; fixed GetHandleSize and GetPtrSize so
;									they return 0 if an error occurs (instead of the error code);
;									added ReallocateHandle, MaxMemSys, CompactMemSys
;									GetOSTrapAddress, SetOSTrapAddress, GetToolTrapAddress,
;									SetToolTrapAddress, GetToolboxTrapAddress,
;									SetToolboxTrapAddress, MaxBlockSys, NewEmptyHandleSys; fixed a
;									bug in StartSound (see below for details); made Create return an
;									error code when GetFileInfo fails, instead of doing a
;									SetFileInfo with random data; changed Open so it will try the
;									OpenDF call first; got rid of the OpenDF glue, since it is now
;									exactly equivalent to Open; shortened SetChooserAlert by taking
;									advantage of the fact that BSET and BCLR return the old state of
;									the bit being set/cleared; change GetDCtlEntry to return NIL if
;									you pass a bad refNum - this matches how the Device Manager does
;									this; moved obsolete glue routines to a separate part of the
;									file
;		<9+>	 11/1/90	dba 	fix GetHandleSize and GetPtrSize failure case
;		 <9>	10/30/90	dnf 	(dragging dba along) Add OpenDF call. Remove DTGetPath,
;									DTOpenInfom and DTCloseDown glue, since it is now inline.
;		 <8>	10/16/90	JL		Putting Greg's Change Back
;		 <7>	 10/4/90	JAL 	Implemented results of code review. No more 64K Rom Support.
;		 <6>	 9/18/90	gbm 	Fix a build warning generated by a short branch to the next
;									instruction... the way I fixed it was by making the exit points
;									be in their own proc
;		 <5>	 8/29/90	dnf 	Rename CreateFileID, DeleteFileID and ResolveFileID to the newly
;									approved CreateFileIDRef, DeleteFileIDRef and ResolveFileIDRef.
;									Change GetAltAccess/SetAltAccess to
;									GetForeignPrivs/SetForeignPrivs
;		 <4>	  5/4/90	dnf 	Add PBMakeFSSpec glue macro
;		 <3>	 3/16/90	dnf 	Change desktop call names to match the latest in traps.a
;		 <2>	  2/4/90	DNF 	Add glue for new HFS and Desktop calls
;				 12/7/89	JAL		Old (64K) Rom code which is now "unSupported".  Removed from:
;									SetSoundVol, ClsPorts, RamSDClose, RamSDOpen, romMoveHHi, MaxApplZone
;				 12/4/89	JAL		Removed HWNonPortable and PrNonPortable equates because they are
;									now defined in the Makefile.
;				 12/9/88	KLH		StartSound must dispose handles after completion.
;				10/19/88	KLH		Busy day. Fixed sndWait index in StartSound.
;				10/19/88	KLH		Added NewHandleSys, NewHandleClear & NewHandleSysClear too.
;				10/19/88	KLH		Added NewPtrSys, NewPtrClear & NewPtrSysClear per Ed Tecot, et al.
;				  4/7/88	KLH		Removed SystemZone, GetApplLimit, ApplicZone, GZSaveHnd & TopMem;
;									provided inline.
;				  1/7/88	KLH		GetVInfo fixed to return correct size info.
;				 12/1/87	KLH		Mike Tibbott points out unnecessary save of ptr in Create.
;				 9/21/87	KLH		In GetDCtlEntry changed LSR.W #2,D0 to LSL.W to get index properly.
;				 6/11/87	KLH		Removed PBSetPEOF per Bill Bruffey.
;				 4/13/87	KLH		StartSound & StopSound now move.l -1 into SoundHdl to stop sounds &
;									test only for a word of -1 to stop sounds started with old buggy code.
;

	STRING	ASIS

onMac	EQU 	1

			LOAD	'StandardEqu.d'
			INCLUDE 'HardwarePrivateEqu.a'
			INCLUDE 'Packages.a'
			INCLUDE 'Printing.a'
			INCLUDE 'SANEMacs.a'
			INCLUDE 'Slots.a'

obsoleteGlue	equ 	0		; stuff conditionalized by this can be moved to a separate file

SoundHdl		EQU 	$AE8	; handle for the Sound Glue

; for EqualString

result		EQU 	16
str1		EQU 	12
str2		EQU 	8
caseSens	EQU 	6
diacSens	EQU 	4
parmSize	EQU 	result-diacSens

;----------------------------------------------------------------------
;
; Procedure InitZone(growProc:		 ProcPtr;
;			 moreMasters:	 Integer;
;			 limitPtr,startPtr : Ptr);
; Creates and initializes a fresh zone from unstructured storage
;
; Arguments:
;		growProc:		points to grow procedure for this zone
;		moreMasters:	number of master pointers to create at a time
;		limitPtr:		points one past last byte of raw storage
;		startPtr:		points to first byte of raw storage
;
; Registers:
;		D0 - result code from InitApplZone
;
InitZone		PROC  EXPORT

				MOVE.L	(SP)+,A1		;return address
				Move.L	SP,A0			;stack parameters form req blk
				_InitZone
				Add 	#14,SP			;strip parameters
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION CompactMem(cbNeeded: Size): Size;
;
; Compact the heap until a free block with cbNeeded bytes is found or
; until the end of the zone is reached.  Returns cbFound, the size of
; the largest block found.
;
; Arguments:
;		cbNeeded:		size of block needed
;
; Result:
;				size of largest block found, in bytes
;
; Registers:
;		D0 - number of bytes needed/number of bytes in biggest block
;
CompactMem		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get cbNeeded
				_CompactMem 			;tell OS to do it
				Move.L	D0,(SP) 		;save result
				JMP 	(A1)			;return via A1

CompactMemSys	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get cbNeeded
				_CompactMem sys 		;tell OS to do it
				Move.L	D0,(SP) 		;save result
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION MaxMem(VAR grow: Size): Size;
;
; Return the size of the maximum block which may be allocated without
; growing the zone.  Also return the maximum number of bytes by which the
; zone may be grown.
;
; Arguments:
;		None
;
; Result:
;				size of largest available block in bytes
;		grow:			maximum growth allowed in current zone
;
; Registers:
;		A0 - grow/pointer to VAR grow
;		A1 - return address
;		D0 - number of bytes in largest free block
;
MaxMem			FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				_MaxMem 				;let OS do it
				Move.L	A0,D1			;max growth allowed
				Move.L	(SP)+,A0		;get the pointer to VAR grow
				Move.L	D1,(A0)
				Move.L	D0,(SP) 		;save result
				JMP 	(A1)			;return via A1

MaxMemSys		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				_MaxMem sys 			;let OS do it
				Move.L	A0,D1			;max growth allowed
				Move.L	(SP)+,A0		;get the pointer to VAR grow
				Move.L	D1,(A0)
				Move.L	D0,(SP) 		;save result
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION NewPtr(byteCount: Size): Ptr;
; FUNCTION NewPtrSys(byteCount: Size): Ptr;
; FUNCTION NewPtrClear(byteCount: Size): Ptr;
; FUNCTION NewPtrSysClear(byteCount: Size): Ptr;
;
; Returns a pointer to a newly allocated non-relocatable block of
; memory byteCount bytes long.
;
; Arguments:
;		byteCount:		number of bytes needed
;
; Result:
;				pointer to new block, or NIL, if not enough room
;
; Registers:
;		A0 - points to new block, or NIL
;		A1 - return address
;		D0 - number of bytes needed/error code
;
NewPtr			FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewPtr 				;ask OS to do request
				Move.L	A0,(SP) 		;return result ptr on stack
				JMP 	(A1)			;return via A1

NewPtrSys		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewPtr ,sys			;ask OS to do request
				Move.L	A0,(SP) 		;return result ptr on stack
				JMP 	(A1)			;return via A1

NewPtrClear 	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewPtr ,clear			;ask OS to do request
				Move.L	A0,(SP) 		;return result ptr on stack
				JMP 	(A1)			;return via A1

NewPtrSysClear	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewPtr ,sys,clear		;ask OS to do request
				Move.L	A0,(SP) 		;return result ptr on stack
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION GetPtrSize(p: Ptr): Size;
;
; Returns number of bytes in the non-relocatable block pointed to by p.
;
; Arguments:
;		p:			points to non-relocatable block
;
; Result:
;				number of bytes in block
;
; Registers:
;		A0 -			points to block
;		A1 -			holds return address
;		D0 -			number of bytes in block
;
GetPtrSize		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get the pointer
				_GetPtrSize 			;let OS do it
				Move.L	D0,(SP) 		;return result on stack
				bpl.s	@done			;check for error			<10>
				clr.l	(sp)			;return zero if we failed	<10>
@done
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure SetPtrSize(p: Ptr; newSize: Size);
;
; Sets the size of the non-relocatable block pointed to by p to newSize
; bytes.
;
; Arguments:
;		p:			points to non-relocatable block
;		newSize:	number of bytes needed in block
;
; Result:
;		None
;
; Registers:
;		A0 -			points to block
;		A1 -			holds return address
;		D0 -			number of bytes needed/error code
;
SetPtrSize		PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the new size
				Move.L	(SP)+,A0		;get the pointer
				_SetPtrSize 			;let OS do it
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION	PtrZone(p: Ptr): THz;
;
; Recovers the reference to the heap zone object, given a pointer to
; a block.
;
; Arguments:
;		p:			points to non-relocatable block
;
; Result:
;				pointer to the zone object for the zone
;				containing the referenced block.
;
; Registers:
;		A0 -			points to block/points to block's zone object
;		A1 -			holds return address
;		D0 -			error code
;
PtrZone 		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get the pointer
				_PtrZone				;let OS do it
				Move.L	A0,(SP) 		;save zone object pointer
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION	NewHandle(byteCount: Size): Handle;
; FUNCTION	NewHandleSys(byteCount: Size): Handle;
; FUNCTION	NewHandleClear(byteCount: Size): Handle;
; FUNCTION	NewHandleSysClear(byteCount: Size): Handle;
;
; Returns a handle to a newly allocated relocatable block
; byteCount bytes long.
;
; Arguments:
;		byteCount:		number of bytes needed
;
; Result:
;				handle to new block, or NIL, if not enough room
;
; Registers:
;		A0 - handle for new block, or NIL
;		A1 - return address
;		D0 - number of bytes needed/error code
;
NewHandle		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewHandle				;ask OS to do request
				Move.L	A0,(SP) 		;return result handle on stack
				JMP 	(A1)			;return via A1

NewHandleSys	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewHandle ,sys 		;ask OS to do request
				Move.L	A0,(SP) 		;return result handle on stack
				JMP 	(A1)			;return via A1

NewHandleClear	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewHandle ,clear		;ask OS to do request
				Move.L	A0,(SP) 		;return result handle on stack
				JMP 	(A1)			;return via A1

NewHandleSysClear	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the byte count
				_NewHandle ,sys,clear	;ask OS to do request
				Move.L	A0,(SP) 		;return result handle on stack
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION	GetHandleSize(h: Handle): Size;
;
; Returns number of bytes in the relocatable block referenced by h.
;
; Arguments:
;		h:			handle for relocatable block
;
; Result:
;				number of bytes in block
;
; Registers:
;		A0 -			points to block
;		A1 -			holds return address
;		D0 -			number of bytes in block
;
GetHandleSize	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get the handle
				_GetHandleSize			;let OS do it
				Move.L	D0,(SP) 		;return result on stack
				bpl.s	@done			;check for error			<10>
				clr.l	(sp)			;return zero if we failed	<10>
@done
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure SetHandleSize(h: Handle; newSize: Size);
;
; Sets the size of the relocatable block referred to by h to newSize
; bytes.
;
; Arguments:
;		h:			refers to relocatable block
;		newSize:		number of bytes needed in block
;
; Result:
;		None
;
; Registers:
;		A0 -			points to block
;		A1 -			holds return address
;		D0 -			number of bytes needed/error code
;
SetHandleSize	PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the new size
				Move.L	(SP)+,A0		;get the handle
				_SetHandleSize			;let OS do it
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION	HandleZone(h: Handle): THz;
;
; Recovers the reference to the heap zone object, given a handle for
; a block.
;
; Arguments:
;		h:			refers to relocatable block
;
; Result:
;				pointer to the zone object for the zone
;				containing the referenced block.
;
; Registers:
;		A0 -			handle for block/points to block's zone object
;		A1 -			holds return address
;		D0 -			error code
;
HandleZone		FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get the handle
				_HandleZone 			;let OS do it
				Move.L	A0,(SP) 		;save zone object pointer
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION	RecoverHandle(p: Ptr): Handle;
;
; Recovers the handle for a relocatable block, given a pointer to the
; relocatable block.  theZone must be set to reflect the zone containing
; this relocatable block.
;
; Arguments:
;		rp: 		points to relocatable block
;
; Result:
;				handle for the referenced block.
;
; Registers:
;		A0 -			pointer to relocatable block/handle for block
;		A1 -			holds return address
;		D0 -			error code
;
RecoverHandle	FUNC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get the reloc block pointer
				_RecoverHandle			;let OS do it
				Move.L	A0,(SP) 		;save handle for block
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure ReallocHandle(h: Handle; byteCount: Size);
;
; Allocates a relocatable block, using an existing handle.
; If the handle is not already empty, the handle is emptied first,
; then allocated.
;
; Arguments:
;		h:			refers to relocatable block
;		byteCount:		number of bytes needed in the new block
;
; Result:
;		None
;
; Registers:
;		A0 -			handle for block/points to block's zone object
;		A1 -			holds return address
;		D0 -			new block size/error code
;
ReallocHandle	PROC  EXPORT
				EXPORT	ReallocateHandle
ReallocateHandle

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get the new size
				Move.L	(SP)+,A0		;get the handle
				_ReallocHandle			;let OS do it
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure BlockMove(srcPtr, destPtr: Ptr; byteCount: Size);
;
; Arguments:
;		srcPtr: 		source pointer
;		destPtr:		destination pointer
;		byteCount:		bytecount for move
;
; Registers:
;		A0 -			source pointer
;		A1 -			destination pointer
;		D0 -			bytecount for move
;		D1 -			holds return address
;
BlockMove		PROC  EXPORT

				Move.L	(SP)+,D1		;return address
				Move.L	(SP)+,D0		;byte count
				Move.L	(SP)+,A1		;destination ptr
				Move.L	(SP)+,A0		;source ptr
				_BlockMove				;let OS to do it.
				Move.L	D1,A1			;return address
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure BlockMoveData(srcPtr, destPtr: Ptr; byteCount: Size);
;
; Arguments:
;		srcPtr: 		source pointer
;		destPtr:		destination pointer
;		byteCount:		bytecount for move
;
; Registers:
;		A0 -			source pointer
;		A1 -			destination pointer
;		D0 -			bytecount for move
;		D1 -			holds return address
;
BlockMoveData	PROC  EXPORT

				Move.L	(SP)+,D1		;return address
				Move.L	(SP)+,D0		;byte count
				Move.L	(SP)+,A1		;destination ptr
				Move.L	(SP)+,A0		;source ptr
				_BlockMoveData			;let OS to do it.
				Move.L	D1,A1			;return address
				JMP 	(A1)			;return via A1

;
; FUNCTION OpenDriver(driverName: OsStr255; VAR refNum: INTEGER): OsErr;
;
;	OpenDriver opens the driver of a given name, returning refNum and error
;
OpenDriver		FUNC	EXPORT

				MOVEQ	#(ioQElSize/2)-1,D0
@1				CLR.W	-(SP)
				DBRA	D0,@1

				MOVE.L	ioQElSize+8(sp),ioFileName(SP)	;set up name
				MOVE.L	SP,A0				;point to it
				_Open						;open the driver

				MOVE.L	ioQElSize+4(SP),a0	;get place to put result
				MOVE.W	ioRefNum(SP),(a0)	;store result

				MOVE.L	ioQElSize(SP),A0	;get return address
				LEA 	ioQElSize+12(SP),SP ;get rid of param. block and parameters
				MOVE.W	D0,(SP) 			;store error code
				JMP 	(A0)				;return

;
; PROCEDURE CloseDriver(refNum: INTEGER):OsErr;
;
;	CloseDriver closes the driver with the specified refNum
;
CloseDriver 	PROC	EXPORT

				MOVE.W	4(SP),D0			;get the refNum
				SUB 	#30,SP				;get space for param block
				MOVE.W	D0,ioRefNum(SP) 	;set up refNum
				MOVE.L	SP,A0
				_Close						;close it!
				ADD 	#30,SP				;pop off param block
				MOVE	D0,6(SP)			;return result

				MOVE.L	(SP)+,A0
				ADDQ	#2,SP
				JMP 	(A0)

;
;FUNCTION  SerReset(refNum: INTEGER; serConfig: INTEGER): OSErr;
;

SerReset FUNC	 EXPORT

		LINK	A6,#-ioQElSize			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	10(A6),ioRefNum(A0) 	; refnum
		MOVE.W	#8,csCode(A0)			; code for Reset
		MOVE.W	8(A6),csParam(A0)		;the configuration

		_Control
		MOVE	D0,12(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,(SP)
		RTS

;
;FUNCTION  SerSetBuf(refNum: INTEGER; serBPtr: Ptr; serBLen: INTEGER): OSErr;
;
SerSetBuf FUNC	  EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	14(A6),ioRefNum(A0) 	; refnum
		MOVE.W	#9,csCode(A0)			; code for Set buffer
		MOVE.L	10(A6),csParam(A0)		;the ptr to the buffer
		MOVE.W	8(A6),csParam+4(A0) 	;the buffer length

		_Control
		MOVE	D0,16(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#8,SP					; fix up stack
		JMP 	(A1)

;
;FUNCTION  SerHShake(refNum: INTEGER; flags: SerShk): OSErr;
;
SerHShake FUNC	  EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	12(A6),ioRefNum(A0) 	; refnum
		MOVE.W	#10,csCode(A0)			; code for setting handshake options
		MOVE.L	8(A6),A1				;ptr to flags record
		MOVE.L	(A1)+,csParam(A0)		;copy the first 4 bytes
		MOVE.L	(A1),csParam+4(A0)		;copy the second 4 bytes

		_Control
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#6,SP					; fix up stack
		JMP 	(A1)

;
;FUNCTION  SerSetBrk(refNum: INTEGER): OSErr;
;
SerSetBrk FUNC	  EXPORT
		EXPORT	SetClr

		MOVE.W	#12,D0

SetClr
		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	8(A6),ioRefNum(A0)		; refnum
		MOVE.W	D0,csCode(A0)			; code for setting break

		_Control
		MOVE	D0,10(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#2,SP					; fix up stack
		JMP 	(A1)

;
;FUNCTION  SerClrBrk(refNum: INTEGER): OSErr;
;
SerClrBrk FUNC	  EXPORT
		IMPORT	SetClr

		MOVE.W	#11,D0				;csCode for clearing break
		JMP 	SetClr				;got to common set/clr break code

;
;FUNCTION  SerGetBuf(refNum: INTEGER; VAR count: LongInt): OSErr;
;
SerGetBuf FUNC	EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	12(A6),ioRefNum(A0) 	; refnum
		MOVE.W	#2,csCode(A0)			; csCode for get buf
		_Status
		MOVE	D0,14(A6)				; return the result code
		MOVE.L	8(A6),A1				; ptr to where to put count
		MOVE.L	csParam(A0),(A1)		;return the count

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#6,SP					; fix up stack
		JMP 	(A1)

;
;FUNCTION  SerStatus(refNum: INTEGER; VAR serSta: SerStaRec): OSErr;
;

SerStatus FUNC	EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	12(A6),ioRefNum(A0) 	; refnum
		MOVE.W	#8,csCode(A0)			; csCode for get buf
		_Status
		MOVE	D0,14(A6)				; return the result code
		MOVE.L	8(A6),A1				; ptr to where to put the status bytes
		MOVE.L	csParam(A0),(A1)+		;return the first 4 bytes
		MOVE.W	csParam+4(A0),(A1)		;return the next 2 bytes

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION DiskEject(drvnum: INTEGER): OSErr;
;

DiskEject FUNC	  EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	#dskRfN,ioRefNum(A0)	; refnum of the Sony Disk
		MOVE.W	#ejectCode,csCode(A0)	; code for Eject
		MOVE.W	8(A6),ioDrvNum(A0)		;the drvNum of drv to be eject

		_Control
		MOVE	D0,10(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#2,SP					; fix up stack
		JMP 	(A1)

;FUNCTION SetTagBuffer(buffPtr: Ptr): OSErr;
;

SetTagBuffer FUNC	 EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	#dskRfN,ioRefNum(A0)	; refnum of the Sony Disk
		MOVE.W	#tgBuffCode,csCode(A0)	; code for SetTagBuffer
		MOVE.L	8(A6),csParam(A0)		;csParam is the buffptr

		_Control
		MOVE	D0,12(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,(SP)
		RTS

;FUNCTION DriveStatus(drvNum: INTEGER; VAR status: DrvSts): OSErr;
;

DriveStatus FUNC	EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	 SP,A0					; address of cmd block

		MOVE.W	#dskRfN,ioRefNum(A0)	; refnum of the Sony Disk
		MOVE.W	#drvStsCode,csCode(A0)	; code for SetTagBuffer
		MOVE.W	12(A6),ioDrvNum(A0) 	;the drvNum of drv to be ejected

		_Status
		MOVE	D0,14(A6)				; return the result code
		MOVE.L	8(A6),A1				; ptr to where to put the status bytes
		LEA 	csParam(A0),A0			;ptr from where to get status bytes
		MOVEQ	#22,D0					;number of bytes to move
		_BlockMove

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION GetTrapAddress(trapNum: INTEGER): LongInt;

GetTrapAddress FUNC  EXPORT

			MOVE.L	(SP)+,A1			;return address
			MOVE.W	(SP)+,D0			;trap word
			_GetTrapAddress
			MOVE.L	A0,(SP) 		;return corresponding address
			JMP 	(A1)

;PROCEDURE SetTrapAddress(trapAddr: LongInt; trapNum: INTEGER);

SetTrapAddress FUNC  EXPORT

			MOVE.L	(SP)+,A1			;return address
			MOVE.W	(SP)+,D0			;trap number
			MOVE.L	(SP)+,A0			;address
			_SetTrapAddress
			JMP 	(A1)

;FUNCTION  NGetTrapAddress(trapNum: INTEGER; tTyp: TrapType): LongInt;

NGetTrapAddress FUNC	EXPORT
		MOVE.L	(SP)+,A1			;return address
		MOVE.B	(SP)+,D1			;trap selector: 0-OSTrap 1-ToolTrap
		MOVE.W	(SP)+,D0			;trap number
		TST.B	D1					;0-OSTrap 1-ToolTrap
		BEQ.S	@1
		_GetTrapAddress newTool
		BRA.S	@3
@1
		_GetTrapAddress newOS
@3
		MOVE.L	A0,(SP) 		;return corresponding address
		JMP 	(A1)

;PROCEDURE NSetTrapAddress(trapAddr: LongInt; trapNum: INTEGER; tTyp: TrapType);

NSetTrapAddress FUNC	EXPORT
		MOVE.L	(SP)+,A1			;return address
		MOVE.B	(SP)+,D1			;trap selector: 0-OSTrap 1-ToolTrap
		MOVE.W	(SP)+,D0			;trap number
		MOVE.L	(SP)+,A0			;trap address
		TST.B	D1					;0-OSTrap 1-ToolTrap
		BEQ.S	@1
		_SetTrapAddress newTool
		BRA.S	@3
@1
		_SetTrapAddress newOS
@3
		JMP 	(A1)

;FUNCTION GetOSTrapAddress(trapNum: INTEGER): LongInt;

GetOSTrapAddress FUNC  EXPORT

		MOVE.L	(SP)+,A1			;return address
		MOVE.W	(SP)+,D0			;trap word
		_GetTrapAddress newOS
		MOVE.L	A0,(SP) 			;return corresponding address
		JMP 	(A1)

;PROCEDURE SetOSTrapAddress(trapAddr: LongInt; trapNum: INTEGER);

SetOSTrapAddress FUNC  EXPORT

		MOVE.L	(SP)+,A1			;return address
		MOVE.W	(SP)+,D0			;trap number
		MOVE.L	(SP)+,A0			;address
		_SetTrapAddress newOS
		JMP 	(A1)

;FUNCTION GetToolTrapAddress(trapNum: INTEGER): LongInt;
;FUNCTION GetToolboxTrapAddress(trapNum: INTEGER): LongInt;

GetToolTrapAddress FUNC  EXPORT
		EXPORT	GetToolboxTrapAddress
GetToolboxTrapAddress

		MOVE.L	(SP)+,A1			;return address
		MOVE.W	(SP)+,D0			;trap word
		_GetTrapAddress newTool
		MOVE.L	A0,(SP) 			;return corresponding address
		JMP 	(A1)

;PROCEDURE SetToolTrapAddress(trapAddr: LongInt; trapNum: INTEGER);
;PROCEDURE SetToolboxTrapAddress(trapAddr: LongInt; trapNum: INTEGER);

SetToolTrapAddress FUNC  EXPORT
		EXPORT	SetToolboxTrapAddress
SetToolboxTrapAddress

		MOVE.L	(SP)+,A1			;return address
		MOVE.W	(SP)+,D0			;trap number
		MOVE.L	(SP)+,A0			;address
		_SetTrapAddress newTool
		JMP 	(A1)

;FUNCTION WriteParam: OsErr;

WriteParam	FUNC  EXPORT
			LEA 	SysParam,A0 		;pointer to buffer to write to c chip
			MOVEQ	#-1,D0
			_WriteParam
			MOVE.W	D0,4(SP)				;return error
			RTS

;FUNCTION ReadDateTime(VAR time: LongInt):OsErr;

ReadDateTime	PROC	EXPORT

				MOVE.L	(SP)+,A1			;get the return address
				MOVE.L	(SP)+,A0			;get the parameter
				_ReadDateTime
				MOVE.W	D0,(SP) 		;return error
				JMP 	(A1)

;PROCEDURE GetDateTime(VAR secs: LongInt);

GetDateTime 	PROC	EXPORT

				MOVE.L	(SP)+,A1			;get the return address
				MOVE.L	(SP)+,A0			;get the parameter
				MOVE.L	Time,(A0)
				JMP 	(A1)

; FUNCTION SetDateTime(time: LongInt):OsErr;

SetDateTime 	PROC	EXPORT

				MOVE.L	(SP)+,A0			;get the return address
				MOVE.L	(SP)+,D0			;get the parameter
				_SetDateTime
				MOVE.W	D0,(SP) 		;return error
				JMP 	(A0)

;PROCEDURE SetTime(d: DateArray);

SetTime 	PROC	EXPORT

				MOVE.L	(SP)+,A1			;get the return address
				MOVE.L	(SP)+,A0			;get the parameter
				_Date2Secs					;D0 = seconds since 1904
				_SetDateTime				;clock = seconds since 1904
				JMP 	(A1)

;PROCEDURE GetTime(VAR d: DateTimeRec);

GetTime PROC		 EXPORT
					MOVE.L	(SP)+,A1			;get the return address
					MOVE.L	(SP)+,A0			;get the parameter
					MOVE.L	Time,D0 			;get time from low memory
					_Secs2Date
					JMP 	(A1)

;PROCEDURE DateToSeconds(d: DateArray; VAR s: LongInt);

DateToSeconds PROC	EXPORT

		export	Date2Secs		; obsolete old procedure name
Date2Secs
		MOVEA.L 8(SP),A0		;A0=date
		_Date2Secs				;D0=seconds elapsed
		MOVEM.L (SP)+,D1/A0-A1	;D1=ret, A0=intptr, A1=date
		MOVE.L	D0,(A0) 		;deliver result
		MOVEA.L D1,A0			;ret addr
		JMP 	(A0)

;PROCEDURE SecondsToDate(s: LongInt; VAR d: DateArray);

SecondsToDate	PROC	EXPORT
		
		export	Secs2Date			; obsolete old procedure name
Secs2Date		
		MOVEM.L (SP)+,D0/A0-A1		;D0=ret, A0=date, A1=s
		MOVE.L	D0,-(SP)			;restore return addr
		MOVE.L	A1,D0				;place D0=s
		_Secs2Date					;convert D0 to A0
		RTS

;PROCEDURE Delay(numTicks: LongInt; VAR finalTicks: LongInt);

Delay			PROC  EXPORT

				MOVE.L	(SP)+,D0			;get the return address
				MOVE.L	(SP)+,A1			;ptr to where to return result
				MOVE.L	(SP)+,A0			;numTicks
				MOVE.L	D0,-(SP)			;restore return address
				_Delay
				MOVE.L	D0,(A1) 			;return value of ticks after delay

				RTS

;FUNCTION EqualString(str1,str2: OsStr255; caseSens,diacSens: BOOLEAN):BOOLEAN;

EqualString 	FUNC	EXPORT
				MOVE.L	str1(SP),A0 		;ptr to str1
				MOVE.L	str2(SP),A1 		;ptr to str2
				MOVEQ	#0,D0
				MOVE.B	(A0)+,D0			;str1 length
				SWAP	D0
				MOVE.B	(A1)+,D0			;str2 length

				;depending on value of booleans, make proper call
				TST.B	diacSens(SP)		;value of diacSens
				BEQ.S	@2					;strip diacriticals
				TST.B	caseSens(SP)		;value of caseSens
				BEQ.S	@1					;ignore case
				_CmpString	,case			;both diacritical and case sensitive
				BRA.S	strDone

@1				_CmpString					;diacritical sensitive,map to upper case
				BRA.S	strDone

				;strip diacriticals
@2				TST.B	caseSens(SP)		;case sensitive?
				BEQ.S	@3
				_CmpString	,marks,case 	;ignore diacrits, case sensitive
				BRA.S	strDone

@3				_CmpString marks			;ignore diacrits and map to upper case

strDone 		EORI.B	#1,D0				;take opposite of what cmpString returns
				MOVE.B	D0,result(SP)		;return result

				MOVE.L	(SP)+,A0			; rtn addr
				LEA 	parmSize(SP),SP 	; pop args
				JMP 	(A0)

;PROCEDURE UprString(VAR theString: OsStr255; diacSens: BOOLEAN);

UprString		PROC  EXPORT

				MOVE.L	(SP)+,A1		;get the return address
				MOVE.B	(SP)+,D1		;diacritical sensitivity bool
				MOVE.L	(SP)+,A0		;ptr to string to canonize
				MOVEQ	#0,D0
				MOVE.B	(A0)+,D0		;string length
				MOVE.L	A1,-(SP)		;restore return address

				;decide which flavor of uprString to call and call it
				TST.B	D1
				BEQ.S	@1				;ignore diacriticals
				_UprString				;keep diacriticals
				BRA.S	@2

@1				_UprString	,marks

@2				RTS

;PROCEDURE Enqueue(qElement: QElemPtr; qHeader: QHdrPtr);

Enqueue PROC	EXPORT

		MOVE.L	(SP)+,D0
		MOVE.L	(SP)+,A1
		MOVE.L	(SP)+,A0
		MOVE.L	D0,-(SP)
		_EnQueue
		RTS

;FUNCTION Dequeue(qElement: QElemPtr; qHeader: QHdrPtr): OsErr;

Dequeue PROC	EXPORT

		MOVE.L	(SP)+,D0
		MOVE.L	(SP)+,A1
		MOVE.L	(SP)+,A0
		MOVE.L	D0,-(SP)
		_DeQueue
		MOVE.W	D0,4(SP)		;return error
		RTS

;PROCEDURE Environs(VAR rom,machine: INTEGER);

Environs PROC	 EXPORT

		MOVE.L	(SP)+,A0		;get rts
		MOVE.L	ROMBase,A1		;ROM start
		ADDQ	#8,A1			;offset to version
		MOVE	(A1),D0 		;get the version
		MOVE.L	(SP)+,A1		;get machine VAR address
		CLR 	(A1)			;assume it's a Lisa
		CMP.B	#$FF,D0 		;is it?
		BEQ.S	@0
		ROR 	#8,D0			;get machine into low byte
		ADDQ.B	#1,D0			;turn into a Mac
		MOVE.B	D0,1(A1)		;set the machine parameter
@0		LSR 	#8,D0			;get Lisa ROM version down
		MOVE.L	(SP)+,A1		;get ROM VAR address
		MOVE	D0,(A1) 		;return the ROM version
		JMP 	(A0)

;FUNCTION GetDCtlEntry(refNum: INTEGER): DCtlHandle;
; Did status 1 call to get the DCEHandle... However, hard disk
; didn't know how to handle this and would crash. Now, at the
; suggestion of Jim Friedlander, I will go directly to the UnitTable
; to get the handle 12 Jun 87 - KLH

GetDCtlEntry FUNC  EXPORT

		MOVE.L	(SP)+,A0				; return address
		MOVE.W	(SP)+,D0				; refNum
		clr.l	(sp)					; default result to nil					<10>
		NOT.W	D0						; unit entry := -1 * (refNum + 1)		<10>
		cmp.w	UnitNtryCnt,d0			; is there an entry of this number?		<10>
		bhs.s	@noEntry				; no, so return NIL						<10>
		LSL.W	#2,D0					; index := entry * 4
		MOVE.L	UTableBase,A1			; unit I/O table [pointer]
		MOVE.L	0(A1,D0.W),(SP)			; return DCtlHandle
@noEntry
		JMP 	(A0)					; RTS

;FUNCTION SetChooserAlert(f: BOOLEAN): BOOLEAN;

SetChooserAlert FUNC  EXPORT

		MOVE.L	(SP)+,A0				; return address
		MOVE.B	(SP)+,D0				; get boolean parameter
		BEQ.S	@3
		BSET	#psAlert,HiliteMode 	; now set flag true
		BRA.S	@5
@3		BCLR	#psAlert,HiliteMode 	; else set flag false
@5		SEQ		d0						; d0 = FF if it was 0, 0 if it was 1	<10>
		ADDQ.B	#1,d0					; d0.b = 0 if it was 0, 1 if it was 1	<10>
		move.b	d0,(sp)					; set that flag							<10>
		JMP 	(A0)

;
; from ioTRAPS.TEXT -- Mac OS io Interface routines for Pascal
;
; Argument- A0: param: Points to Parameter block.
;
; Results-	D0: ec: error code.
;			<0: OS Call failed.
;		 0: All is well.
; Registers- D0: ec:	 error code
;		 A0: param:  Paramater list address.
;		 A1: ra:	 Return Address.
;

				MACRO
				OSCall
				Move.L	(SP)+,A1		;get return address
.**** check this out thoroughly before changing
				Move.B	(SP)+,D0		;Get ASync flag. (why was this a word?)
				Move.L	(SP)+,A0		;get param pointer.
				BNE.S	@1
.*
				&SysLst[1]				;tell OS to do it Synchronously
				BrA.S	@2
.*
@1				&SysLst[1]		,async	;Tell OS to do it Asynchronously
@2				Move.W	D0,(SP) 		;save result
				Jmp 	(A1)			;return to caller
				ENDM

; interface routines expecting a parameter block ptr as argument
; hence the prefix PB
;
; FUNCTION PBOpen(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBClose(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBRead(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBWrite(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBControl(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBStatus(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBKillio(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
;
PBOpen			PROC  EXPORT
				OSCall _Open

PBClose 		PROC  EXPORT
				OSCall _Close

PBRead			PROC  EXPORT
				OSCall _Read

PBWrite 		PROC  EXPORT
				OSCall _Write

PBControl		PROC  EXPORT
				OSCall _Control

PBStatus		PROC  EXPORT
				OSCall _Status

PBKillio		PROC  EXPORT
				OSCall _Killio

; FUNCTION PBGetVInfo(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBGetVol(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBSetVol(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBFlushVol(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBCreate(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBDelete(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBOpenRF(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBRename(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBGetFInfo(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBSetFInfo(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBSetFLock(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBRstFLock(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBSetFVers(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBAllocate(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBGetEOF(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBSetEOF(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBGetFPos(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBSetFPos(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
; FUNCTION PBFlushFile(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;

PBGetVInfo		PROC  EXPORT
				OSCall _GetVolInfo

PBGetVol		PROC  EXPORT
				OSCall _GetVol

PBSetVol		PROC  EXPORT
				OSCall _SetVol

PBFlushVol		PROC  EXPORT
				OSCall _FlushVol

PBCreate		PROC  EXPORT
				OSCall _Create

PBDelete		PROC  EXPORT
				OSCall _Delete

PBOpenRF		PROC  EXPORT
				OSCall _OpenRF

PBRename		PROC  EXPORT
				OSCall _Rename

PBGetFInfo		PROC  EXPORT
				OSCall _GetFileInfo

PBSetFInfo		PROC  EXPORT
				OSCall _SetFileInfo

PBSetFLock		PROC  EXPORT
				OSCall _SetFilLock

PBRstFLock		PROC  EXPORT
				OSCall _RstFilLock

PBSetFVers		PROC  EXPORT
				OSCall _SetFilType

PBAllocate		PROC  EXPORT
				OSCall _Allocate

PBGetEOF		PROC  EXPORT
				OSCall _GetEOF

PBSetEOF		PROC  EXPORT
				OSCall _SetEOF

PBGetFPos		PROC  EXPORT
				OSCall _GetFPos

PBSetFPos		PROC  EXPORT
				OSCall _SetFPos

PBFlushFile 	PROC  EXPORT
				OSCall _FlushFile

; MountVolume, UnMountVolume, Eject, Offline calls can only be made synchronously
; FUNCTION PBMountVol(paramBlock: ParmBlkPtr): OsErr;
; FUNCTION PBUnMountVol(paramBlock: ParmBlkPtr): OsErr;
; FUNCTION PBEject(paramBlock: ParmBlkPtr): OsErr;
; FUNCTION PBOffLine(paramBlock: ParmBlkPtr): OsErr;

PBMountVol		PROC  EXPORT
				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get param pointer.
				_MountVol				;tell OS to do it Synchronously
				Move.W	D0,(SP) 		;save result
				Jmp 	(A1)			;return to caller

PBUnMountVol	PROC  EXPORT
				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get param pointer.
				_UnMountVol 			;tell OS to do it Synchronously
				Move.W	D0,(SP) 		;save result
				Jmp 	(A1)			;return to caller

PBEject 		PROC  EXPORT
				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get param pointer.
				_Eject					;tell OS to do it Synchronously
				Move.W	D0,(SP) 		;save result
				Jmp 	(A1)			;return to caller

PBOffLine		PROC  EXPORT
				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get param pointer.
				_Offline				;tell OS to do it Synchronously
				Move.W	D0,(SP) 		;save result
				Jmp 	(A1)			;return to caller

; PROCEDURE AddDrive(drvrRefNum: INTEGER; drvNum: INTEGER; QEl: drvQElPtr);

AddDrive		PROC  EXPORT
				MOVE.L	(SP)+,A1		;get return address
				MOVE.L	(SP)+,A0		;ptr to memory for queue element
				MOVE.L	(SP)+,D0		;drive number
				_AddDrive
				JMP 	(A1)

;FUNCTION FSOpen(fileName: Str255; versNum: SignedByte; vRefNum: INTEGER; VAR refNum: INTEGER): OSErr;

;Always try to use OpenDF (which does not open drivers) first. If it doesnÕt work, then do a
;normal Open (this is for old systems that do not implement OpenDF).

FSOpen	FUNC  EXPORT
		EXPORT	OpenDF
OpenDF

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	14(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	12(A6),ioDrvNum(A0) 	; drive number
		CLR.B	ioFileType(A0)			; file type
		CLR.B	ioPermssn(A0)			; open for read/write
		CLR.L	ioOwnBuf(A0)			; use system buffer

		_OpenDF
		cmp.w	#paramErr,d0			; paramErr indicates that this OpenDF is not implemented
		bne.s	@continue
		_Open							; use the old-style open
@continue

		MOVE.L	8(A6),A1				; return the refnum
		MOVE	ioRefNum(A0),(A1)
		MOVE	D0,18(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A0				; return address
		LEA 	10(SP),SP				; fix up stack
		JMP 	(A0)

;FUNCTION FSClose(refNum: INTEGER): OsErr;

FSClose FUNC  EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block
		MOVE	8(A6),ioRefNum(A0)		; get the refnum param
		_Close
		MOVE	D0,10(A6)				; return the result code
		UNLK	A6
		MOVE.L	(SP)+,A0				; return address
		ADDQ.L	#2,SP					; fix up stack
		JMP 	(A0)

;FUNCTION FSRead(refNum: INTEGER; VAR count: LongInt; buffPtr: Ptr): OsErr;
;FUNCTION FSWrite(refNum: INTEGER; VAR count: LongInt; buffPtr: Ptr): OsErr;

FSRead	FUNC  EXPORT
		EXPORT FSWrite

		SF		D1						; set up read
		BRA.S	DoBlk

FSWrite
		ST		D1						; set up write

DoBlk
		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	8(A6),ioBuffer(A0)		; buffer address
		MOVE.W	16(A6),ioRefNum(A0) 	; refnum
		MOVE.L	12(A6),A1				; address of the count
		MOVE.L	(A1),ioByteCount(A0)	; read count
		CLR.W	ioPosMode(A0)			; no special mode
		CLR.L	ioPosOffset(A0) 		; clear offset

		TST.B	D1						; look for read or write
		BNE.S	@1
		_READ
		BRA.S	@2
@1		_WRITE
@2
		MOVE	D0,18(A6)				; return the result code

		MOVE.L	12(A6),A1				; address of the count
		MOVE.L	ioNumDone(A0),(A1)		; return count read

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA    10(SP),SP				; fix up stack
		JMP 	(A1)

;FUNCTION Control(refNum: INTEGER; csCode: INTEGER; csParamPtr: Ptr): OsErr;

Control FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	14(A6),ioRefNum(A0) 	; refnum
		MOVE.W	12(A6),csCode(A0)		; the control operation to be performed
		TST.L	8(A6)					; see if there is a parameter block
		BEQ.S	@1						; if not, don't bother copying one
		LEA 	csParam(A0),A1			; dest address of op specific params
		MOVE.L	8(A6),A0				; src address of op specific params
		MOVEQ	#22,D0					; max number of bytes to be moved
		_BlockMove						; copy the op specific params
		LEA 	-ioQElSize(A6),A0		; put cmd block addr back into A0

@1		_CONTROL
		MOVE	D0,16(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	 #8,SP					; fix up stack
		JMP 	(A1)

;FUNCTION Status(refNum: INTEGER; csCode: INTEGER; csParamPtr: Ptr): OsErr;

Status	FUNC  EXPORT					;analogous to MacControl but returns
										;opParams rather than expecting it as arg

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	14(A6),ioRefNum(A0) 	; refnum
		MOVE.W	12(A6),csCode(A0)		; the control operation to be performed
		_STATUS
		MOVE	D0,16(A6)				; return the result code
		LEA 	csParam-ioQElSize(A6),A0 ;ptr to the status information
		MOVE.L	8(A6),A1				; ptr to where to put this information
		MOVEQ	#22,D0					; max number of bytes to be moved
		_BlockMove						; copy the op specific params

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	 #8,SP					; fix up stack
		JMP 	(A1)

;FUNCTION KillIO(refNum: INTEGER): OsErr;

KillIO	FUNC	EXPORT

		LINK	A6,#-32				;get space for control p-block
		MOVE.L	SP,A0 				;point A0 at the block
		MOVE.W	8(A6),ioRefNum(A0)  ; refnum
		_KillIO						; make the control call
		MOVE	D0,10(A6)			; return the result code
		UNLK	A6
		MOVE.L  (SP)+,A1			; return address
		ADDQ	#2,SP				; fix up stack
		JMP		(A1)

;FUNCTON GetVInfo(drvNum: INTEGER; volName: StringPtr; VAR vRefNum: INTEGER; VAR freeBytes: LongInt): OsErr;

GetVInfo FUNC  EXPORT

		LINK	A6,#-ioHVQElSize		; BUG FIX, NEED MORE ROOM FOR HParamBlock
		MOVE.L	SP,A0				 	; BUG FIX, NEED MORE ROOM FOR HParamBlock
		MOVE.L	16(A6),ioVNPtr(A0)		; volume name pointer
		MOVE.W	20(A6),ioVDrvNum(A0)	; drive number
		CLR.W	ioVolIndex(A0)			; no volume queue index
		_HGetVInfo 						; make the control call
		MOVE	D0,22(A6)				; return the result code
		MOVE.L	12(A6),A1				; pointer to vRefNum
		MOVE.W	ioVRefNum(A0),(A1)		; return volume ref num

		;now calculate the number of free bytes on the volume by multiplying
		;allocation block size * free allocation blocks
		;would ideally like to multiply long * integer but since MULU only
		;multiplies two ints, to allow for a larger than 16 bit allocation
		;block size we shift it right by 9 (since we know it to be a multiple
		;of 512 and then shift the result back.

		MOVE.L	ioVAlBlkSiz(A0),D0		;num bytes in an allocation block
		MOVEQ.L	#9,D1 					;shift over by 8
		ASR.L	D1,D0					;and one more
		MULU	ioVFrBlk(A0),D0 		;multiply by number of free blocks
		ASL.L	D1,D0					;shift back to the left
		MOVE.L	8(A6),A1				;pointer to free bytes
		MOVE.L	D0,(A1) 				;return the value

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA		14(SP),SP				; fix up stack
		JMP		(A1)

;FUNCTION GetFInfo(fileName: Str255; versNum: SignedByte; vRefNum: INTEGER; VAR fndrInfo: FInfo):OsErr;

GetFInfo FUNC	 EXPORT

		LINK	A6,#-ioFQElSize		 	; make room on stack for cmd block
		MOVE.L 	SP,A0					; address of cmd block

		MOVE.L	14(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	12(A6),ioVRefNum(A0)	; set volume ref num
		CLR.B	ioFileType(A0)			; (version field)
		CLR.W	ioFDirIndex(A0) 		;clear directory index

		_GetFileInfo					;get the info
		MOVE	D0,18(A6)				; return the result code

		;transfer the user defined finder info words (16 bytes) into result
		LEA 	ioFlUsrWds(A0),A0		;where to copy from
		MOVE.L	8(A6),A1				;where to copy to
		MOVEQ	#16,D0					; 16 bytes of information
		_BlockMove

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA 	10(SP),SP				; fix up stack
		JMP 	(A1)

;FUNCTION GetVol(volName: StringPtr; VAR vRefNum: INTEGER):OsErr;

GetVol	FUNC	EXPORT

		LINK	A6,#-ioVQElSize 		; get space for control p-block
		MOVE.L	SP,A0					; point A0 at the block
		MOVE.L 12(A6),ioVNPtr(A0)		; pointer to volume name pointer
		_GetVol							; make the control call
		MOVE	D0,16(A6)				; return the result code
		MOVE.L	8(A6),A1				; pointer to drive number
		MOVE.W	ioVRefNum(A0),(A1)		; return drive number

		UNLK	 A6
		MOVE.L  (SP)+,A1				; return address
		ADDQ.L  #8,SP					; fix up stack
		JMP		(A1)

;FUNCTION SetVol(volName: StringPtr; vRefNum: INTEGER): OsErr;

SetVol	FUNC	EXPORT

		LINK	A6,#-ioVQElSize 		;get space for control p-block
		MOVE.L	SP,A0					; point A0 at the block
		MOVE.L 10(A6),ioVNPtr(A0)		; ptr to desired volume name
		MOVE.W 8(A6),ioVRefNum(A0) 		; desired default drive number
		_SetVol							; make the control call
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L  (SP)+,A1				; return address
		ADDQ.L  #6,SP					; fix up stack
		JMP	 	(A1)

;FUNCTION UnmountVol(VolName: StringPtr; vRefNum: INTEGER):OsErr;

UnMountVol FUNC    EXPORT

		LINK	A6,#-ioVQElSize 		;get space for control p-block
		MOVE.L	SP,A0					; point A0 at the block
		MOVE.W	8(A6),ioVRefNum(A0) 	; drive to be unmounted
		MOVE.L	10(A6),ioVNPtr(A0)		; volume name pointer
		_UnmountVol
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L  (SP)+,A1				; return address
		ADDQ.L  #6,SP					; fix up stack
		JMP		(A1)

;FUNCTION Eject(VolName: StringPtr; vRefNum: INTEGER): OSErr;

Eject	FUNC	EXPORT

		LINK	A6,#-ioVQElSize 		; get space for control p-block
		MOVE.L	SP,A0					; point A0 at the block
		MOVE.W	8(A6),ioVRefNum(A0) 	; drive to be unmounted
		MOVE.L	10(A6),ioVNPtr(A0)		; volume name pointer
		_Eject
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L  (SP)+,A1				; return address
		ADDQ.L  #6,SP					; fix up stack
		JMP	 	(A1)

;FUNCTION FlushVol(VolName: StringPtr; vRefNum: INTEGER): OSErr;

FlushVol FUNC	 EXPORT

		LINK	A6,#-ioVQElSize 		; get space for control p-block
		MOVE.L	SP,A0					; point A0 at the block
		MOVE.W	8(A6),ioVRefNum(A0) 	; drive to be unmounted
		MOVE.L	10(A6),ioVNPtr(A0)		; volume name pointer
		_FlushVol
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L  (SP)+,A1				; return address
		ADDQ.L  #6,SP					; fix up stack
		JMP	 	(A1)

;FUNCTION Create(fileName: Str255; vRefNum: INTEGER; creator: OSType; fileType: OSType): OSErr;

Create	FUNC  EXPORT

		LINK	A6,#-ioFQElSize			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	18(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	16(A6),ioVRefNum(A0)	; set volume ref num
		CLR.B	ioFileType(A0)			; clear type, permissions (version field)

		_Create
		BNE.S	crDone					;yes, don't bother setting type

		CLR.W	ioFDirIndex(A0) 		;clear directory index
		_GetFileInfo					;get the previous info
		BNE.S	crDone					;if we failed, return error						<10>

		;transfer the user defined finder info words (16 bytes)
		LEA 	ioFlUsrWds(A0),A1		;where to copy user words
		MOVE.L	8(A6),(A1)+ 			;enter in the new file type
		MOVE.L	12(A6),(A1) 			;enter in the new file creator
		_SetFileInfo

crDone
		MOVE	D0,22(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA 	14(SP),SP				; fix up stack
		JMP 	(A1)

;FUNCTION FSDelete(fileName: OsStr255; vRefNum: INTEGER):OsErr;

FSDelete FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	10(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	8(A6),ioVRefNum(A0) 	; set volume ref num
		CLR.B	ioFileType(A0)			; clear type, permissions (version field)

		_Delete
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION OpenRF(fileName: Str255; vRefNum: INTEGER; VAR refNum: INTEGER): OSErr;

OpenRF	FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	14(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	12(A6),ioVRefNum(A0)	; set volume ref num
		CLR.B	ioFileType(A0)			; clear type, permissions (version field)
		CLR.B	ioPermssn(A0)			; open for read/write
		CLR.L	ioOwnBuf(A0)			; use system buffer

		_OpenRF
		MOVE	D0,18(A6)				; return the result code
		MOVE.L	8(A6),A1				; ptr to refNum
		MOVE.W	ioRefNum(A0),(A1)		; return the refNum

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA 	10(SP),SP				; fix up stack
		JMP 	(A1)

;FUNCTION Rename(oldName: Str255; vRefNum: INTEGER; newName: Str255):OsErr;

Rename	FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	14(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	12(A6),ioVRefNum(A0)	; set volume ref num
		CLR.B	ioFileType(A0)			; clear type, permissions (version field)
		MOVE.L	8(A6),ioNewName(A0) 	; new name to give to file

		_Rename
		MOVE	D0,18(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA 	10(SP),SP				; fix up stack
		JMP 	(A1)

;FUNCTION SetFInfo(fileName: Str255; vRefNum: INTEGER; fndrInfo: FInfo): OSErr;

SetFInfo FUNC  EXPORT

		LINK	A6,#-ioFQElSize			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	14(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	12(A6),ioVRefNum(A0)	; set volume ref num
		CLR.B	ioFileType(A0)			; (version field)
		CLR.W	ioFDirIndex(A0) 		;clear directory index

		_GetFileInfo					;get the previous info

		;transfer the user defined finder info words (16 bytes)
		LEA 	ioFlUsrWds(A0),A1		;where to copy user words
		MOVE.L	8(A6),A0				;where the user words are now
		MOVEQ	#16,D0					; 16 bytes of information
		_BlockMove
		MOVE.L 	SP,A0					;restore A0

		_SetFileInfo
		MOVE	D0,18(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		LEA 	10(SP),SP				; fix up stack
		JMP 	(A1)

;FUNCTION SetFLock(fileName: Str255; vRefNum: INTEGER): OSErr;

SetFLock FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	10(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	8(A6),ioVRefNum(A0) 	; set volume ref num
		CLR.B	ioFileType(A0)			; clear type, permissions (version field)

		_SetFilLock
		MOVE.W	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)


;FUNCTION RstFLock(fileName: Str255;	vRefNum: INTEGER): OSErr;

RstFLock FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	10(A6),ioFileName(A0)	; set ptr to filename
		MOVE.W	8(A6),ioVRefNum(A0) 	; set volume ref num
		CLR.B	ioFileType(A0)			; clear type, permissions (version field)

		_RstFilLock
		MOVE.W	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION Allocate(refNum: INTEGER; VAR count: LongInt): OSErr;

Allocate FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.L	8(A6),A1				;ptr to requested byte count
		MOVE.L	(A1),ioReqCount(A0)
		MOVE.W	12(A6),ioRefNum(A0) 	; set refnum

		_Allocate
		MOVE	D0,14(A6)				; return the result code
		MOVE.L	ioActCount(A0),(A1) 	; return actual byte count

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION GetEOF(refNum: INTEGER; VAR LogEOF: LongInt): OSErr;
GetEOF	FUNC  EXPORT

		LINK	A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	12(A6),ioRefNum(A0) 	; set refnum

		_GetEOF
		MOVE	D0,14(A6)				; return the result code
		MOVE.L	8(A6),A1				;ptr to logical length variable
		MOVE.L	ioLEOF(A0),(A1) 		;return logical end of file

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION SetEOF(refNum: INTEGER; logEOF: LongInt): OSErr;

SetEOF	FUNC  EXPORT

		LINK	A6,#-ioQElSize 			; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	12(A6),ioRefNum(A0) 	; set refnum
		MOVE.L	8(A6),ioLEOF(A0)		; the desired end of file

		_SetEOF
		MOVE	D0,14(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)

;
;FUNCTION GetFPos(refNum: INTEGER; VAR filePos: LongInt):OsErr;
;
GetFPos FUNC  EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	12(A6),ioRefNum(A0) 	; set refnum

		_GetFPos
		MOVE	D0,14(A6)				; return the result code
		MOVE.L	8(A6),A1				;ptr to logical length variable
		MOVE.L	ioPosOffset(A0),(A1)	;return logical end of file

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#6,SP					; fix up stack
		JMP 	(A1)

;FUNCTION SetFPos(refNum: INTEGER; posMode: INTEGER; posOff: LongInt): OSErr;

SetFPos FUNC  EXPORT

		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
		MOVE.L	SP,A0					; address of cmd block

		MOVE.W	14(A6),ioRefNum(A0) 	; set refnum
		MOVE.W	12(A6),ioPosMode(A0)	; positioning information
		MOVE.L	8(A6),ioPosOffset(A0)	; new file position

		_SetFPos
		MOVE	D0,16(A6)				; return the result code

		UNLK	A6
		MOVE.L	(SP)+,A1				; return address
		ADDQ.L	#8,SP					; fix up stack
		JMP 	(A1)

;FUNCTION  GetVRefNum(fileRefNum: INTEGER; VAR vRefNum: INTEGER):OSErr;
;
; There was originally checking for valid refnums. However, when we went to
; HFS from MFS, the block size changed and the checking was commented out. This
; allowed some error to creep in, so we put INTELLIGENT checking back in. We
; check the size a block should be first! 9 Aug 88 - KLH

GetVRefNum		FUNC	EXPORT
				MOVE.L	(SP)+,A1		;return addr
				MOVEQ	#0,D1			;clear high word
				MOVE.W	4(SP),D1		;get the fileRefNum
				MOVE.L	FCBSPtr,A0		;ptr to file-control-block buffer
				MOVE.W	FSFCBLen,D0 	;get size of file control blocks
				BMI.S	mfs 			;-1 => MFS, so use fixed size
				DIVU	D0,D1			;see if valid refnum
				BRA.S	hfs 			; go test results
mfs 			DIVU	#fcbEntLen,D1	;old way: use fixed block size
hfs 			SWAP	D1 				;continue with divide analysis: remainder
				SUBQ.W	#2,D1			; should have been 2 for # of blocks.
				BNE.S	endError
				MOVE.W	4(SP),D0		;get fileRefNum again.
				CMP.W	(A0),D0 		;is refNum too large?
				BCC.S	endError		;br if so
				MOVE.L	fcbVPtr(A0,D0),A0	;get ptr to volume control block
				MOVE.W	vcbVRefNum(A0),D0	;return vRefNum
				MOVEQ	#0,D1			;no err
				BRA.S	endG
endError		MOVEQ	#0,D0			;default refum
				MOVE	#rfNumErr,D1		;ref num error
endG			MOVE.L	(SP),A0 		;get vRefNum address
				MOVE	D0,(A0) 		;put it there
				ADDQ	#6,SP			;remove passed parameters
				MOVE	D1,(SP) 		;post the error
				JMP 	(A1)			;go home

;_______________________________________________________________________
;
; Function: 	This section contains the Hierarchical File System trap macros.
;_______________________________________________________________________

;FUNCTION  PBOpenWD(paramBlock: WDPBPtr; aSync: BOOLEAN): OsErr;
PBOpenWD		PROC EXPORT
				OSCall _OpenWD
;FUNCTION  PBCloseWD(paramBlock: WDPBPtr; aSync: BOOLEAN): OsErr;
PBCloseWD		PROC EXPORT
				OSCall _CloseWD
;FUNCTION  PBHSetVol(paramBlock: WDPBPtr; aSync: BOOLEAN): OsErr;
PBHSetVol		PROC EXPORT
				OSCall _HSetVol
;FUNCTION  PBHGetVol(paramBlock: WDPBPtr; aSync: BOOLEAN): OsErr;
PBHGetVol		PROC EXPORT
				OSCall _HGetVol
;FUNCTION  PBCatMove(paramBlock: CMovePBPtr; aSync: BOOLEAN): OsErr;
PBCatMove		PROC EXPORT
				OSCall _CatMove
;FUNCTION  PBDirCreate(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBDirCreate 	PROC EXPORT
				OSCall _DirCreate
;FUNCTION  PBGetWDInfo(paramBlock: WDPBPtr; aSync: BOOLEAN): OsErr;
PBGetWDInfo PROC EXPORT
				OSCall _GetWDInfo
;FUNCTION  PBGetFCBInfo(paramBlock: FCBPBPtr; aSync: BOOLEAN): OsErr;
PBGetFCBInfo		PROC EXPORT
				OSCall _GetFCBInfo
;FUNCTION  PBGetCatInfo(paramBlock: CInfoPBPtr; aSync: BOOLEAN): OsErr;
PBGetCatInfo	PROC EXPORT
		OSCall _GetCatInfo

;FUNCTION  PBSetCatInfo(paramBlock: CInfoPBPtr; aSync: BOOLEAN): OsErr;
PBSetCatInfo		PROC EXPORT
				OSCall _SetCatInfo
;FUNCTION  PBAllocContig(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
PBAllocContig	PROC EXPORT
				OSCall _AllocContig
;FUNCTION  PBLockRange(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
PBLockRange 	PROC EXPORT
				OSCall _LockRng
;FUNCTION  PBUnLockRange(paramBlock: ParmBlkPtr; aSync: BOOLEAN): OsErr;
PBUnLockRange		PROC EXPORT
				OSCall _UnLockRng

;FUNCTION  PBSetVInfo(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBSetVInfo		PROC EXPORT
				OSCall _SetVolInfo
;FUNCTION  PBHGetVInfo(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHGetVInfo 	PROC EXPORT
				OSCall _HGetVInfo
;FUNCTION  PBHOpen(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHOpen 	PROC EXPORT
				OSCall _HOpen
;FUNCTION  PBHOpenRF(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHOpenRF	PROC EXPORT
				OSCall _HOpenRF
;FUNCTION  PBHCreate(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHCreate	PROC EXPORT
				OSCall _HCreate
;FUNCTION  PBHDelete(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHDelete		PROC EXPORT
				OSCall _HDelete
;FUNCTION  PBHRename(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHRename		PROC EXPORT
				OSCall _HRename
;FUNCTION  PBHRstFLock(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHRstFLock 	PROC EXPORT
				OSCall _HRstFLock
;FUNCTION  PBHSetFLock(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHSetFLock 	PROC EXPORT
				OSCall _HSetFLock
;FUNCTION  PBHGetFInfo(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHGetFInfo 	PROC EXPORT
				OSCall _HGetFileInfo
;FUNCTION  PBHSetFInfo(paramBlock: hParmBlkPtr; aSync: BOOLEAN): OsErr;
PBHSetFInfo 	PROC EXPORT
				OSCall _HSetFileInfo
;FUNCTION  PBHGetVolParms(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHGetVolParms	PROC EXPORT
				OSCall _GetVolParms
;FUNCTION  PBHGetLogInInfo(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHGetLogInInfo PROC EXPORT
				OSCall _GetLogInInfo
;FUNCTION  PBHGetDirAccess(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHGetDirAccess PROC EXPORT
				OSCall _GetDirAccess
;FUNCTION  PBHSetDirAccess(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHSetDirAccess PROC EXPORT
				OSCall _SetDirAccess
;FUNCTION  PBHMapID(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHMapID		PROC EXPORT
				OSCall _MapID
;FUNCTION  PBHMapName(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHMapName		PROC EXPORT
				OSCall _MapName
;FUNCTION  PBHCopyFile(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHCopyFile 	PROC EXPORT
				OSCall _CopyFile
;FUNCTION  PBHMoveRename(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHMoveRename	PROC EXPORT
				OSCall _MoveRename
;FUNCTION  PBHOpenDeny(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHOpenDeny 	PROC EXPORT
				OSCall _OpenDeny
;FUNCTION  PBHOpenRFDeny(paramBlock: hParmBlkPtr; async: BOOLEAN): OSErr;
PBHOpenRFDeny	PROC EXPORT
				OSCall _OpenRFDeny

PBCreateFileIDRef	proc	export
				OSCall	_CreateFileIDRef

PBDeleteFileIDRef	proc	export
				OSCall	_DeleteFileIDRef

PBResolveFileIDRef	proc	export
				OSCall	_ResolveFileIDRef

PBExchangeFiles proc	export
				OSCall	_ExchangeFiles

PBCatSearch 	proc	export
				OSCall	_CatSearch

PBGetForeignPrivs	proc	export
				OSCall	_GetForeignPrivs

PBSetForeignPrivs	proc	export
				OSCall	_SetForeignPrivs

PBOpenDF		proc	export
				OSCall	_OpenDF

PBHOpenDF		proc	export
				OSCall	_HOpenDF

PBMakeFSSpec	proc	export
				OSCall	_MakeFSSpec

; The Desktop Manager param block routines

; PBDTGetPath	sync only call has inline glue	<9>
; PBDTCloseDown sync only call has inline glue	<9>

PBDTAddIcon 	proc	export
				OSCall	_DTAddIcon

PBDTGetIcon 	proc	export
				OSCall	_DTGetIcon

PBDTGetIconInfo proc	export
				OSCall	_DTGetIconInfo

PBDTAddAPPL 	proc	export
				OSCall	_DTAddAPPL

PBDTRemoveAPPL	proc	export
				OSCall	_DTRemoveAPPL

PBDTGetAPPL 	proc	export
				OSCall	_DTGetAPPL

PBDTSetComment	proc	export
				OSCall	_DTSetComment

PBDTRemoveComment proc	export
				OSCall	_DTRemoveComment

PBDTGetComment	proc	export
				OSCall	_DTGetComment

PBDTFlush		proc	export
				OSCall	_DTFlush

PBDTReset		proc	export
				OSCall	_DTReset

PBDTGetInfo 	proc	export
				OSCall	_DTGetInfo

; PBDTOpenInform	sync only calls has inline glue <9>

PBDTDelete		proc	export
				OSCall	_DTDelete

;The following are the implementation of the event mgr routines that are
;register based as oposed to stack based
;They are included here because they are OSTraps, however the interfaces for
;them are in toolIntf
;
;  FUNCTION PostEvent(eventNum: INTEGER; eventMsg: LongInt): OsErr;

PostEvent		PROC	EXPORT

				MOVE.L	(SP)+,A1		;A1 is return address
				MOVE.L	(SP)+,D0		;32-bit quantity defined by the event
				MOVE.W	(SP)+,A0		;word of event number
				_POSTEVENT
				MOVE.W	D0,(SP)			;return 0=event posted; 1=not posted
				JMP		(A1)

; FUNCTION PPostEvent(eventCode: INTEGER; eventMsg: LONGINT; VAR qEl: EvQEl): OSErr;

PPostEvent	PROC	EXPORT
		MOVE.L		(SP)+,D1			; return address, for now
		MOVE.L		(SP)+,A1			; qEl
		MOVE.L		(SP)+,D0			; eventMsg
		MOVE.W		(SP)+,A0			; eventCode
		MOVE.L		D1,-(SP)			; restore return address
		_PPostEvent
		MOVE.L		A0,(A1) 			; stuff returned qEl ptr
		MOVE.W		D0,4(SP)			; stuff return code
		RTS

;FUNCTION OSEventAvail(mask: INTEGER; VAR theEvent: EventRecord): BOOLEAN;

OSEventAvail	FUNC  EXPORT

		MOVE.L	(SP)+,A1		;return address
		MOVE.L	(SP)+,A0		;user event record
		MOVE.W	(SP)+,D0		;event mask (set of events desired)
		_OSEventAvail
		ADDQ.W	#1,D0
		MOVE.B	D0,(SP)
		JMP		(A1)

;FUNCTION GetOSEvent(mask: INTEGER; VAR theEvent: EventRecord): BOOLEAN;

GetOSEvent		FUNC  EXPORT

				MOVE.L	(SP)+,A1		;return address
				MOVE.L	(SP)+,A0		;user event record
				MOVE.W	(SP)+,D0		;event mask (set of events desired)
				_GetOSEvent
				ADDQ.W	#1,D0
				MOVE.B	D0,(SP)
				JMP (A1)

; Sound Manager interface implementation
;
; PROCEDURE SetSoundVol(level: INTEGER);

SetSoundVol 	PROC	EXPORT

				MOVE.L	(SP)+,A0			;get return address
				MOVE.W	(SP)+,D0			;get the volume
				MOVE.L	A0,-(SP)			;replace return address

				LINK	A6,#-32 			;get some space for the control p-block
				MOVE.L	SP,A0				;point A0 at the block
				MOVE.W	#-4,ioRefNum(A0)	;set up the sound driver refNum
				MOVE.W	#2,csCode(A0)		;set up the control "opCode"
				MOVE.W	D0,csParam(A0)		;set up event ptr as parameter
				_Control immed				;make the control call

				UNLK	A6					;de-allocate parameter block
				RTS

; PROCEDURE GetSoundVol(VAR level: INTEGER);
; actually, SdVolume is a byte.

GetSoundVol 	PROC	EXPORT

				MOVE.L	(SP)+,A0			;get return address
				MOVE.L	(SP)+,A1			;ptr to result
				CLR.B	(A1)+				;clear high byte
				MOVE.B	SdVolume,(A1)		;return volume level in low byte
				JMP 	(A0)

;PROCEDURE StartSound(synthRec: Ptr; numBytes: LongInt; CompletionRtn: ProcPtr);

StartStuff	PROC 	 EXPORT
			EXPORT	  StartSound, StopSound

;realSize set to 0 means that the parameter block is busy; the competion routine can
;not be executed while the sound handle is inconsistent

myPBlock  EQU		 0					;50 bytes total, init ioResult to be NIL
realSize  EQU		 myPBlock+50		;what SetHandleSize means in a completion routine
IAZ 	  EQU		 realSize+2 		;salted away IAZNotify routine
intrupt   EQU		 IAZ+4				;an interrupt routine tried to execute?
noIntrupt EQU		 intrupt+1			;interrupt routines not allowed to execute
blkSize   EQU		 noIntrupt+1

;set up the parameter block if it is free, otherwise queue up the request
;note that synchronous calls do not get queued up.	We just loop around
;until all pending calls are done and then make the call.  This is because
;you cannot start up a synchronous call in a VBL task
;
; 13mar87 - There was a bug in StartSound that moved only half of MinusOne
; into SoundHdl, so the following StartSound would fail the CMPA.L MinusOne
; test. That was fixed by doing a MOVE.L MinusOne,SoundHdl down by ThrowAway.
; However, code using the original incorrect glue will still break future
; applications, so we now test only for the upper half of SoundHdl having
; -1 in it. Extra work, but bulletproof.
;
;	9 Dec 88	John Dance finds StartSound is leaving a handle locked
; in the middle of the MPW shell application heap. Not all paths through
; Start & StopSound dispose of the handle. Most places that had jumped to
; ssDone (sound done) now include a path to throwAway. - KLH

StartSound
		  MOVE.L	SoundHdl,A0    ;something like $0040 if uninitialized

; Keithen had a CMP.W MinusOne,A0 here, thinking that it checked only the high word of A0.
; Unfortunately all operations on address registers are done on the whole long word, so it
; never worked. Instead, we now use the high bit to tell if it is initialized or not. <10>

			move.l	a0,d0			;													<10>
			BPL.S 	inited		   ;a0 != $FFFFFFFF => initialize

		  MOVEQ 	#blkSize,D0    ;enough for a single call for starters
		  _NewHandle ,clear
		  bne		quit		;but can't dispose handle if didn't allocate!

		  _HLock
		  MOVE.L	A0,SoundHdl    ;salt away in low memory for next time

;Install code in IAZNotify so that SoundHdl can be reset to ROMBase when the
;application heap is scrubbed
		  MOVE.L	(A0),A1
		  MOVE.L	IAZNotify,IAZ(A1) ;keep old one so it can be called as well
		  LEA		ClrSoundHdl,A1 ;routine to clean up after we leave
		  MOVE.L	A1,IAZNotify

inited	  MOVE.L	(A0),A1    ;the record mp, always good (not purgable)
		  TST.W 	ioResult(A1)   ;ioResult is 0 if blk is free
		  BLE		blkFree    ;or if an error had occurred

; parameter block is not free, queue this request up if it is asynchronous. If it is
; synchronous, loop until everything else is done and then start it up

; If a completion routine trys to execute while the paramblk handle is being
; increased in size, the data would be inconsistent.  To avoid this, a pair of
; flags, intrupt and noIntrupt, arbitrate between the synchronous call
; StartSound and the asynchronous MyCompletion to determine when it is safe for
; MyCompletion to execute.	If MyCompletion interrupts StartSound while
; the param block handle is being moved, then MyCompletion is called by
; StartSound after the data is made consistent.  A copy of the handle is created
; rather than growing the existing handle since it would be bad for the original
; handle to be locked while it is grown since this would likely fail, and it
; can not be unlocked since ioCore will still try to look at dCtlQHead at
; interrupt time.  Also, since a new handle is created each time a new call
; is made, the handle can't be moved high or low since the one already high
; or low can't be freed up until after the new one is locked down.
;
;	9 Dec 88	Test for full -1 in completion routine due to bug reported by
; Jay Zipnick & Brian Baker of ICOM Simulations. Passing a Ptr with the high
; bit set doesn't seem to be a good idea, but isn't necessarily wrong yet. - KLH

		  MOVE.L	4(SP),D1	   ;the completion rtn
;		   BMI.S		sndWait    ;oops, what if high bit set, but good address?
		  CMP.L 	MinusOne,D0 	; only full -1 => async
		  Beq.w 	sndWait 		;branch if -1 to handle async				<SM3> rb

		  ST		noIntrupt(A1)  ;make completion routine do nothing
		  MOVE		realSize(A1),D1

		  MOVE.L	A0,D2	   ;save the handle to the old one
		  MOVEM.L	D1/D2,-(SP)
		  _HandToHand
		  MOVEM.L	(SP)+,D1/D2
		  TST		D0
		  BNE		ssDone

		  ;??? In doing HandToHand & SetHandleSize to add new sound parameter
		  ; block, if there is an error (BNE ssDone): we will do a throwaway,
		  ; but could conceivably have the noIntrupt flags set and a completion
		  ; routine that came in and not executed. So we should have done the
		  ; clearing of flags and testing to see if we needed a completion
		  ; routine executed. ??? Save for re-write of StartSound. 12/12/88

		  MOVEQ 	#0,D0
		  ADD		#12,D1	   ;make room for the next entry
		  MOVE		D1,D0	   ;save the size
		  _SetHandleSize	   ;make it bigger (or smaller, or the same)
		  BNE		ssDone	   ;quit if couldn't do it
		  _HLock
		  MOVE.L	A0,SoundHdl
		  MOVE.L	(A0),A1    ;ptr to the queue

		  MOVE.L	SoundDCE,A0    ;the sound driver's DCE
		  MOVE.L	A1,dCtlQHead(A0)
		  MOVE.L	A1,dCtlQTail(A0)

		  MOVE.L	D2,A0	   ;get back old handle
		  MOVE.L	(A0),A0
		  MOVE.B	intrupt(A0),D0
		  OR.B		D0,intrupt(A1) ;just in case

		  MOVE.L	D2,A0
		  _DisposHandle

		  MOVE		D1,realSize(A1) ;keep track of real size for completion
		  BCLR		#0,intrupt(A1) ;was it interrupted?
		  BEQ.S 	notIntrupt	   ;everything is just OK

; since routine was interrupted, clear ioResult since copy may have it still
; set busy
		  CLR		ioResult(A1)
		  JSR		myCompletion   ;go take care of completion request
notIntrupt
		  SF		noIntrupt(A1)  ;allow completion routine to interrupt
		  ADD		D1,A1	   ;add in offset to end of prev data
		  MOVEQ 	#12,D0	   ;number of bytes to copy
		  SUB		D0,A1
		  LEA		4(SP),A0	   ;ptr to the args
		  _BlockMove
		  BRA.S 	quit	   ;done queueing up, exit

			; Index off of ioResult(A1) instead of A0, bug called in to
			; Darin Adler. <KLH> 19 Oct 88.
sndWait   MOVE.W	ioResult(A1),D0 	;see if sound is done yet
		  BGT.S 	sndWait    ;nope, loop on.

blkFree   MOVE.L	A1,A0
		  MOVE		#blkSize,realSize(A0)
		  MOVE.L	8(SP),ioByteCount(A0)	;numbytes
		  MOVE.L	12(SP),ioBuffer(A0) 	;the synthesizer rec
		  MOVE.W	#-4,ioRefNum(A0)		;sound driver refNum
		  MOVE.L	4(SP),D1	   ;the completion rtn
;		   BPL.S		doAsync
		  CMP.L 	MinusOne,D1 	; only full -1 => async
		  Bne.S 	doAsync 		;fall through if -1 to handle synchronous

		  _Write		   ;synchronous write
;		   BRA.S		tstDone ;12/9/88 hmm.. why not go right to bsr throwAway?
		  BRA.S 	realDone	;must free up handle, even if error.

doAsync   MOVE.L	D1,ioOwnBuf(A0) 	;save their compl rtn in ownBuff
		  LEA		myCompletion,A1 	;my completion routine
		  MOVE.L	A1,ioCompletion(A0)
		  _Write	,async	   ;asynchronous write
tstDone   TST		D0		   ;set condition code if error

ssDone	  BEQ.S 	quit
realDone  BSR.S 	throwAway	   ;if an error occurs along the way, just give up

quit	  MOVE.L	(SP)+,A1
		  ADD		#12,SP
		  JMP		(A1)

throwAway
		  MOVE.L	SoundHdl,A0    ;something like $0040 if uninitialized

;		  CMPA.L	MinusOne,A0 	;
		  CMPA.W	MinusOne,A0    ;only compare word to allow for old bug.
		  BEQ.S 	goHome			;if already nuked, go on

		  MOVE.L	(A0),A1
		  MOVE.L	IAZ(A1),IAZNotify ;fix up IAZNotify before we go
		  _DisposHandle

		  MOVE.L	MinusOne,SoundHdl ;and mark low memory as unused

goHome	  RTS

;
; PROCEDURE StopSound;
;
StopSound

		  LINK		A6,#-32    ;get some space for the control p-block
		  LEA		-32(A6),A0	   ;point A0 at the block
		  MOVE.W	#-4,ioRefNum(A0) ;set up the sound driver refNum
		  _Killio	,immed	   ;make the control call

;so next StartSound with same Pitch square wave will appear to have different pitch
		  CLR.W 	CurPitch	   ;to fix SoundDriver bug

;now dispose of any pending write calls.  Note: The completion routines are not
;called, although Killio normally would; they are just dequeued.
		  BSR.S 	throwAway	   ;get the handle and dispose it
		  UNLK	  A6		   ;de-allocate parameter block
noMore	  RTS

ClrSoundHdl
		  BSR.S 	StopSound
		  MOVE.L	IAZNotify,D0
		  BLE.S 	noMore
		  MOVE.L	D0,A0
		  JMP		(A0)		;otherwise, guess that it is OK to call app's

;the completion routine that gets called when an asynchronous call is through
;note: only asynchronous calls are queued up

myCompletion
		  MOVEM.L	D0-D2/A0-A1,-(SP)	;preserve the regs

goOn	  MOVE.L	SoundHdl,A0
		  MOVE.L	(A0),A0
		  TST.B 	noIntrupt(A0)  ;can we continue?
		  BEQ.S 	@0
		  ST		intrupt(A0)    ;we interrupted when we shouldn't have
		  BRA 	 	myCdone    ;so do nothing (we'll get recalled later) <SM4> CSS
@0		MOVE		realSize(A0),D0 	;get size
		  MOVE.L	ioOwnBuf(A0),D1 	;address of their completion rtn
		  BEQ.S 	noCompl    ;NIL completion routine
		  MOVE.L	D1,A1	   ;the completion routine

		  MOVEM.L	D0/A0,-(SP)
		  JSR		(A1)	   ;go to it
		  MOVEM.L	(SP)+,D0/A0

noCompl   CMP		#blkSize,D0    ;is there a pending sound call?
;		   BEQ.S		myCdone    ;no queue, just return
			; 12/9/88	per John Dance: if no queue, we are really done, so get
			; rid of the handle so it won't be locked in the application heap.
			BNE.S	more
			JSR 	throwAway
			BRA.S	myCdone

;there is a pending call, copy the parameters into the parm blk
more	  MOVE.L	A0,A1	   ;make a copy of it
		  LEA		blkSize(A0),A0
		  MOVE.L	(A0)+,ioOwnBuf(A1)	;their completion routine
		  MOVE.L	(A0)+,ioByteCount(A1) ;numBytes
		  MOVE.L	(A0)+,ioBuffer(A1)	;the synthesizer rec
		  MOVE.W	#-4,ioRefNum(A1)	;sound driver refNum

;now remove the parameters from the queue
		  MOVEQ 	#blkSize+12,D1 ;size of handle with 1 pending entry
		  SUB		D1,D0	   ;did it have more than 1 entry?
		  BEQ.S 	dspQ	   ;no, just dispose of the handle
		  MOVE		D0,D1	   ;save the new size
		  EXT.L 	D0		   ;clear top half for block move
		  MOVE.L	A0,A1	   ;A0 points to next queue entry
		  SUB		#12,A1	   ;A1 points to first queue entry
		  _BlockMove		   ;shift the bytes up in the queue
		  ADD		#blkSize,D1    ;get back the new size
		  BRA.S 	setSize

dspQ	  MOVEQ 	#blkSize,D1
setSize   MOVE.L	SoundHdl,A0    ;get the handle again
		  MOVE.L	(A0),A0
		  MOVE		D1,realSize(A0)

;set up my completion routine and make the write call
complSS   LEA		myCompletion,A1 	;this completion routine
		  MOVE.L	A1,ioCompletion(A0) ;stuff it
		  _Write	,async	   ;start asynchronous write and return

myCdone   MOVEM.L (SP)+,D0-D2/A0-A1 	;restore regs
		  RTS

;global parameter block set up for the user. This allows for general
;async sound driver calls without the user worrying about memory allocation.
;if more than one sound driver call is pending at one time, a handle is created
;which contains a queue of the outstanding calls.	These are posted as soon
;as the current calls is completed.

;
;FUNCTION SoundDone: BOOLEAN;
; One outstanding problem with this method; sound can not return an error.
; If ioResult is negative (error condition) then SoundDone returns TRUE.
SoundDone FUNC	   EXPORT
		  MOVE.L	(SP)+,A1	   ;return address
		  ST		(SP)	   ;$FF, assume that sound is done
		  MOVE.L	SoundHdl,A0    ;$E4 normally points to deep shit

;	  CMPA.L	MinusOne,A0
		  CMPA.W	MinusOne,A0    ;only compare word to allow for old bug.
		  BEQ.S 	exitTrue	   ;no handle if StopSound or sound never called

		  MOVE.L	(A0),A0    ; parameter block
		  TST.W 	ioResult(A0)   ; see if io is done
		  SLE		(SP)	   ; if 0 or negative (error), set true
exitTrue
		  NEG.B 	(SP)	   ;turn $00 or $FF into $00 or $01

		  JMP		(A1)

;PROCEDURE CountAppFiles(VAR message: INTEGER; VAR count: INTEGER);
;

CountAppFiles PROC	EXPORT

		MOVE.L	4(SP),A1
		CLR 	(A1)				;set default count to 0
		MOVE.L	AppParmHandle,A0		;the app parm handle
		_GetHandleSize				;are we real
		TST.L	D0
		BLE.S	CountEnd
		MOVE.L	(A0),A0 			;deref appParm Handle
		MOVE.L	8(SP),A1			;ptr to message
		MOVE.W	(A0)+,(A1)			;return the message
		MOVE.L	4(SP),A1
		MOVE.W	(A0),(A1)			;return the count

CountEnd
		MOVE.L	(SP)+,A0			;return addr
		ADDQ	#8,SP
		JMP 	(A0)

;
;PROCEDURE GetAppFiles(index: INTEGER; VAR theFile: AppFile);
;
; fType is set to all 0's if no next file was found or there is no file list

;AppFile = RECORD
;		  vRefNum: INTEGER;
;		  ftype: OsType;
;		  versNum: INTEGER;   {versNum in high byte}
;		  fName: str255;
;			END; {appFile}

;appParm has format:  message (0/1) for load or print	(2 bytes)
;			  # of entries				(2 bytes)
;	for each entry:   volume refNum 			(2 bytes)
;			  type					(4 bytes)
;			  version					(2 bytes)
;			  name- padded to even

GetAppFiles FUNC	EXPORT

			MOVEM.L 	A2-A3,-(SP)
			MOVE.L		4+8(SP),A1		;ptr to fileListElem
			CLR.L		2(A1)			;assume failure
			MOVE.L		AppParmHandle,A0	;get the application parameter handle
			_GetHandleSize			;are we real?
			TST.L	D0
			BLE.S		getEnd
			MOVE.L		(A0),A2 		;deref appParm Handle
			ADDQ		#2,A2			;skip the msg
			MOVE		8+8(SP),D1		;which entry to go to
			CMP 		(A2)+,D1		;see if index within limit
			BGT.S		getEnd
			SUBQ		#1,D1			;make index zero based

getLoop 	BLT.S		getEnd			;are we done?
			MOVE.L		A2,A0			;where to copy from
			MOVEQ		#2,D0
			ADD.B		8(A0),D0		;length of string
			AND 		#$FFFE,D0		;evenize it
			ADDQ		#8,D0			;also move refnum,type,versNum
			ADD 		D0,A2			;move to next
			_BlockMove
			SUBQ		#1,D1
			BRA.S		getLoop

getEnd		MOVEM.L 	(SP)+,A2-A3 	;save regs
			MOVE.L		(SP)+,A0
			ADDQ		#6,SP			;pop args
			JMP 		(A0)

;
;PROCEDURE ClrAppFiles(index: INTEGER);
;

ClrAppFiles PROC	EXPORT

			MOVE.L		AppParmHandle,A0	;get the application parameter handle
			_GetHandleSize			;are we real?
			TST.L	D0
			BLE.S		clrEnd
			MOVE.L		(A0),A0 		;deref appParm Handle
			ADDQ		#2,A0			;skip the msg

			MOVE		4(SP),D1		;which entry to go to
			CMP 		(A0)+,D1		;see if index within limit
			BGT.S		clrEnd
			SUBQ		#1,D1			;make index zero based

clrLoop 	BLT.S		clrEnd			;are we done?
			BEQ.S		ClrType
			MOVEQ		#2,D0
			ADD.B		8(A0),D0		;length of string
			AND 		#$FFFE,D0		;evenize it
			ADD 		#8,D0			;also move refnum,type,versNum
			ADD 		D0,A0			;move to next
			SUBQ		#1,D1
			BRA.S		clrLoop

ClrType 	CLR.L		2(A0)
clrEnd
			MOVE.L		(SP)+,A0
			ADDQ		#2,SP			;pop args
			JMP 		(A0)

; PROCEDURE SysError(errorCode: INTEGER);
;
;implementation for system error handler  (ie. deep sh*t manager)
;
;	2/26/88 KLH SysError calls in C Headers, Pascal Interfaces, and traps.a
; all are inline functions or traps. Nothing comes here, so remove from
; library!

;SysError	   PROC  EXPORT
;
;				MOVE.L	 (SP)+,A0		;get return address
;				MOVE.W	 (SP)+,D0		;get error code
;				_SysError				;invoke deeep sh*t
;				DC.W	  $A9FF 			;don't come back!

;----------------------------------------------------------------------
;
;	FUNCTION MaxBlock: LONGINT;
;
; Returns maximum size for a block w/o compacting
;
;
; Arguments:
;		none
;
; Entry:
;		none
;
; Exit:
;		D0.L -			size of block that could be allocated
;
MaxBlock FUNC EXPORT
	_MaxBlock
	MOVE.L D0,4(A7)
	RTS

MaxBlockSys FUNC EXPORT ; <10>
	_MaxBlock sys
	MOVE.L D0,4(A7)
	RTS

;----------------------------------------------------------------------
;
;	PROCEDURE PurgeSpace (VAR purgeFree, afterPurge: LONGINT);
;
; Returns the sum of free and purgeable bytes in the heap zone, as well
; as the maximum possible contiguous chunk which would be available
; after purging.
;
;
; Arguments:
;		purgeFree		sum of purgeable and free bytes in zone
;		afterPurge		maximum possible contiguous space after purge
;
; Entry:
;		none
;
;	Exit:
;		A0 -		maximum possible contiguous space after purge
;		D0.L -	sum of purgeable and free bytes in zone
;
;
PurgeSpace	PROC	EXPORT
	_PurgeSpace
	MOVE.L	4(A7),A1		; get address of afterpurge
	MOVE.L	A0,(A1) 	;
	MOVE.L	8(A7),A1		; get address of purgeFree
	MOVE.L	D0,(A1)
	MOVE.L	(A7)+,A1		; get return address
	ADD #8,A7				; discard 8 bytes
	JMP (A1)

;----------------------------------------------------------------------
;
;	FUNCTION StackSpace: LONGINT;
;
; Returns remaining stack space available (i.e. space between A7 and HeapEnd.
;
;
; Arguments:
;		none
;
; Entry:
;		none
;
; Exit:
;		D0.L -			available stack space
;
StackSpace FUNC EXPORT
	_StackSpace
	MOVE.L D0,4(A7)
	RTS

;----------------------------------------------------------------------
;
;	FUNCTION NewEmptyHandle: Handle;
;
; This is an optimized special case of NewHandle.  This routine is used
; mainly by the Resource Manager
;
;
; Arguments:
;		none
;
; Entry:
;		none
;
; Exit:
;			A0 -				handle to the new block
;			D0.L -			error code
;
NewEmptyHandle FUNC EXPORT
	_NewEmptyHandle
	MOVE.L A0,4(A7)
	RTS

NewEmptyHandleSys FUNC EXPORT ; <10>
	_NewEmptyHandle sys
	MOVE.L A0,4(A7)
	RTS

;----------------------------------------------------------------------
;
; FUNCTION HGetState(h: Handle): SignedByte;
;
; Given a handle, returns its master pointer's flags byte
;
;
; Arguments:
;		h				Handle to get state of
;
; Entry:
;		A0 -			handle
;
; Exit:
;		D0.B -			flags byte of handle's master pointer
;
HGetState FUNC EXPORT
	MOVE.L (A7)+,A1 		; return address
	MOVE.L (A7)+,A0 			; h
	_HGetState
	MOVE.B D0,(A7)				; is this the right byte????
	JMP (A1)

;----------------------------------------------------------------------
;
; PROCEDURE HSetState(h:Handle;state: SignedByte);
;
; Given a handle and a flags byte, sets the handle's master pointer's
; flags byte
;
; Arguments:
;		h:			refers to relocatable block
;		byteCount:		number of bytes needed in the new block
;
; Entry:
;		A0 -			handle to set
;			D0.B -		flags byte
;
; Exit:
;		D0.W -			error code
;
HSetState PROC EXPORT
	MOVE.L (A7)+,A1 		; return address
	MOVE.B (A7)+,D0 		; state
	MOVE.L (A7)+,A0 			; h
	_HSetState
	JMP (A1)						; return via A1 (2/4/86 Memerr OK)

;----------------------------------------------------------------------

DTInstall	PROC	EXPORT

			MOVE.L	4(SP),A0		; Get pointer to defer request block
			_DTInstall
			MOVE.L (SP)+,A0 		; Get return address off the stack
			ADDQ.L	#4,SP			; Adjust for parameter
			MOVE.W	D0,(SP) 		; Set the OSErr return value
			JMP 	(A0)			; Return

;----------------------------------------------------------------------
;
;  FUNCTION RelString(str1,str2: Str255; caseSens, diacSens: Boolean): integer;
;
; Just like _CmpString, except it indicates sorting order of strings,
; _CmpString only tells whether or not they're equal.
;
;
; Arguments:
;		str1				the first string
;		str2				the second string
;		caseSens			case sensitive?
;		diacSens			sensitive to diacriticals?
;
; Entry:
;	  A0 -			points to first character of first string
;		A1 -			points to first character of second string
;		D0 (Hi Word)	length of first string
;		D0 (Lo Word)	length of second string
;
; Exit:
;		D0.L -			-1 if first string sorts before second string
;						0  if strings are equal
;						1  if first string sorts after second string
;

RelString		FUNC	EXPORT
				LINK	  A6, #0		   ; allocate stack frame

				MOVE.L	16(A6),A0		;ptr to str1
				MOVE.L	12(A6),A1		;ptr to str2
				MOVEQ	#0,D0
				MOVE.B	(A0)+,D0		;str1 length
				SWAP	D0
				MOVE.B	(A1)+,D0		;str2 length

				;depending on value of booleans, make proper call
				TST.B	8(A6)			;value of diacSens
				BEQ.S	@2			;strip diacriticals
				TST.B	10(A6)			;value of caseSens
				BEQ.S	@1			;ignore case
				_RelString	,case		;both diacritical and case sensitive
				BRA.S	strDone

@1				_RelString			;diacritical sensitive,map to upper case
				BRA.S	strDone

				;strip diacriticals
@2				TST.B	10(A6)			;case sensitive?
				BEQ.S	@3
				_RelString	,marks,case ;ignore diacrits, case sensitive
				BRA.S	strDone

@3				_RelString	,marks		;ignore diacrits and map to upper case

strDone 		MOVE.W	D0,20(A6)		;return result	integer

				UNLK	   A6			; restore stack
				MOVE.L	   (SP)+,A0 	; rtn addr
				LEA 	12(SP),SP				; fix up stack
				JMP    (A0)

;----------------------------------------------------------------------
;
;FUNCTION GetMMUMode: SignedByte;

GetMMUMode		FUNC	EXPORT
				MOVE.B	MMU32bit,4(SP)	; FUNCTION return
				RTS

;PROCEDURE SwapMMUMode(VAR mode: SignedByte);

SwapMMUMode 	PROC	EXPORT
				MOVE.L	4(SP),A0		; VAR
				MOVE.B	(A0),D0 		; D0 := new mode
				_SwapMMUMode
				MOVE.L	4(SP),A0		; in case A0 was trashed.
				MOVE.B	D0,(A0) 		; return old mode.
				MOVE.L	(SP)+,A0		; return address
				ADDQ	#4,SP			; clear var address
				JMP 	(A0)

;----------------------------------------------------------------------
;
;FUNCTION SwapInstructionCache(cacheEnable: BOOLEAN) : BOOLEAN;

SwapInstructionCache PROC EXPORT
	MOVEA.L (A7)+,A1			; save return address
	CLR.L	D0					; clear D0 before we shove Boolean into it
	MOVE.B	(A7)+,D0			; D0 <- new mode
	MOVE.L	D0,A0				; trap wants mode in A0
	CLR.W	D0					; set low word to 0 (routine selector)
	_HWPriv
	MOVE.W	A0,D0				; move old state of cache to D0
	TST.W	D0					; if non-zero, cache was enabled
	BEQ.S	WasFalse			; if zero, leave result false
	MOVEQ	#$01,D0 			; set result to true
WasFalse:
	MOVE.B	D0,(A7) 			; save result on stack
	JMP (A1)
	ENDPROC

FlushInstructionCache PROC EXPORT
	MOVEA.L (A7)+,A1			; save return address
	MOVEQ	#$01,D0 			; set low word to 1 (routine selector)
	_HWPriv
	JMP (A1)
	ENDPROC

;----------------------------------------------------------------------
;
;FUNCTION SwapDataCache(cacheEnable: BOOLEAN) : BOOLEAN;

SwapDataCache PROC EXPORT
	MOVEA.L (A7)+,A1			; save return address
	CLR.L	D0					; clear D0 before we shove Boolean into it
	MOVE.B	(A7)+,D0			; D0 <- new mode
	MOVE.L	D0,A0				; trap wants mode in A0
	MOVE.W	#$0002,D0			; set low word to 2 (routine selector)
	_HWPriv
	MOVE.W	A0,D0				; move old state of cache to D0
	TST.W	D0					; if non-zero, cache was enabled
	BEQ.S	WasFalse			; if zero, leave result false
	MOVEQ	#$01,D0 			; set result to true
WasFalse:
	MOVE.B	D0,(A7) 			; save result on stack
	JMP (A1)
	ENDPROC

;PROCEDURE FlushDataCache;

FlushDataCache PROC EXPORT
	MOVEA.L (A7)+,A1			; save return address
	MOVEQ	#$03,D0 			; set low word to 3 (routine selector)
	_HWPriv
	JMP (A1)
	ENDPROC

;----------------------------------------------------------------------

	if obsoleteGlue then

;----------------------------------------------------------------------
;
; Procedure SetApplBase;
;
; Initialize the Application Zone while growing the System zone.
;
; Arguments:
;		A0 - ptr to new application zone base.
;
; Registers:
;		D0 - result code from SetApplBase (always 0)
;
SetApplBase 	PROC  EXPORT

				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;startPtr
				_SetApplBase			;ask OS to do request
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure InitApplZone;
;
; Initialize the Application Zone
;
; Arguments:
;		None
;
; Registers:
;		D0 - result code from InitApplZone
;
InitApplZone	PROC  EXPORT

				_InitApplZone			;ask OS to do request
				rts

;----------------------------------------------------------------------
;
; FUNCTION GetZone: THz;
;
; Returns value of theZone
;
; Arguments:
;		None
;
; Result:
;				size of largest available block in bytes
;		grow:			maximum growth allowed in current zone
;
; Registers:
;		A1 -			holds return address
;
GetZone 		FUNC  EXPORT

				_GetZone				;ask OS to do request
				Move.L	A0,4(SP)		;save result
				rts

;----------------------------------------------------------------------
;
; Procedure SetZone(hz: THz);
;
; Sets theZone to hz
;
; Arguments:
;		hz: 		holds new value for theZone
;
; Registers:
;		A2 -			holds return address
;
SetZone 		PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;zone pointer
				_SetZone				;ask OS to do request
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure PurgeMem(cbNeeded: Size);
;
; Purge purgeable blocks in the heap until a free block of cbNeeded bytes
; is found, or until the end of the zone is reached.
;
; Arguments:
;		cbNeeded:		size of block needed
;
; Result:
;
; Registers:
;		A1 - return address
;		D0 - number of bytes needed/error code
;
PurgeMem		PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get cbNeeded
				_PurgeMem				;tell OS to do it
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; FUNCTION FreeMem: LongInt;
;
; Returns number of free bytes in the current zone
;
; Arguments:
;		None
;
; Result:
;				number of free bytes in the current zone
;
; Registers:
;		D0 -			holds result value
;
FreeMem 		FUNC  EXPORT

				_FreeMem				;ask OS to do request
				Move.L	D0,4(SP)		;save result
				rts

;----------------------------------------------------------------------
;
; Procedure ResrvMem(cbNeeded: Size);
;
; Purge purgeable blocks in the heap until a free block of cbNeeded bytes
; is found, or until the end of the zone is reached.
;
; Arguments:
;		cbNeeded:		size of block needed
;
; Result:
;
; Registers:
;		A1 - return address
;		D0 - number of bytes needed/error code
;
ResrvMem		PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,D0		;get cbNeeded
				_ResrvMem				;tell OS to do it
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure SetGrowZone(growZone: ProcPtr);
;
; Sets the current heap zone's GrowZone procedure to growZone
;
; Arguments:
;		growZone:		new value for this zone's GrowZone proc
;
; Registers:
;		A1 -			holds return address
;
SetGrowZone 	PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;Procedure pointer
				_SetGrowZone			;ask OS to do request
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure SetApplLimit(zoneLimit: Ptr);
;
; Sets the application zone's limit to zoneLimit
;
; Arguments:
;		zoneLimit:		new value for application zone limit
;
;		A2 -			holds return address
;
SetApplLimit	PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;zone pointer
				_SetApplLimit			;ask OS to do request
				JMP 	(A1)			;return via A1

;PROCEDURE MaxApplZone;
;
;grows the application zone to as large as allowable (by applLimit)

MaxApplZone 	PROC  EXPORT
				DC.W	$A063				;put ROM glue here
				RTS

;-------------------------------------------------------------------------------------------
; PROCEDURE MoveHHi( h : Handle );
;
; Moves h up to the top of its region (space between two locked/nonrelocatable objects or
; between a locked/nonreloc and the heap end), but with neither purge nor heap growth, only
; compaction.  The idea is to use a stack buffer to move slices of the rising block in steps,
; compacting along the way to free space at the top.  Requires about 1K of stack space.
; If the block is already high, MoveHHi does nothing.
;
;	Arguments:	A0 = handle to be moved high
;	Results:	D0 = error code =	0 no error
;									NilHandleErr
;									LkdHandleErr
;									StackErr
; Register conventions:
;
;	A6 - theZone pointer
;	A5 - stack locals, buffer
;	A4 - handle of block we are moving
;	A3 - BkLim(theZone)
;
;	D6 - current BC of block moved so far (not including header)
;	D7 - current BC of block left to move (not including header)
;-------------------------------------------------------------------------------------------

MoveHHi PROC EXPORT

			MOVE.L	(SP)+,A1			; return address
			MOVE.L	(SP)+,A0			; handle
			_MoveHHi					; off to ROM version
			JMP 	(A1)				; return to caller of glue

;----------------------------------------------------------------------
;
; Procedure DisposPtr(p: Ptr);
;
; Releases the block pointed to by p.
;
; Arguments:
;		p:			pointer to block to be freed
;
; Result:
;		None
;
; Registers:
;		A0 - points to block to be freed
;		A1 - return address
;		D0 - error code
;
DisposPtr		PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get parameter
				_DisposPtr				;let OS do work
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure DisposHandle(h: Handle);
;
; Releases the block referenced by h.
;
; Arguments:
;		h:			handle for the block to be freed
;
; Result:
;		None
;
; Registers:
;		A0 - handle for block to be freed
;		A1 - return address
;		D0 - error code
;
DisposHandle	PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get handle
				_DisposHandle			;let OS do work
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure EmptyHandle(h: Handle);
;
; Explicitly purges the relocatable block referred to by h.
;
; Arguments:
;		h:			refers to relocatable block
;
; Result:
;		None
;
; Registers:
;		A0 -			handle for block
;		A1 -			holds return address
;		D0 -			error code
;
EmptyHandle 	PROC  EXPORT

				Move.L	(SP)+,A1		;get return address
				Move.L	(SP)+,A0		;get the handle
				_EmptyHandle			;let OS do it
				JMP 	(A1)			;return via A1

;----------------------------------------------------------------------
;
; Procedure HLock(h: Handle);
; Procedure HUnLock(h: Handle);
; Procedure HPurge(h: Handle);
; Procedure HNoPurge(h: Handle);
; Procedure HSetRBit(h: Handle);
; Procedure HClrRBit(h: Handle);

;
; These procedure are used to change the lock and purge and resource
; attributes of the relocatable block referred to by h.
;
; Arguments:
;		h:			handle for relocatable block
;
; Registers:
;		A0 -			handle for relocatable block
;		A1 -			holds return address
;

HLock			PROC  EXPORT

				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;handle for block
				_HLock					;let OS to do it.
				JMP 	(A1)			;return via A1

HUnLock 		PROC  EXPORT

				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;handle for block
				_HUnLock				;let OS to do it.
				JMP 	(A1)			;return via A1

HPurge			PROC  EXPORT

				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;handle for block
				_HPurge 				;let OS to do it.
				JMP 	(A1)			;return via A1

HNoPurge		PROC  EXPORT

				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;handle for block
				_HNoPurge				;let OS to do it.
				JMP 	(A1)			;return via A1

HSetRBit		PROC  EXPORT
				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;handle for block
				_HSetRBit				;let OS to do it.
				JMP 	(A1)			; return via A1 (2/4/86 Memerr OK)

HClrRBit		PROC  EXPORT

				Move.L	(SP)+,A1		;return address
				Move.L	(SP)+,A0		;handle for block
				_HClrRBit				;let OS to do it.
				JMP 	(A1)			; return via A1 (2/4/86 Memerr OK)

;
;PROCEDURE MoreMasters;
;

MoreMasters PROC  EXPORT

		   _MoreMasters
				rts

;----------------------------------------------------------------------
;
; FUNCTION MemError: OsErr;
;
;  Returns the error observed by the most recent memory manager call.
;  It has been obsoleted by INLINE equivalent.
;
; Arguments:
;		None
;
; Registers:
;
MemError		FUNC  EXPORT

				Move.W	MemErr,4(SP)	 ;last error
				RTS

;___________________________________________________________________
;
; FUNCTION RamSDOpen(whichPort: SPortSel): OSErr;
;
; RAMSDOpen loads and installs Mac or MacXL RAM serial driver
;	(resource type SERD, ID=1 for Mac, ID=2 for MacXL) if the system
;	driver is version 0.  The driver is then opened for both input
;	and output.  The resource should have the locked attribute set so
;	that it is brought in low in the heap.	If the driver is only used
;	on a 512K system, it may have the System Heap bit set (there would
;	probably not be room for it on a 128K machine).
;
; (1) This routine is intended for those who need the additional capability
;		of the version 1 driver.  History:
;
;		Main problem was to get four drivers in which
;		are packaged as one and still preserve the DCE pointers which the old
;		one had.  Probably would have been better to package as RAM DRVR 28 which,
;		when opened, would have also installed 29, 30, and 31 into DCEs.  Later, code
;		was added to default to current drivers if they were a late enough version.
;		Finally, configuration/use check was added to avoid Device Manager bug which
;		ate Open error codes from driver, and to check for disk drivers using the DCEs
;		which didn't support new protocol yet.
;
; (2) If we just had new ROMs, RAMSDOpen would not be needed because the driver
;		would already exist - except: logical drivers which support version 1
;		set may be around and want to be found. Open('.AIn') and Open('.AOut')
;		would not necessarily work since open may work but version 1 level may
;		still not be around.
;
; (3) So, RAMSDOpen is sort of an amalgamation of different FUNCTIONs which are handled
;		separately in the future (hopefully):
;
;		- loading RAM-based drivers (load appropriate one for MacXL).
;		- closing old drivers and opening the new.
;		- observing configuration/use protocols.
;		- checking for a certain level of driver service.
;
; (4) Current loading logic is:
;
;		IF either DCE is missing: fail with unitEmptyErr.
;		(RAMSDOpen callers want full-duplex async service.	This also
;		 keeps us from closing a hard-disk driver which is using one of the
;		 DCEs and disposing the other. We will also exit here in the case of
;		 AppleTalk and old ROMs because the DCEs will be removed by the MPP driver).
;		IF the output DCE version byte>0, we will just try opening the current driver.
;		(If both DCEs are around AND version bytes are > 0, we can assume that the
;		 driver is BOTH async - only async drivers in the future should use these
;		 refnums - AND that it's a superset version of the driver.  The case of
;		 a network async driver should fall in here; if it's not a superset driver,
;		 it should just be version 0 and RAMSDOpen will fail in the config check (port
;		 will be in use).  If it does support version 1 capability or more, RAMSDOpen
;		 goes directly to the open code and should open successfully.  Old ROM device
;		 manager problems may still interfere in error cases, but we can't be perfect.
;		IF both DCEs are present AND the version is 0, we check the configuration and use
;		 port bytes and figure out if it's ok to open.  If so, we load the SERD
;		 resource (if not already loaded) and install it.  Finally, we open the
;		 driver.
;
;		We should put in a check for ROM85 and trap out if so; this would allow us to
;		fix any problems in that ROM.
;
;
; possible errors:
;	 -1 			- DCEs version is 0 but RAM-based (something wierd . . .)
;	-97 PortInUse		- some other driver is currently using this port
;	-98 PortNotCf		- parameter ram is set for some other type use
;	-22 unitEmptyErr	- DCE has been removed
;  -192 ResNotFound 	- appropriate SERD resource not found
;  -108 MemFullErr		- not enough memory to load driver
;
;
;___________________________________________________________________

RamSDOpen	FUNC	EXPORT
			EXPORT	RamSDClose

serAInRfn	EQU 	-6				; -6 and -7 for port A
serAOutRfn	EQU 	-7
serBInRfn	EQU 	-8				; -8 and -9 for port B
serBOutRfn	EQU 	-9

idMacSERD	EQU 	1				; resource ID 1 for Mac
idMacXLSERD EQU 	2				; resource ID 2 for Mac XL

resultOS	EQU 	10				; RamSDOpen A6 offsets after link
portSelOS	EQU 	8				; $0000=port A , $0100=port B

romVersOS	EQU 	8				; version word offset from ROMBase

			LINK	A6, #-ioQElSize 	; make room for io pblk and save
			MOVEM.L D2-D3/A2-A3,-(SP)	; save regs
			CLR.W	ResultOS(A6)		; assume no error

			; Open both drivers and we are done!

openBoth	MOVEQ	#1, D2				; want to do this twice
			LEA 	-ioQElSize(A6), A0	; ptr to param blk
			LEA 	drvANames, A1		; assume port A
			TST.B	PortSelOS(A6)		; which port?
			BEQ.S	@1					; br if port A
			LEA 	drvBNames, A1		; ptr to names: bIn and bOut

@1			MOVE.L	A1, ioFileName(A0)	; stuff ptr to name
			CLR.W	ioDrvNum(A0)
			CLR.B	ioPermssn(A0)		; open for read/write
			_Open
			BNE.S	ramSDFail			; better work!
			CLR.W	D1
			MOVE.B	(A1)+, D1			; the length of this string
			ADD.W	D1, A1				; skip to next name
			DBRA	D2, @1

RamSDExit	MOVEM.L (SP)+,D2-D3/A2-A3	; restore those regs
			UNLK	A6

			MOVE.L	(SP)+, A0			; get rts
			ADDQ	#2, SP				; strip WhichPort parameter
			JMP 	(A0)

ramSDFail	MOVE.W	D0, ResultOS(A6)
			BRA.S	RamSDExit

;___________________________________________________________________
;
; PROCEDURE  RamSDClose(whichPort: SPortSel);
;
; RamSDClose closes the drivers (both in and out) for the port
;	indicated by whichPort.  It disposes of the RAM serial driver if
;	it is no longer needed (ie the other port is not open).
;
;___________________________________________________________________

RamSDClose
			LINK	A6, #-ioQElSize 	; make room for io pblk and save
			MOVEM.L D2-D3/A2-A3,-(SP)	; save regs

			; first close the in and out drivers for this port

			MOVE.B	PortSelOS(A6), D1	; the value of whichPort
			BSR 	ClsPorts

			BRA.S	RamSDExit			; and exit

;______________________________________;
;
; Routine:		GetSerDCE
; Arguments:	  D2 (input)   --  driver refnum
;		  D0 (output)  --  0 if DCE ok, unitEmptyErr if not
;		  A0 (output)  --  DCE ptr if D0=0
;		  -ioQElSize(A6) -- io parameter block
;		  all other regs preserved
; Called By:	RAMSDOpen
; Purpose:		Get pointer to appropriate output DCE (based on WhichPort)

GetSerDCE	LEA 	-ioQElSize(A6), A0	; address of cmd block
			MOVE.W	D2, ioRefNum(A0)	; refnum
			MOVE.W	#1, csCode(A0)		; get DCE status code
			_Status
			BNE.S	@2					; br if the DCE is not around
			MOVE.L	csParam(A0), A0 	; get DCE handle
			MOVE.L	(A0), A0			; get DCE ptr
			BRA.S	@3
@2			MOVEQ	#unitEmptyErr, D0	; no DCE (probable case of old ROM driver)
@3			RTS 						; return

;______________________________________;
;
; Routine:		ChkConfig
; Arguments:	  D1 (input)   --  0=port A , 1=port B
;		  D0 (output)  --  0 if avail (unchanged if avail for ChkConf1 entry)
;			-97 PortInUse	- some other driver is currently using this port
;			-98 PortNotCf	- parameter ram is set for some other type use
;		  all other regs preserved
; Called By:	SDAvail, RAMSDOpen
; Purpose:		Check to see if PortUse and SPConfig are ok for an async driver.

ChkConfig	MOVEQ	#0, D0				; return 0 if ok

ChkConf1	MOVE.L	D2, -(SP)			; preserve all regs (D0 changed on failure)
			MOVE.B	SPConfig, D2		; see what parameter ram says
			TST.B	D1
			BNE.S	@1					; br if port b
			LSR.B	#4, D2				; use appropriate 4 bits
@1			AND.B	#$0F, D2
			BEQ.S	@2					; br if 0 (UseFree)
			SUBQ.B	#useAsync, D2		; config'ed for async?
			BEQ.S	@2					; br if so

			MOVEQ	#PortNotCf, D0		; "port not configured error"
			BRA.S	@4

@2			MOVE.B	PortBUse, D2		; see if port is in use
			TST.B	D1
			BNE.S	@3					; br if port b
			MOVE.B	PortAUse, D2

@3			BCLR	#7, D2				; in use?
			BNE.S	@4					; br if not
			EOR.B	#useAsync, D2		; in use by async driver?
			BEQ.S	@4					; ok if so . . .

			MOVEQ	#PortInUse, D0		; note the error

@4			MOVE.L	(SP)+, D2			; restore regs
			TST 	D0					; set CCR
			RTS 						; and return (D0 unchanged if ok)

;______________________________________;
;
; Routine:		ClsPorts
; Arguments:	  D1 (input)   --  0=port A , 1=port B
;		  A2 (input)   --  ptr to SDOpen/Close 'globals' record
;		  A6 (input)   --  -ioQElSize(A6) is I/O parameter blk
;		  A0/D0 clobbered.
; Called By:	RamSDOpen, RAMSDClose
; Purpose:		ClsPorts closes both the in and out driver of a serial port.

intMask 	EQU 	$0600				; excludes all ints on Mac, MacXL

ClsPorts	MOVEQ	#SerAInRfn, D0		; assume port A
			TST.B	D1					; portA or portB?
			BEQ.S	@1
			MOVEQ	#serBInRfn, D0		; port B

@1			LEA 	-ioQElSize(A6), A0		; the ptr to the param blk
			MOVE.W	D0, ioRefNum(A0)	; set up the parameter block
			_Close						; close the in driver
			SUBQ.W	#1, ioRefNum(A0)	; refNum of out driver
			_Close						; close it also

			RTS 						; and return

drvANames	DC.B	4
			DC.B	'.AIn'
			DC.B	5
			DC.B	'.AOut'
drvBNames	DC.B	4
			DC.B	'.BIn'
			DC.B	5
			DC.B	'.BOut'

;
;FUNCTION GetSysPPtr: SysPPtr;
;

GetSysPPtr	FUNC	EXPORT

			MOVE.L	#SysParam,4(SP) 	;get the address
			RTS

;PROCEDURE Restart;

Restart PROC	EXPORT

		MOVE.L	ROMBase,A0		;get ROM start
		ADD 	#$A,A0			;Offset of reboot location
		JMP 	(A0)			;Bye

;FUNCTION GetFSQHdr: QHdrPtr;

GetFSQHdr PROC	  EXPORT

		MOVE.L	   #FSQHdr,4(SP)
		RTS

;FUNCTION  GetDrvQHdr: QHdrPtr;

GetDrvQHdr PROC    EXPORT

		MOVE.L	   #DrvQHdr,4(SP)
		RTS

;FUNCTION  GetVCBQHdr: QHdrPtr;

GetVCBQHdr PROC    EXPORT

		MOVE.L	   #VCBQHdr,4(SP)
		RTS

;FUNCTION  GetVBLQHdr: QHdrPtr;

GetVBLQHdr PROC    EXPORT

		MOVE.L	   #VBLQueue,4(SP)
		RTS

;FUNCTION  GetEvQHdr: QHdrPtr;
;
GetEvQHdr PROC	  EXPORT

		MOVE.L	#EventQueue,4(SP)
		RTS

;----------------------------------------------------------------------
;
; FUNCTION ApplicZone: THz;
;
; Returns value of ApplZone.  It has been obsoleted by INLINE equivalent.
;
; Arguments:
;       None
;
; Result:
;		        current value of ApplZone pointer
;
; Registers:
;       A1 -	        holds return address

ApplicZone      FUNC  EXPORT

				Move.L  ApplZone,4(SP)
				RTS

;----------------------------------------------------------------------
;
; FUNCTION SystemZone: THz;
;
; Returns value of SysZone.  It has been obsoleted by INLINE equivalent.
;
; Arguments:
;       None
;
; Result:
;		        current value of SysZone pointer
;
; Registers:
;       A1 -	        holds return address

SystemZone      FUNC  EXPORT
				Move.L  SysZone,4(SP)
				RTS

;----------------------------------------------------------------------
;
; FUNCTION TopMem: Ptr;
;
; Returns the address of the byte after the last byte of real memory.
; It has been obsoleted by INLINE equivalent.
;
; Arguments:
;       None
;
; Result:
;       Ptr:	        Address of byte just following last byte of
;			  real memory
;
; Registers:
;       D0 - result code

TopMem          FUNC  EXPORT

				Move.L  MemTop,4(SP)    ;set FUNCTION result
				RTS

;----------------------------------------------------------------------
;
; FUNCTION GetApplLimit: Ptr;
;
; Fetches the current application heap limit.  It has been obsoleted by
; INLINE equivalent.

GetApplLimit    FUNC  EXPORT

				Move.L  ApplLimit,4(SP) ;zone pointer
				RTS

;----------------------------------------------------------------------
;
;	PROCEDURE InsTime(tmTaskPtr: QElemPtr);

InsTime 	PROC	EXPORT

; Someone thought this glue was bad because it relies on A1 being
; preserved across the trap call. That is wrong! The trap dispatcher
; preserves A1 across OS traps!

			MOVE.L	(A7)+,A1	;get return address
			MOVE.L	(A7)+,A0	;get pointer
			_InsTime
			JMP		(A1)		;return

;----------------------------------------------------------------------
;
;	PROCEDURE RmvTime(tmTaskPtr: QElemPtr);

RmvTime 	PROC	EXPORT

; Someone thought this glue was bad because it relies on A1 being
; preserved across the trap call. That is wrong! The trap dispatcher
; preserves A1 across OS traps.

			MOVE.L	(A7)+,A1	;get return address
			MOVE.L	(A7)+,A0	;get pointer
			_RmvTime
			JMP		(A1)		;return

;----------------------------------------------------------------------
;
;	PROCEDURE PrimeTime(tmTaskPtr: QElemPtr; count: LONGINT);

PrimeTime	PROC	EXPORT

; Someone thought this glue was bad because it relies on A1 being
; preserved across the trap call. That is wrong! The trap dispatcher
; preserves A1 across OS traps.

			MOVE.L	(A7)+,A1	;get return address
			MOVE.L	(A7)+,D0	;get count
			MOVE.L	(A7)+,A0	;get pointer
			_PrimeTime
			JMP		(A1)		;return

;----------------------------------------------------------------------

;
;FUNCTION VInstall(VBLBlockPtr: VBLCBPtr): OsErr;
;

VInstall	FUNC  EXPORT

			MOVE.L	(SP)+,A1			;get the return address
			MOVE.L	(SP)+,A0			;addr of vertical retrace control blk
			_VInstall
			MOVE.W	D0,(SP) 			;return error
			JMP 	(A1)

;
;FUNCTION VRemove(VBLBlockPtr: VBLCBPtr): OsErr;
;

VRemove 	FUNC  EXPORT

			MOVE.L	(SP)+,A1			;get the return address
			MOVE.L	(SP)+,A0			;addr of vertical retrace control blk
			_VRemove
			MOVE.W	D0,(SP) 			;return error
			JMP 	(A1)

	ENDIF

;----------------------------------------------------------------------

	END
