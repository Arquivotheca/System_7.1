;;	File:		DeskMgr.a;;	Contains:	The desk manager is the interface between the applications and the desk ornament/;				RAM-based driver system.  When an application receives an event, it passes it to;				the desk manager to allow the system to capture events for desk ornaments and;				other system functions.  The applications also call the desk manager routine;				"SystemTask" in their main loop to give the drivers back some good "main thread";				time to call the memory manager or keep the desk ornaments alive.;;	Written by:	Andy Hertzfeld   23-Oct-82;;	Copyright:	© 1982-1993 by Apple Computer, Inc.  All rights reserved.;;	Change History (most recent first):;;	  <SM18>	 8/16/93	BH		Manual-eject handling now looks at all of a volume's open files;									to determine if the volume needs to be updated, rather than just;									the vcbDirty flag.;	  <SM17>	  8/3/93	BH		Added manual-eject event support to SystemEvent.;	  <SM16>	 1/27/93	CSS		Patch the SystemMenu function to handle the Keyboard menu, and;									input method menus correctly. Also, fix the dispatcher to point;									to the SystemMenu routine in this file again.;	  <SM15>	11/18/92	SWC		Removed the HcMac IdleMind code since the _IdleMind call is now;									made in SyncIdleTime.;		<SM2>	11/01/92	HY		Conditionalize call to IdleMind for LC930 ROM.  We don't;									include any of the PowerMgr stuff for this ROM and IdleMind;									is one of the vectors conditionalized in :Make:VectorTable.a.;		<SM1>	 7/17/92	CSS		Jeff copied this directly from Reality, but with the;									diffences in include file structure over there, it compiled.;									Here in SuperMario, it didn't.  The reason is that SuperMario;									includes PowerEqu.a in StandardEqu.a while Reality includes;									PowerPrivEqu.a.  So, I am including PowerPrivEqu.a back;									in this file.  Maybe someday we can figure out why Power anything;									is included in StandardEqu.a.;		<11>	  7/8/92	JSM		Merge changes from SuperMario: roll-in HMSystemTaskPatch and;									HMSystemMenuPatch from Balloonptch28.a. Also, add a change from;									FixSystemClick that was’t originally done in <5> and roll-in;									GetDCtlRefNumFromHandleForSendDrvrMsg and;									GetDCtlRefNumFromHandleForClosingDeskAccessory patches from;									DeskMgrPatches.a.;		<10>	  5/5/92	JSM		Get rid of conditionals: get rid of local conditional;									ApplDefEvent which will never be true, hasIdle, hasJaws, and;									isUniversal are always true, hasNormandy is always false.  This;									file now has no conditionals.;		 <9>	 2/10/92	JSM		Moved this file to DeskMgr folder, keeping all the old;									revisions.;		 <8>	11/16/91	DTY		Replacing hard addresses with a record to make the equates “more;									universal” is nice but useless if the code has no way of getting;									to those addresses any more. Add an equate for VidRAMStkPtr to;									this file to keep the ROM build building until the hardware guys;									figure out what they’re trying to do.;		 <7>	 9/14/90	MSH		Newer, faster version of power cycling (should probably be;									vectorized someday).;		 <6>	 9/13/90	BG		Removed <4>. 040s are working more reliably now.;		 <5>	  8/2/90	csd		Fixed SystemClick to get the window variant in a 32-bit clean;									way.;		 <4>	 7/16/90	BG		Added EclipseNOPs for flakey 040s.;		 <3>	 5/16/90	MSH		Added Waimea Power Cycling to the portable idle code. Fully;									universal of course.;		 <2>	 1/12/90	CCH		Adding include of “HardwarePrivateEqu.a”.;	   <2.6>	 12/4/89	MSH		Ported over the forked off hcmac source changes.;	   <2.5>	 8/22/89	SES		Removed references to nFiles.;	   <2.4>	  6/8/89	KSM		Restored to version 1.9 (last real change).;	   <2.3>	  6/2/89	KSM		Updated conditionals for ROM/SYS build AGAIN (again).;	   <2.2>	  6/2/89	KSM		Updated conditionals for ROM/SYS build AGAIN.;	   <2.1>	  6/2/89	KSM		Updated conditionals for ROM/SYS build.;	   <2.0>	  6/1/89	KSM		Added check to handle events for tear off menus.;	   <1.9>	 5/15/89	EMT		Checked for NIL frontwindow in SystemEvent, fixes BRC #34592.;	   <1.8>	 5/15/89	MSH		Test of watch cursor had the wrong register.;	   <1.7>	 3/31/89	MSH		Moved the idle stuff to a subroutine at the end of the file.;	   <1.6>	  3/9/89	MSH		Check the time out dirty flag before using them.;	   <1.5>	  3/3/89	MSH		No longer have to check for LastAct and LastHd initialized.;	   <1.4>	 2/28/89	MSH		Time outs reduced to one each for sleep and hard disk.;	   <1.3>	  2/8/89	MSH		Moved all sleep and hard disk time out in from poweResourceMgr.a;	   <1.2>	12/14/88	MSH		Had to make file hardware dependent to support idle mode.;	   <1.1>	11/10/88	CCH		Fixed Header.;	   <1.0>	 11/9/88	CCH		Adding to EASE.;	  <•1.2>	 9/23/88	CCH		Got rid of inc.sum.d and empty nFiles;	   <1.1>	 5/16/88	BBM		Give Notification Manager time as well.;	   <1.0>	 2/11/88	BBM		Adding file for the first time into EASE…;	  <C151>	 1/14/87	JTC		32-bit friendly changes, rolled in much later since TJ had;									access to the file during the 32-bit drive.;	  <A216>	10/14/86	TJ		Fixed missing drive # in call to DoEject; no longer complains;									about ejecting drive #243.;	  <C150>	  9/9/86	TJ		Extended the DiskHandler to accept DiskInsertEvt "Eject" events;;									the upper word if -1 means a disk eject, not insert. Eject;									function goes through a trap vector, no longer a ROM jump;									vector.;				 2/19/86	BBM		Made some modifications to work under MPW;				 9/26/85	BBM		Made DeskMgr pass on events greater than 8. Event 9 is still;									ignored and reserved for future use. To pass on application;									defined events, set the conditional assembly flag ApplDefEvent;									to 1.;				 2/20/85	LAK		Special IOPermission value set for OpenDeskAcc Opens.;				 1/30/85	LAK		Lock/Unlock window def proc around call.;				 1/29/85	EHB		Checked for NIL frontwindow in SystemTask;				 1/29/85	EHB		Unlocked WindowDef before LoadResource in SystemClick;				 1/23/85	LAK		Adapted for new equate files.;				  9/6/83	AJH		Made SystemEdit save and restore the port;				  9/5/83	AJH		Fixed bug in SystemEdit;				 8/30/83	SC		Fixed bug in Movem.l in system click;				 8/15/83	AJH		monster code krunch (from code review with Jerome, Capps);				  8/9/83	AJH		Removed NetEvent support, general code crunch;				 6/30/83	AJH		Added CloseDeskAcc, SystemEdit;				 6/23/83	SC		Added support for multiple windows (Changed SearchWindow);				 6/19/83	AJH		Made the desk mgr control call asynchronous;				 6/17/83	LAK		Changed to use UnitNtryCnt lomem var instead of equate.;				 6/15/83	AJH		Added OpenDeskAcc;				 5/10/83	AJH		Made it use a hook to close desk ornaments;				 4/27/83	AJH		Made SystemClick call deskHook with wmgrPort clip set up;				  3/7/83	AJH		Made TaskLock a byte flag (instead of word);				  2/9/83	AJH		Made SystemTask not call active drivers;				  2/8/83	AJH		Changed DragWindow call to provide boundsRect;				 1/24/83	AJH		SystemMenu lets orn own menuBar; new I/O calls;				 1/23/83	AJH		added support for diskInserted events, deskHook in SystemClick;				 1/20/83	AJH		fixed stack bug in goAway handling code;				12/19/82	AJH		Added SystemMenu, handling of activate/deactivate events;				11/16/82	AJH		Added TaskLock to SystemTask to avoid re-entrancy problems;				BLANKS		ON				STRING		ASIS				LOAD		'StandardEqu.d'				INCLUDE		'HardwarePrivateEqu.a'				INCLUDE		'MMUEqu.a'				INCLUDE		'UniversalEqu.a'				INCLUDE		'BalloonsPriv.a'				INCLUDE		'TSMPrivate.a'		; <SM16> CSS				INCLUDE		'ScriptPriv.a'		; <SM16> CSS	DeskMgr 		PROC	EXPORT					EXPORT	SystemEvent,SystemClick,SystemTask,SystemMenu,SystemEdit				EXPORT	OpenDeskAcc,CloseDeskAcc				WITH	ProductInfo,DecoderInfo,VideoInfo;;  FUNCTION SystemEvent(theEvent: EventRecord): BOOLEAN;;;	 SystemEvent is called by an application when it receives an event from the;  event manager.  SystemEvent determines if the event should be handled by the;  application or the system.  If the application should handle it, SystemEvent;  returns FALSE; otherwise, SystemEvent calls the appropriate system code to handle;  the event and returns TRUE.;SystemEvent				MOVE.L	A3,-(SP)				;preserve a work register				MOVE.L	8(SP),A3				;get pointer to event record				CLR.W	12(SP)					;assume its not for us (return FALSE); preserve the current port				SUBQ	#4,SP					;make some room on stack				MOVE.L	SP,-(SP)				;point to it				_GetPort						;remember the current port;  case out on the Event.What field				MOVE.W	EvtNum(A3),D0			;get the event number				CMP 	#12,D0					;only handle events 0-8 					<26sep85> BBM				BCC.S	DoneSEvt				;if not one of ours, ignore it;				ADD.W	D0,D0					;double for word index				LEA 	EvtDTable,A0			;get address of dispatch table				ADD.W	0(A0,D0),A0 			;compute dispatch address				JMP 	(A0)					;dispatch to proper handler;; Here is the system event dispatch table, offset-encoded for compactness;EvtDTable				DC.W	DoneSEvt-EvtDTable		;null event is ignored			(0)				DC.W	DoneSEvt-EvtDTable		;mouse down is ignored			(1)				DC.W	IfTopWants-EvtDTable	;feed mouse up to top window	(2)				DC.W	IfTopWants-EvtDTable	;feed key down to top window	(3)				DC.W	IfTopWants-EvtDTable	;feed key up to top window		(4)				DC.W	IfTopWants-EvtDTable	;feed auto-key to top window	(5)				DC.W	SysUpdate-EvtDTable 	;handle system update events	(6)				DC.W	DiskHandler-EvtDTable	;handle disk inserted events	(7)				DC.W	SysUpdate-EvtDTable 	;handle activate events 		(8)				DC.W	DoneSEvt-EvtDTable		;reserved event is ignored		(9) 	<26sep85> BBM				DC.W	IfTopWants-EvtDTable	;feed network to top window 	(10)	<26sep85> BBM				DC.W	IfTopWants-EvtDTable	;feed device drvr to top window (11)	<26sep85> BBM;; DoneSEvt is the code for returning to the application when the desk manager; is all finished its work.  Events that are ignored branch here, too, since the; result has already been flagged false.  The alternative entry point "DoneSysEvt"; is used to return true.;DoneSysEvt				ADDQ.B	#1,16(SP)				;flag the result "TRUE"DoneSEvt				_SetPort						;restore it				MOVE.L	(SP)+,A3				;recover work register				MOVE.L	(SP)+,(SP)				;strip parameter				RTS 							;return to caller;; IfTopWants feeds the event to a driver if that driver's window is the frontMost; visible window and the driver has the event enabled.	First use FrontWindow; to find the frontMost visible window;IfTopWants				SUBQ	#4,SP					;make space for function result				_FrontWindow					;find out the frontMost window				MOVE.L	(SP)+,D0				; get windowPtr 					<1.9>				BEQ.S	DoneSEvt				; no searching for NIL windows! 	<1.9>				MOVE.L	D0,A0					; else search for window in A0		<1.9>				BSR.S	SearchWindow			;get handle to DCE that owns the window				BNE.S	DoneSEvt				;if none, we're done;; At this point, A1 is a pointer to the driver control entry that owns the window.; See if it wants this event.;				MOVE	EvtNum(A3),D0			;get number of event				MOVE	DCtlEMask(A1),D1		;get event mask				BTST	D0,D1					;this event enabled?				BEQ.S	DoneSEvt				;if not, we're done;				BSR.S	SendDrvrMsg 			;feed the event to the driver				BRA.S	DoneSysEvt				;return TRUE;;; SearchWindow takes the window pointer in A0 and fetches the windowKind. System; windows have negative kinds and the kind is the -UnitNumber of the driver.; So, using the - kind as an index into the unit table yields the handle/pointer; to the driver (if installed).; If one is found, A0 contains its handle, A1 contains a pointer and the; Z flag is set.  If none are found or the window isn't a system kind, the; Z-flag is cleared.;SearchWindow				MOVE	windowKind(A0),D0		; get the unit number from window				BPL.S	noGoodSearch			; if not sys. kind, ignore it				NOT 	D0						; flip it (bitwise)				ASL 	#2,D0					; * 4				MOVE.L	UTableBase,A0			; point to the driver table				MOVE.L	0(A0,D0),A0 			; get the handle				MOVE.L	(A0),A1 				; dereference				MOVEQ	#0,D0					; set z flag				RTSnoGoodSearch				MOVEQ	#-1,D0					; clear z flag				RTS;; SendDrvrMsg sends the driver (whose DCE pointer is in A1) a "feedEvent" control; call.  A pointer to the relevant event record is in A3;SendDrvrMsg				MOVEQ	#64,D0					;message 64 is "feedEvent";SendDCommon				LINK	A6,#-32 				;get some space for the control p-block				LEA 	IORefNum-32(A6),A0		;point A0 at the block				MOVE.W	DCtlRefNum(A1),(A0)+	;set up the refNum				MOVE.W	D0,(A0)+				;set up the control "opCode"				MOVE.L	A3,(A0) 				;set up event ptr as parameter				LEA 	-32(A6),A0				;point to pBlock				_Control  ,IMMED				;make the control call;				UNLK	A6						;de-allocate parameter block				RTS 							;return to caller;; SendRunMsg sends the "run" opcode control call to the driver whose DCE ptr is in A1; It shares lots of code with "SendDrvrMsg";SendRunMsg				MOVEQ	#65,D0					;the run message is 65				BRA.S	SendDCommon 			;use common code;; SysUpdate handles update events for system windows.  On entry, A3 points to the; event record.;SysUpdate				MOVE.L	EvtMessage(A3),A0		;get the window pointer				BSR.S	SearchWindow			;try to find the window				BNE 	DoneSEvt				;if not found, we're done;; OK, we found the driver control entry of the driver that owns the window to be; update.  Send it the "feedEvent" message;				BSR 	SendDrvrMsg 			;send update message				BRA 	DoneSysEvt				;return TRUE;; DiskHandler handles a disk inserted event by calling the file system "suck em up"; routine.	It passes the event through to the application (by returning FALSE),; adding the result of the "suck em up" call to the event.message field;DiskHandler		tst.w	EvtMessage(A3)			;if an Eject event,			<C150/09sep86>				beq.s	@1						;handle as a Command-Shift-	<C150/09sep86>			IF hasManEject THEN					;							<SM17> <BH 03Aug93>				CMPI.W	#-2,EvtMessage(A3)		; is this a manual eject?	<SM17> <BH 03Aug93>				BEQ.S	HandleManEject			;							<SM17> <BH 03Aug93>			ENDIF								;							<SM17> <BH 03Aug93>				move.l	jDoEject,A0				;							<C150/10sep86>				move.w	EvtMessage+2(A3),D1		;the drive number,			<A216/14oct86>				moveq	#1,D2					;flag from "keyboard"		<C150/10sep86>				jsr		(A0)					;eject the disk				<C150/09sep86>				bra.s	DoneSysEvt				;mark as taken, no error	<C150/09sep86>@1				SUB.W	#24,SP					;allocate 24 bytes on stack				MOVE.L	SP,A0					;point to it				MOVE.W	EvtMessage+2(A3),IODrvNum(A0) ;get the "disk ID" parameter				_MountVol						;tell OS to do its thing				ADD.W	#24,SP					;deallocate space on stack				MOVE.W	D0,EvtMessage(A3)		;return result to application				BRA 	DoneSEvt				;always return "FALSE"	IF hasManEject THEN					; <SM17> <BH 03Aug93>			IMPORT	SwitchDisk,ClearSysErrorUpdateRectHandleManEject			MOVE.W	EvtMessage+2(A3),D1	; drive number			MOVEA.L	VCBQHdr+qHead,A2@chkvcb		MOVE.L	A2,D0			BEQ.S	DoneSysEvt			; nothing to see here, folks...move along			CMP.W	vcbDrvNum(A2),D1			BEQ.S	@gotvcb			MOVEA.L	qLink(A2),A2			BRA.S	@chkvcb			@gotvcb		MOVE.W	vcbFlags(A2),D0			BTST	#vcbDirty,D0		; VCB dirty?			BNE.S	@dirtyvol			; yes: go deal with it...							<SM18> <BH 16Aug93>			MOVEA.L	FCBsPtr,A1			; no: check FCBs for dirty files...							.			MOVEQ	#2,D1				; offset to first FCB										.@chkfcb		MOVE.L	fcbFlNm(A1,D1),D0	; open file?												.			BEQ.S	@nextfcb			; no, skip it												.			CMPA.L	fcbVPtr(A1,D1),A2	; does it belong to our volume?								.			BNE.S	@nextfcb			; no, skip it												.			BTST.B	#fcbModBit,fcbMdRByt(A1,D1)	; is it dirty?										.			BNE.S	@dirtyvol			; yes, go try to get the vol back							.@nextfcb	ADD.W	FSFCBLen,D1			; offset to next FCB										.			CMP.W	(A1),D1				; reached the end yet?										.			BEQ		@offline			; yes: everything's clean, so just offline it				.			BRA.S	@chkfcb				; check out the next one							<SM18> <BH 16Aug93>@dirtyvol	MOVE.W	vcbDRefNum(A2),-(SP)	; save driver refnum			MOVE.W	vcbDrvNum(A2),vcbDRefNum(A2)	; save old drive num here			CLR.W	vcbDrvNum(A2)		; and make it look offline so MountVol can do a remount			MOVE.W	#dsDirtyDisk,D4		; err code for SwitchDisk			JSR		SwitchDisk			; ask for the disk			BSET	#7,DSWndUpdate		; don't need evt mgr to update syserr box			JSR		ClearSysErrorUpdateRect	; we'll draw over it			TST.W	D0					; SwitchDisk result			BNE.S	@warning			; DS request aborted--warn the user						SUBA.L	#ioVQElSize,SP		; volumeParam			CLR.L	ioVNPtr(SP)			; no name			MOVE.W	vcbVRefNum(A2),ioVRefNum(SP)	; vrefnum			MOVEA.L	SP,A0			_FlushVol			ADDA.L	#ioVQElSize+2,SP	; clean up stack (incl. DRefNum saved earlier)						CLR.L	-(SP)				; result space			MOVE.W	#-16413,-(SP)		; "You may now remove the disk" DLOG ID			CLR.L	-(SP)				; allocate dialog record in heap			MOVEQ	#-1,D0			MOVE.L	D0,-(SP)			; come up in front			_GetNewDialog			MOVE.L	(SP),-(SP)			; dialog ptr			MOVE.W	vcbDrvNum(A2),D0	; drive num for filter proc			MOVE.L	D0,-(SP)			; dialog ptr is already on stack			_SetWRefCon			SUBQ	#2,SP				; result			PEA		@filter				; filter to watch for ejection			PEA		4(SP)				; -> result			_ModalDialog			MOVE.W	(SP)+,A3			; result (in A3 cause it's already saved--silly, I know)			_DisposeDialog				; ptr is already on stack			MOVE.W	A3,D0			BMI.S	@offline			; disk was ejected			BRA.S	DoneSysEvt			; user OKed, disk is flushed and present			@warning	MOVE.W	vcbDRefNum(A2),vcbDrvNum(A2)	; restore VCB stuff we tweaked to			MOVE.W	(SP)+,vcbDRefNum(A2)	; make the vol look offline			CLR.W	-(SP)				; result			MOVE.W	#-16414,-(SP)		; "You may lose data" ALRT ID			CLR.L	-(SP)				; no filter			_CautionAlert			ADDQ	#2,SP				; clear result			@offline	SUBA.L	#ioVQElSize,SP		; paramblock on the stack			MOVEA.L	SP,A0				; point to it			CLR.L	ioVNPtr(A0)			; don't use the name...			MOVE.W	vcbVRefNum(A2),ioVRefNum(A0)	; use the vRefNum instead			_Offline					; mark it offline			ADDA.L	#ioVQElSize,SP		; goodbye paramblock			NEG.W	vcbDRefNum(A2)		; volume has been ejected--flip this to indicate it			BRA.S	DoneSysEvt			@filter		LINK	A6,#-14-EvtBlkSize	; some local space			CLR.W	20(A6)				; default return: false			MOVEA.L	12(A6),A0			; A0 -> evt record			CMPI.W	#keyDwnEvt,evtNum(A0)	; keyDown?			BNE.S	@update			MOVE.L	evtMessage(A0),D0	; key			CMPI.B	#$0D,D0				; return?			BEQ.S	@ok			CMPI.B	#$03,D0				; enter?			BNE.S	@chkeject@ok			MOVEA.L	8(A6),A0			; A0 -> itemHit			MOVE.W	#1,(A0)				; itemHit=OK button			MOVE.B	#1,20(A6)			; handled it, so return true			BRA		@exit			@update		CMPI.W	#updatEvt,evtNum(A0)	; update?			BNE.S	@chkeject			PEA		-18(A6)				; old GrafPtr			_GetPort			MOVE.L	16(A6),-(SP)		; dialog ptr			_SetPort			MOVE.L	16(A6),-(SP)		; dialog ptr			MOVE.W	#1,-(SP)			; OK button item number			PEA		-2(A6)				; item type			PEA		-6(A6)				; item handle			PEA		-14(A6)				; item rect			_GetDItem					; get info			PEA		-14(A6)				; item rect			MOVE.L	#$FFFCFFFC,-(SP)	; -4,-4			_InsetRect			MOVE.L	#$00030003,-(SP)	; 3,3			_PenSize			PEA		-14(A6)				; rect			MOVE.L	#$00100010,-(SP)	; curvature: 16,16			_FrameRoundRect				; outline OK button			_PenNormal			MOVE.L	-18(A6),-(SP)		; old GrafPtr			_SetPort			BRA.S	@exit			@chkeject	LEA		-14-EvtBlkSize(A6),A0	; local event record			MOVE.W	#128,D0				; disk-insert event mask			_GetOSEvent			BNE.S	@exit				; didn't get anything we wanted			TST.W	-14-EvtBlkSize+evtMessage(A6)	; really an insertion?			BPL.S	@repost				; yes: save it for later			SUBQ	#4,SP				; no: an ejection--get dialog refcon			MOVE.L	16(A6),-(SP)		; dialog ptr			_GetWRefCon			MOVE.L	(SP)+,D0			; refcon==drive number we're watching for			CMP.W	-14-EvtBlkSize+evtMessage+2(A6),D0	; got it?			BNE.S	@repost				; no: throw it back			MOVEA.L	8(A6),A0			; A0 -> itemHit			MOVE.W	#-1,(A0)			; itemHit=-1 for ejection			MOVE.B	#1,20(A6)			; handled it, so return true			BRA.S	@exit@repost		MOVE.L	-14-EvtBlkSize+evtMessage(A6),D0	; get message			MOVEA.W	#DiskInsertEvt,A0	; event type			_PostEvent					; post it			@exit		UNLK	A6					; clean up locals			MOVEA.L	(SP),A0				; get return addr			ADDA.L	#16,SP				; clean up parameters			JMP		(A0)				; return	ENDIF	;; PROCEDURE SystemClick(theEvent: EventRecord; theWindow: windowPtr);;;  SystemClick is used to feed "mouse button down" events to the driver/desk; ornament system after they've been classified by FindWindow as a click in; a system window.	If the clicked-in window is the frontmost visible window,; feed it the event.  Otherwise we unhilite the current "frontWindow" and; hilite and BringToFront the clicked in window.;SystemClick				MOVEM.L D0/D3-D4/A3-A4,-(SP)	;preserve some work registers												;D0 to reserve space on stack				MOVE.L	SP,-(SP)				;push "savePort"				_GetPort						;remember the current grafPort on stack				MOVE.L	24(SP),A4				; get theWindow into A4				MOVE.L	WindowDef(A4),A3		; get the window def proc handle into A3  <EHB 29-Jan-85>				MOVE.L	28(SP),D4				; get theEvent into D4				MOVE.L	A4,D0					; test the window ptr				BEQ 	CheckDeskHook			; if nil, check the desk hook				MOVE.L	A4,A0					; pass in A0							<EHB 29-Jan-85>				BSR 	SearchWindow			;find it in the driver list				BNE.S	DoneSClick				;if not found, ignore the call				MOVE.L	A0,D3					;remember DCE handle (formerly remembered the pointer) (from FixSystemClick) <11>;; we found the window in the device table; A1 points to the DCE entry of the driver; that owns the window.  First see what part of the window its in by calling; the window definition proc to classify.;				MOVEQ	#0,D0					;clear out high part				MOVE.B	WindowDef(A4),D0		;get selector				CLR.L	-(SP)					;make room for the result				subq	#2, SP					; room for window variant				move.l	A4, -(SP)				; push window pointer				_GetWVariant					; legally get the window variant				MOVE.L	A4,-(SP)				;push the window ptr				MOVE	#WHitMsg,-(SP)			;the message is "HitTest"				MOVE.L	D4,A0					;get the event				MOVE.L	EvtMouse(A0),-(SP)		;push the mouse point (global); don't lock window def before loading.  Be 32-bit friendly in any case.			<C151> JTC				MOVE.L	A3,-(SP)				; make sure window def proc is loaded	<EHB 29-Jan-85>				_LoadResource					;										<EHB 29-Jan-85>				MOVEA.L	A3,A0					;def proc handle	<C151>				_HLock							;lock before call	<C151>				MOVEA.L	(A3),A0					;deref the proc				JSR		(A0)					;invoke it				MOVEA.L	A3,A0					;def proc handle	<C151>				_HUnlock						;lock before call	<C151>								MOVE.L	(SP)+,D0				;get the result code				BEQ.S	DoneSClick				;if 0, nothing to do				SUBQ	#2,D0					;is it in drag?				BEQ.S	DragClick				;if so, drag it				SUBQ	#2,D0					;how about GoAway?				BEQ.S	GoAwayClick 			;if so, handle it;; its in the content of the window.  See if its on top;				CLR.L	-(SP)					;make room for function result				_FrontWindow					;figure out the frontmost one				MOVE.L	(SP)+,D0				;get the result				CMP.L	A4,D0					;is it ours?				BNE.S	NotFrontMost			;if not, go bring ours to the top;; our window is the frontmost, so send it the event;				MOVE.L	D4,A3					;get event ptr in A3; begin roll-in GetDCtlRefNumFromHandleForSendDrvrMsg patch													<11>				move.l	d3,a1					;put DCE handle in an address register to dereference it	<11>				move.l	(a1),a1					;get the DCE pointer now									<11>; end roll-in GetDCtlRefNumFromHandleForSendDrvrMsg patch													<11>				BSR 	SendDrvrMsg 			;send it the "mouseDown" message;; all done with SystemClick so restore registers, strip parameters and return to caller;DoneSClick				_SetPort						;restore it				MOVEM.L (SP)+,D3-D4/A3-A4		;restore work registers				MOVE.L	(SP)+,A0				;get the return address				ADDQ	#8,SP					;strip parameters				JMP 	(A0)					;return to caller;; CheckDeskHook is called when the user called SystemClick with a NIL window; pointer.	Call the desk hook if its installed;CheckDeskHook				TST.L	DeskHook				;got something?				BEQ.S	DoneSClick				;if not, just ignore it				MOVE.L	WmgrPort,-(SP)			;push the wmgrPort				_SetPort						;get into the wmgrPort				MOVE.L	GrayRgn,-(SP)			;push the gray region				_SetClip						;make that the clip				CLR.L	-(SP)					;push NIL				_ClipAbove						;clip to all windows				MOVE.L	D4,A0					;get event pointer				MOVE.L	DeskHook,A1 			;get address in A-reg				MOVEQ	#-1,D0					;flag its from SystemClick				JSR 	(A1)					;call the deskHook				BRA.S	DoneSClick				;all done...;; at this point, the user has clicked in a system window that isn't the frontmost.; We must unHilite the old front window, bring the one just clicked in to the; front and hilite it.;NotFrontMost;				MOVE.L	A4,-(SP)				;push our window				_SelectWindow					;select it;				BRA.S	DoneSClick				;all done!;; It was clicked in the drag area of a system window so drag it;DragClick				MOVE.L	A4,-(SP)				;push the window				MOVE.L	D4,A0					;get the event				MOVE.L	EvtMouse(A0),-(SP)		;push the point				MOVE.L	(A5),A0 				;point to grafGlobals				PEA 	ScreenBits+Bounds(A0)	;use screenBits.bounds as boundsRect				_DragWindow 					;its a drag!				BRA.S	DoneSClick;; It was clicked in the GoAway button so track it and, if necessary, close the; driver;GoAwayClick				CLR.W	-(SP)					;make room for result				MOVE.L	A4,-(SP)				;push the window				MOVE.L	D4,A0					;get the event				MOVE.L	EvtMouse(A0),-(SP)		;push the point				_TrackGoAway					;track it				TST.B	(SP)+					;time to go Away?				BEQ.S	DoneSClick				;if not, we're done;; the user pushed the GoAway button so close this driver;; begin roll-in GetDCtlRefNumFromHandleForClosingDeskAccessory patch										<11>				move.l	d3,a1					;put DCE handle in an address register to dereference it	<11>				move.l	(a1),a1					;get the DCE pointer now									<11>; end roll-in GetDCtlRefNumFromHandleForClosingDeskAccessory patch											<11>				MOVE.L	CloseOrnHook,D0 		;is there a hook installed				BNE.S	DoCloseHook 			;if so, use it				MOVE.W	DCtlRefNum(A1),-(SP)	;push the refNum				_CloseDeskAcc					;close it				BRA.S	DoneSClick				;all done!DoCloseHook				MOVE.L	D0,A0					;get hook address in A-reg				JSR 	(A0)					;invoke it				BRA.S	DoneSClick				;all done;; PROCEDURE SystemTask;;;  SystemTask is called by the applications when they don't have anything better;  to do, hopefully at least once through their main loop.	SystemTask gives;  a call to any driver that has the "NeedsTime" flag set in its header.;  SystemTask provides a way for asynchronous tasks to call the memory manager,;  since any driver can hook into "main thread" time.  The DrvrCount parameter;  in the driver header specifies the number of ticks the driver needs between;  systemTask calls.  A value of 0 causes it to be called everytime systemTask;  is called.;SystemTask; begin roll-in HMSystemTaskPatch patch												<11>				IMPORT	ptchHMGetBalloons		;									<11>				JSR		ptchHMGetBalloons		; what is the state of What Is? mode?		<11>				BEQ.S	@BalloonsOff			; no, let's not scan for a content window	<11>				SUBQ	#2,SP					; make room for a dummy OSErr		<11>				_HMBalloonBulk					;									<11>				ADDQ	#2,SP					; toss result (for now)				<11>@BalloonsOff; end roll-in HMSystemTaskPatch patch												<11>				IMPORT	NMTask					;									<V1.1>				JSR		NMTask					;Give time to Notification Manager	<V1.1>				MOVEM.L D3/A3,-(SP) 			;save some work registers;; if this is a re-entrant call, just punt;				BSET	#7,TaskLock 			;flag that we're in system task				BNE 	TaskDone				;if re-entrant, just exit;				SUBQ	#4,SP					;make space on stack				MOVE.L	SP,-(SP)				;push pointer to it				_GetPort						;remember the old port;; first see if the FrontWindow is a system Window.	If so, give it a chance to; set the cursor shape;				CLR.L	-(SP)					;make room for result				_FrontWindow					;find out the front one				MOVE.L	(SP)+,D0				; get windowPtr 					<EHB 29-Jan-85>				BEQ.S	NotSWindow				; no searching for NIL windows! 	<EHB 29-Jan-85>				MOVE.L	D0,A0					; else search for window in A0		<EHB 29-Jan-85>				BSR 	SearchWindow			;get the DCE ptr in A1				BNE.S	NotSWindow				;if we cant find it, skip;; send the window pointed to by A0 a "cursor" message;				BTST	#DrvrActive,DCtlFlags+1(A1) ;is it active?				BNE.S	NotSWindow				;skip if its active				MOVEQ	#66,D0					;D0 contains "cursor" message				BSR 	SendDCommon 			;send the cursor messageNotSWindow				MOVE.L	UTableBase,A3			;point to the driver table				MOVE.W	UnitNtryCnt,D3			;get number of entries;; here is the main loop for SystemTask.  For each driver that's installed, see if; it needs time.  If so, send it the RUN message.;SysTLoop				MOVE.L	(A3)+,D0				;get DCE handle				BEQ.S	NextTSys				;if NIL, this drivers not installed				MOVE.L	D0,A0					;need it in an A-reg				MOVE.L	(A0),A1 				;get the DCE ptr in A1;;				 BTST	 #DNeedTime,DCtlFlags(A1) ;does it need time at all?;				 BEQ.S	 NextTSys				 ;if not, go check the next one;				 BTST	 #DOpened,DCtlFlags+1(A1)  ;is it opened?;				 BEQ.S	 NextTSys				 ;if not, go check next one;				 BTST	 #DrvrActive,DCtlFlags+1(A1) ;is it active?;				 BNE.S	 NextTSys				 ;if so, don't call it				MOVE.W	DCtlFlags(A1),D0		;get the flags				AND 	#$20A0,D0				;get rid of the don't care bits				CMP.W	#$2020,D0				;in the right state (see above)				BNE.S	NextTSys				;if not, skip;; it might need time so check out the elapsed time from the last time it was called;				MOVEQ	#0,D0					;zero high part of D0				MOVE.W	DCtlDelay(A1),D0		;get delay tick count				BEQ.S	DoItNow 				;if zero, always do it				ADD.L	DCtlCurTicks(A1),D0 	;figure out next time to call it				CMP.L	Ticks,D0				;has that time passed yet?				BGT.S	NextTSys				;if not, don't call it;; its time to give it a call;				MOVE.L	Ticks,DCtlCurTicks(A1)	;update last called timeDoItNow				BSR 	SendRunMsg				;send it the "RUN" message;; here is the bottom of the main loop.	See if there are any more entries to process;NextTSys				SUBQ.W	#1,D3				BGT.S	SysTLoop				;loop if there's more to do				_SetPort						;restore it				CLR.B	TaskLock				;flag that we're doneTaskDone		MOVEM.L (SP)+,D3/A3 			;restore work registers				RTS 							;return to caller;; PROCEDURE SystemMenu(menuResult: LongInt);;;	 Feeds a menu event to the open driver that owns a menu matching the ID;  or, if MBarEnable is set, just feed it to the topMost window;SystemMenu				MOVE.L	4(SP),D1						;get the menuResult parameter				SWAP	D1						;get theMenu in low part				CMP.W	#kHMHelpMenuID,D1				; is it help menu id?				BEQ		@HandleHelpMenu					; then handle it.				CMP.W	#-kTSMSystemMenuID,D1			; is it input method menu (pencil)				BEQ		@HandleInputMethodMenu			; then handle it.				CMPI.W	#kKeyboardMenuID,D1				; is this keyboard ?				BEQ		@HandleKeyboardMenu				; then handle it				BRA		@SpecialMenusHandled; begin roll-in __SystemMenuPatch from TSMDispatch <SM16> CSS												<11>@HandleInputMethodMenu				SWAP	D1								;put the high word back				MOVE.L	D1,-(SP)						;move it onto the stack				PEA		(SP)							;push the address				IMPORT	CHANGEMENURESULTFORINPUTMETHOD				JSR		CHANGEMENURESULTFORINPUTMETHOD	;and send it to the input method				ADDQ	#4,SP							;get rid of space for menuresult				MOVE.L	(SP)+,(SP)						;strip parameter				RTS										;return to caller				; end roll-in __SystemMenuPatch from TSMDispatch <SM16> CSS; begin roll-in ptchSystemMenu from ScriptMgrSystemMenusPatch <SM16> CSS												<11>@HandleKeyboardMenu				SWAP	D1								;put the high word back				MOVE.L	D1,-(SP)						;move it onto the stack				IMPORT	HandleKeyboardMenu				JSR		HandleKeyboardMenu				;go handle the keyboard menu.				MOVE.L	(SP)+,(SP)						;strip parameter				RTS										;return to caller				; end roll-in ptchSystemMenu from ScriptMgrSystemMenusPatch <SM16> CSS												<11>; begin roll-in HMSystemMenuPatch patch												<11>@HandleHelpMenu				MOVE.L	ExpandMem,A0			; point to the expand mem ptr		<11>				MOVE.L	ExpandMemRec.emHelpGlobals(A0),A0	; A0 = global ptr		<11>					MOVE.W	#kHMHelpMenuID,hmgSystemMenuID(A0)	; set the global system menu ID to our help menu ID		<11>								SWAP	D1							; fix menuResult, so the item is in low word			<11>				MOVE.W	D1,hmgSystemMenuItem(A0)	;	and put the item into our system menu item global	<11>				CLR.W	-(SP)					; do a HiliteMenu(0); for apps that only call this			<11>				_HiliteMenu						; for their own menus [Nisus, Quicken, Adobe apps, etc.]	<11>				MOVE.L	4(SP),D1						;get the menuResult parameter again							<11>				SWAP	D1								;get theMenu in low part again								<11>; end roll-in HMSystemMenuPatch patch												<11>@SpecialMenusHandled				MOVEM.L A2-A3,-(SP) 					;preserve work registers				MOVE.W	MBarEnable,D0			;who owns the menuBar?				BEQ.S	@1						;if the app, we're cool				MOVE.W	D0,D1					;get ID in D1@1				MOVE.L	UTableBase,A2			;point to base of driver table				MOVE.W	UnitNtryCnt,D2			;get number of entries;SMLoop				MOVE.L	(A2)+,D0				;fetch DCE handle				BEQ.S	NextSM					;if none, skip				MOVE.L	D0,A0					;get handle in A0				MOVE.L	(A0),A1 				;and ptr in A1;				BTST	#DOpened,DCtlFlags+1(A1) ;is it open?				BEQ.S	NextSM					 ;if not, don't consider it				CMP.W	DCtlMenu(A1),D1 		;does this one own it?				BNE.S	NextSM					;if not, try the next one;; we found one that owns the menu, so send it the message;FeedToOrn				MOVE.L	12(SP),A3				;get param into A3				MOVEQ	#67,D0					;signal "menu" call				BSR 	SendDCommon 			;send the message				BRA.S	DoneSM					;return TRUE;; loop till we find one;NextSM				SUBQ.W	#1,D2				BGT.S	SMLoop					;loop till driver table's exhaustedDoneSM				MOVEM.L (SP)+,A2-A3 			;restore work registers				MOVE.L	(SP)+,(SP)				;strip parameter				RTS 							;return to caller; FUNCTION SystemEdit(editCmd: INTEGER): BOOLEAN;;;	SystemEdit is called by an application when it receives an edit request; from the user (usually through a menu).  If the topMost window is a system; window, SystemEdit returns true and sends the corresponding desk accessory; an edit control call; otherwise SystemEdit returns false.SystemEdit				CLR.W	6(SP)					;assume false				SUBQ	#8,SP					;make room for function result				PEA 	4(SP)					;push pointer to buffer on stack				_GetPort						;remember the port				_FrontWindow					;get the frontWindow				MOVE.L	(SP)+,D0				;is there one?				BEQ.S	DoneSEdit				;if not, we're done; There is a front window, so send it the edit message				MOVE.L	D0,A0				BSR 	SearchWindow			;get DCE ptr in A1				BNE.S	DoneSEDit				;branch if unsuccessful				MOVE.W	8(SP),D0				;get edit index				ADD.W	#68,D0					;offset it to indicate edit				BSR 	SendDCommon 			;send the message				ADDQ.B	#1,10(SP)				 ;flag it as true; all done with SystemEditDoneSEdit				_SetPort						;restore the port				BRA.S	TwoByteExit 			;use common code to exit; FUNCTION OpenDeskAcc(theName: Str255): INTEGER;;	opens a desk accessory and shows its window, returning the refCon.;	If the refCon = 0, it was a bad open.OpenDeskAcc				CLR.W	8(SP)			   ;return 0 as the default				SUB 	#32,SP			   ;get 32 bytes for a parameter block				MOVE.L	36(SP),IOFileName(SP)  ;set up name				CLR.W	IODrvNum(SP)	   ;use default volume				MOVE.W	#$0040, IOFileType(SP) ;clear type byte, special permissions to ID OpenDeskAcc				CLR.L	IOOwnBuf(SP)	   ;use system buffer				MOVE.L	SP,A0			   ;point to it				_Open					   ;open the driver				BNE.S	DoneOpenDAcc	   ;if an error, don't return refNum				MOVE.W	IORefNum(SP),D0    ;get the refNum				MOVE	D0,40(SP)		   ;return the refNum; figure out the DCE ptr				NOT.W	D0						; bitwise complement to get unitnum				ASL.W	#2,D0					; multiply by four				MOVE.L	UTableBase,A1			; get address of unit table				MOVE.L	0(A1,D0.W),A1			; add in the offset				MOVE.L	(A1),A1 				; dereference handle; get the window ptr and, if one exists, show it				MOVE.L	DCtlWindow(A1),D0		;get the window ptr				BEQ.S	DoneOpenDAcc				MOVE.L	D0,-(SP)				MOVE.L	D0,-(SP)				;push it twice				_SelectWindow				_ShowWindow 					;show it!DoneOpenDAcc				ADD.W	#32,SP					;strip the pBlock				MOVE.L	(SP)+,(SP)				;strip parameter				RTS; PROCEDURE CloseDeskAcc(refNum: INTEGER);;	close the desk accessory (or driver) with the specified refNumCloseDeskAcc				MOVE.W	4(SP),D0				;get the refNum				SUB 	#30,SP					;get space for param block				MOVE.W	D0,IORefNum(SP) 		;set up refNum				MOVE.L	SP,A0				_Close							;close it!				ADD 	#30,SP					;pop off param blockTwoByteExit				MOVE.L	(SP)+,A0				ADDQ	#2,SP				JMP 	(A0)								END                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    