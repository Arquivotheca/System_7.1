;
;	File:		RoundedWDEF.a
;
;	Contains:	The rounded window defintion procedure
;
;	Copyright:	© 1982-1991 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;		 <4>	 8/30/91	DTY		Remove a shift which prevented half of the variations from being
;									used. (Conditionilised for PsychoticFarmer.)
;		 <3>	 11/9/90	VL		(dc) Rolled back change <2> because The Gang of Five decided
;									that titles should not be drawn in TrueGray.
;		 <2>	10/30/90	VL		(KSM) Title should be drawn in TrueGray when the window is
;									inactive.
;	   <1.2>	 8/22/89	SES		Removed references to nFiles. Updated equates accordingly.
;	   <1.1>	11/11/88	CCH		Fixed Header.
;	   <1.0>	 11/9/88	CCH		Adding to EASE.
;	  <•1.1>	 9/23/88	CCH		Got rid of inc.sum.d and empty nFiles
;	   <1.0>	 2/12/88	BBM		Adding file for the first time into EASE…
;	  <C700>	 1/26/87	DAF		Universal defproc (version 10)
;	  <C491>	 12/8/86	DAF		Locked title string before drawing it (OLD BUG!)
;	  <C424>	11/18/86	DAF		Added portToMap to correct problems in cWindows.
;	  <C407>	10/13/86	DAF		changed textmode from srcBIC to srcCopy
;	  <Cxxx>	 10/6/86	DAF		updated color support to use RGB calls on Beck's. Fixed goaway
;									mask to center mask for everyone.
;				 8/22/86	DLD		Recoded draw goaway before DoHilite to fix Mac Plus system.
;	   <C60>	 8/22/86	DLD		Recoded draw goaway before DoHilite to fix Mac Plus system.
;				 7/23/86	DLD		Converted source to MPW.
;	   <C59>	 6/30/86	DAF		added color support for nuMac
;		<v4>	  8/7/85	EHB		did variable system font height version
;				 7/29/85	EHB		converted back to porkshop
;				 2/14/85	JTC		named rsrc.
;				 1/31/85	EHB		made hit-testing of GoAway box accurate
;				 1/11/85	JTC		convert to MDS
;				10/18/83	AJH		made it ignore unwanted messages; new hiliting
;				 8/20/83	AJH		made it get roundness from selector instead of refCon
;				 4/27/83	AJH		only plot, hit-test goAway if window is active
;				 3/17/83	AJH		Fixed D4 trash bug
;				  3/7/83	AJH		Made it dispose the title region (bug fix)
;				  1/2/83	AJH		Made it a "WDEF" resource
;				11/15/82	AJH		Added GoAway button, made content rectangular
;				10/16/82	AJH		Converted to QuickDraw Trap Interface
;
;	To Do:
;

;EASE$$$ READ ONLY COPY of file “RoundedWDEF.a”
; 1.2	SES 08/22/1989  Removed references to nFiles.  Updated equates accordingly.
; 1.1	CCH 11/11/1988 Fixed Header.
; 1.0	CCH 11/ 9/1988 Adding to EASE.
; OLD REVISIONS BELOW
;•1.1	CCH 9/23/1988 Got rid of inc.sum.d and empty nFiles
; 1.0	BBM 2/12/88 Adding file for the first time into EASE…
; END EASE MODIFICATION HISTORY 

;
;File RoundedWDEF.a
;-------------------------------------------------------
;
;  Rounded Corner Window Definition Routine "RDocProc"
;
;  written by Andy Hertzfeld  Aug 4, 1982
;
;  © Apple Computer, Inc. 1982, 1983, 1984, 1985, 1986, 1987
;	All rights reserved.
;
;	 This file contains the window definition procedure
;  "RDocProc", a standard Mac window type similar to the
;  "DocumentProc" included in the ROM.	It is indentical if
;  the refCon is zero, otherwise the roundness of the corners
;  is specified using the high 2 bytes of the window
;  refCon.	It is intended to be linked with applications or
;  desk ornaments.
;
;  Modification History:
;
;	16-OCt-82  AJH	Converted to QuickDraw Trap Interface
;	15-Nov-82  AJH	Added GoAway button, made content rectangular
;	02-Jan-83  AJH	Made it a "WDEF" resource
;	07-Mar-83  AJH	Made it dispose the title region (bug fix)
;	17-Mar-83  AJH	Fixed D4 trash bug
;	27-Apr-83  AJH	only plot, hit-test goAway if window is active
;	20-Aug-83  AJH	made it get roundness from selector instead of refCon
;	18-Oct-83  AJH	made it ignore unwanted messages; new hiliting
;	11-Jan-85  JTC	convert to MDS
;	31-Jan-85  EHB	made hit-testing of GoAway box accurate
;	14-Feb-85  JTC	named rsrc.
;	29-Jul-85  EHB	converted back to porkshop
;v4  7-Aug-85  EHB	did variable system font height version
;   23 Jul 86  DLD  Converted source to MPW.
;   22 Aug 86  DLD  Recoded draw goaway before DoHilite to fix Mac Plus system.
;
;----Reno World!----------------------------------------
;
;	<C59/30Jun86> DAF added color support for nuMac
;   <C60/22Aug86> DLD Recoded draw goaway before DoHilite to fix Mac Plus system.
;	<Cxxx/06Oct86> DAF updated color support to use RGB calls on Beck's.  Fixed
;						goaway mask to center mask for everyone.
;	<C407/13Oct86> DAF changed textmode from srcBIC to srcCopy
; 	<C424/18Nov86> DAF	Added portToMap to correct problems in cWindows.
;	<C491/08Dec86> DAF	Locked title string before drawing it (OLD BUG!)
;	<C700/26Jan87> DAF	Universal defproc (version 10)
;

			BLANKS		ON
			STRING		ASIS

			PRINT		OFF
			LOAD		'StandardEqu.d'
			INCLUDE		'colorequ.a'
			PRINT		ON

WDEF1		FUNC		EXPORT


; Stack Frame Definitions

WindowID	EQU		14			;								
message		EQU		12			;								

WFrameSize	EQU		-30			;	
IsColor		EQU		-30			; do we have colorQD and toolbox?  [boolean]
Align		EQU		-29			; a dead byte for IsColor			
SavFgCol	EQU		-28
SavBkCol	EQU		-22
WCTabHndl	EQU		-16			;								
WCTabPtr	EQU		-12			;								
WInfoRec	EQU 	-8			;								<7Aug85>
WAscent 	EQU 	-8			;								<7Aug85>
WDescent	EQU 	-6			;								<7Aug85>
WHeight 	EQU 	-4			;								<7Aug85>
WBoxDelta	EQU 	-2			;								<7Aug85>

;
;  FUNCTION   RDocProc(    selector: INTEGER
;			   window: WindowPtr,
;			   message: INTEGER;
;			   parameter: LongInt): LongInt
;
			BRA.S	@0

; standard header

			DC.W	0					; flags word
			DC.B	'WDEF'				; type
			DC.W	1					; ID
			DC.W	10					; version

@0
			LINK	A6,#WFrameSize		; set up a stack frame to address parameters	
			MOVEM.L D3-D5/A3-A4,-(SP)	; save work registers

; test if the message is in range

			CMP.W	#wCalcRgnMsg,message(A6) ; compare to highest value	(this is highest for rdocs)<C700/26Jan87> DAF
			BGT 	OORange					; skip it, it's too high			<C700/26Jan87> DAF
			CMP.W	#wDrawMsg,message(A6)	;  compare to lowest value, too		<C700/26Jan87> DAF
			BMI 	OORange					;									<C700/26Jan87> DAF
			
			MOVE.L	grafGlobals(A5),A0 	; get pointer to quickDraw globals			<7Aug85>
			MOVE.L	thePort(A0),-(SP)	; save current port on stack				<7Aug85>

; Determine type of system.  We need to know if we have color QuickDraw and a color
;	window manager port.
	
			CMP.W	#$3FFF,ROM85		; do we have color QD? 
			SLS		IsColor(A6)			; set boolean depending on color or B&W system
			BHI.S	@BWSys				; no, this system has B&W QD

; when using the wmgrCPort, it is the defproc's responsibility to reconcile
; 	the wmgrPort and the wmgrCPort.  

			BSR 	UpdateCPort			; compare and update wmgrPorts, also set WMgrCPort

; save off the current port fore- & backcolors on color systems. 
			
			PEA		SavFgCol(A6)		; push a pointer to save area
			_GetForeColor				; get the current color
			PEA		SavBkCol(A6)		; 
			_GetBackColor				;

; also, find the auxWinRec and lock it down
			
			CLR.L	-(SP)				; here's a space for the var handle
			CLR.W	-(SP)				; function return here
			MOVE.L	14(A6),-(SP)		; push window ptr 
			PEA		6(SP)				; a pointer to the space above
			_GetAuxWin					; find the auxrec
			ADDQ	#2,SP				; pitch the boolean (it doesn't matter)
			MOVE.L	(SP)+,A0			; get the auxRecHandle
			MOVE.L	(A0),A0				; handle -> ptr
			MOVE.L	awCTable(A0),A0		; get the colortable handle						<1.2>
			MOVE.L	A0,WCTabHndl(A6)	; save this handle
			_HLock						; lock the table down in memory
			MOVE.L	(A0),WCTabPtr(A6)	; and get a pointer too!
			BRA.S	@CommonSys			; 

@BWSys									; END OF A COLOR-ONLY SECTION
			MOVE.L	WMgrPort,-(SP)		; and set port to window manager port
			_SetPort					; 
@CommonSys								

; rdocprocs have asymmetric titles that are 19 high.  Figure it so that fonts smaller
; or equal to chicago get mapped to 19, and all others are made odd for good centering.

			LEA 	WInfoRec(A6),A3 	; point to our info rec 					<7Aug85>
@1			MOVE.L	A3,-(SP)			; push a pointer							<7Aug85>
			_GetFontInfo				; and get the font's info                   <7Aug85>
			MOVE.W	(A3)+,D0			; get ascent+2								<5Aug85>
			ADD.W	(A3)+,D0			; add descent								<5Aug85>
			ADDQ.W	#4,D0				; get the height							<5Aug85>
			BSET	#0,D0				; make height odd for symmetry				<7Aug85>
			MOVEQ	#19,D1				; get 19									<26Aug85>
			CMP.W	D1,D0				; force height to 19 min					<26Aug85>
			BGE.S	@3					; => not a tiny font						<5Aug85>
			SUB.W	D0,D1				; how much less than 19 is it?				<26Aug85>
			LSR.W	#1,D1				; used for centering tiny fonts 			<26Aug85>
			ADD.W	D1,WAscent(A6)		; make the ascent "bigger"					<26Aug85>
			MOVEQ	#19,D0				;											<7Aug85>
@3			MOVE.W	D0,(A3)+			; WHeight = ascent+descent+4				<7Aug85>
			SUB.W	#13,D0				; subtract height of box					<7Aug85>
			LSR.W	#1,D0				; divide by 2								<7Aug85>
			MOVE.W	D0,(A3) 			; save delta to goAway box				<7Aug85>

; fetch the parameters into registers

			LEA 	8(A6),A0			; get ptr to first parameter
			MOVE.L	(A0)+,D3			; get param in D3
			MOVE.W	(A0)+,D0			; get message
			MOVE.L	(A0)+,A3			; get the window pointer
			MOVE.W	(A0)+,D5			; get the selector
			
;
; <4> This line effectively reduced the number of possible variants by half.
; Take it out for PsychoticFarmer.
;

	if CubeE then
			LSR 	#1,D5				; only use 8 alternatives
	endif
			ASL 	#2,D5				; quadruple for long index
			CLR.L	(A0)				; clear out function result
;
; case out on the message number
;
			CMP 	#3,D0				; is it one we deal with?
			BGE.S	@4					; if not, skip

			ASL 	#2,D0				; quadruple for long index
			JSR 	GODOCPROC(D0)		; dispatch to appropriate routine
;
; we're done -- restore port and registers and return to caller
;

@4			
			TST.B	IsColor(A6)			; are we on a color system?			
			BEQ.S	@NoColor2			; if on B&W, then skip			

			PEA		SavFgCol(A6)		;
			_RGBForeColor				;
			PEA		SavBkCol(A6)		;
			_RGBBackColor				;
			MOVE.L	WCTabHndl(A6),A0	; unlock the colortable
			_HUnlock					;
@NoColor2								; END OF A COLOR-ONLY SECTION

			_SetPort					; restore the port						<7Aug85>
OORange									; 'Out Of Range, of course'			<C700/26Jan87> DAF
			MOVEM.L (SP)+,D3-D5/A3-A4	; restore work registers
			UNLK	A6					; unlink stack frame
			MOVE.L	(SP)+,A0
			ADD 	#12,SP				; strip parameters
			JMP 	(A0)				; return to caller
;
; DocumentProc dispatch table -- entries must be long branches!
;
GODOCPROC
			BRA 	DRAWDOC 			; draw is message 0
			BRA 	HITDOC				; hit test is message 1
			BRA 	CALCDOC 			; calc test is message 2

DoneDoc 	RTS 						; nor does it need dispose call


; utility UpdateCPort 
;	This utility compares the pertinent fields of the wmgrPort and the wmgrCPort,
;	updating the wmgrCPort as necessary to match the wmgrPort.

UpdateCPort								; <C700/26Jan87> DAF	
			MOVE.L	WmgrCPort,-(SP)		; make the wmgrCPort the current port
			_SetPort					; set it

			MOVE.L	WmgrPort,A0			; get the wmgrPort addr
			MOVE.L	WmgrCPort,A1		; and the wmgrCPort too
			
			PEA		bkPat(A0)			; push pointers to pattern for later
			PEA		pnPat(A0)			;

; copy all fields from pnLoc to end of grafPort, excluding pnPixPat and fillPixPat

			LEA		pnLoc(A0),A0					; point at source
			LEA		pnLoc(A1),A1					; point at dest
			MOVE.L	(A0)+,(A1)+						; copy pnLoc
			MOVE.L	(A0)+,(A1)+						; copy pnSize
			MOVE.W	(A0)+,(A1)+						; copy pnMode
			ADDQ	#8,A0							; skip pnPat (aka, pnPixPat,fillPixPat)
			ADDQ	#8,A1							; 
			MOVE.W	#((portRec-pnVis)/2)-1,D0		; set up a counter (long sized)
@1
			MOVE.W	(A0)+,(A1)+						; copy it
			DBRA	D0,@1							; loop
			
; now set up the patterns in the wmgrCPort (which is thePort)
;	the parameters were pushed before the copying loop above

			_PenPat
			_BackPat

			RTS							; <C700/26Jan87> DAF


; SetUpColor takes a window part identifier in D0, finds the corresponding
;	part in the AuxWinTable (the part code is in the .value field) and returns
;	a pointer to its RGB on the stack.  If the requested part is not found,
;	the first color table element is used (I'd use frameColor, but that might
;	not be there!).  Trashes A0/D0.

SetUpColor
			MOVE.L	D1,-(SP)			; save a register
			MOVE.L	WCTabPtr(A6),A0		; get the color table pointer
			MOVE.W	CTSize(A0),D1		; get the color table size
			MULU	#8,D1				; convert to color table index
LegalIndex	
			CMP.W	CTTable+value(A0,D1),D0	; is this the one?
			BEQ.S	FoundIt				; if equal, then done
			SUB.W	#8,D1				; try the previous one
			BGE.S	LegalIndex			; loop while index positive
			MOVEQ	#0,D1				; OK, use the first one
FoundIt		
			LEA		CTTable+rgb(A0,D1),A0 ; get the address of the color to use
			MOVE.L	A0,D0				; we'll need A0 in a second
			MOVE.L	(SP)+,D1			; restore the register
			MOVE.L	(SP)+,A0			; get the return address
			MOVE.L	D0,-(SP)			; push the rgb addr on the stack
			JMP		(A0)				; return to caller
			

PORTTOMAP										; <C424/18Nov86> DAF
;----------------------------------------------------------
;
; Given a window pointer in A0, return the bitmap/pixmap pointer in A0

			ADDQ	#PORTBITS,A0				;POINT TO BITMAP/PIXMAP HANDLE
			TST		ROWBYTES(A0)				;BITMAP OR PIXMAP HANDLE?
			BPL.S	GOTBITMAP					;=>JUST A BITMAP
			MOVE.L	BASEADDR(A0),A0				;ELSE GET PORT'S PIXMAP HANDLE
			MOVE.L	(A0),A0						;GET PIXMAP POINTER
GOTBITMAP	RTS			
									
;
;  DrawDoc -- draw the document window.   The windowPtr is in A3
;
DrawDoc
			TST.B	WVISIBLE(A3)		; is it visible?
			BEQ.S	DoneDoc 			; if not, don't do anything
;
; see if its a EORGoAway call and special case it
;
			CMP 	#wInGoAway,D3		; is it a goAway call?
			BEQ 	EorGoAway			; if so, go handle it

;
; derive the titleBar rectangle from the structRgn and keep it in TempRect
;
			LEA 	TEMPRECT,A0 		; get pointer to tempRect
			MOVE.L	STRUCTRGN(A3),A1	; get structure region handle
			MOVE.L	(A1),A1 			; get strucRgn pointer
			ADDQ	#RGNBBOX,A1 		; point A1 at the bounding box
			MOVE.L	(A1)+,(A0)+ 		; copy bounding box into tempRect
			MOVE.L	(A1),(A0)
;
;  make bottom := top + height
;
			MOVE	-4(A0),D0			; get top
			ADD.W	WHeight(A6),D0		; compute top + height					<EHB 7Aug85>
			MOVE	D0,(A0) 			; update bottom
;
; handle the case of non-rectangular titleBar -- we must allocate a region
;
			CLR.L	-(SP)				; make space for function result
			_NewRgn 					; allocate a region

			MOVE.L	(SP),A4 			; keep it in A4 -- and don't pop it off
			PEA 	TEMPRECT			; tempRect defines the bounding rect
			BSR 	GetRadPoint 		; get the radius point in D0
			MOVE.L	D0,-(SP)			; push the radius factor
			ST		-(SP)				; topRound is true
			CLR 	-(SP)				; botRound is false
			BSR 	MakeRoundRegion 	; make the region

; set the frame color first					

			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor3			; no, so skip this
			
			MOVE.W	#wframeColor,D0		; get element index
			BSR.S	SetUpColor			; get it on the stack
			_RGBForeColor				; and set it

; and do a PenNormal so that pattern and mode are OK (mostly for PaintRgn coming up) <C254/22Oct86> DAF
			
			_PenNormal					; 				<C254/22Oct86> DAF

@NoColor3								; END OF A COLOR-ONLY SECTION
			
; draw the titlebar outline

			MOVE.L	A4,-(SP)			; push the region
			_FrameRgn					; frame it
			
; determine the highlight state and set colors accordingly				<26Apr86>
			
			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor4			; no, so skip this
			
			TST.B	WHILITED(A3)		; is it hilited?
			BNE.S	@8					; ≠ is highlighted, = is not highlighted
			MOVEQ	#wTitleBarColor,D0	; not hilited, so paint the titlebar in this color
			BSR.S	SetUpColor			;
			_RGBForeColor
			MOVEQ	#wFrameColor,D0		; in this state, text is in frame color
			BSR.S	SetUpColor			;
			BRA.S	@9
@8			MOVEQ	#wTitleBarColor,D0	; hilited, so paint the text in this color
			BSR.S	SetUpColor			;	(foreColor is already frameColor!)
@9			_RGBBackColor
	
@NoColor4								; END OF A COLOR-ONLY SECTION
			
; now, go on and draw the rest of the titlebar

			MOVE.L	A4,-(SP)			; push it again
			MOVE.L	OneOne,-(SP)		; inset by 1
			_InsetRgn					; inset it
			MOVE.L	A4,-(SP)			; push for erase (now paint)

			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor5			; no, so erase			
			_PaintRgn					; paint it
			BRA.S	@Common5			; and continue
@NoColor5	_EraseRgn					; erase it
@Common5

;
; hilite the title bar by filling it with specified pattern
;
DrawTheTitle
			BSR 	DoTitleString		; draw the centered Title
;
; plot the goAway button, if necessary
;
			TST.B	WHilited(A3)		; if hilited window			<08/22/86 DLD>
			BEQ.S	DisposIt			; if not, don't plot goAway	<08/22/86 DLD>

			TST.B	WGoAway(A3) 		; is there a goaway button?	<08/22/86 DLD>
			BEQ.S	DoHilite			; if not, skip				<08/22/86 DLD>

			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor6			;
			MOVEQ	#notSrcCopy,D1		; plot in notsrcCopy mode	<08/22/86 DLD>
			BRA.S	@Common6			; continue
@NoColor6	MOVEQ	#srcCopy,D1			; default to srcCopy mode	<08/22/86 DLD>
@Common6								;	since we will invert	<08/22/86 DLD>
			LEA 	GoAwaySymbol,A1 	; get the goAway symbol		<08/22/86 DLD>
			BSR.S 	PlotGoAway			; draw goAway				<08/22/86 DLD>

DoHilite
			TST.B	IsColor(A6)			; is it B&W?
			BNE.S	@BW1				;
			
			SUBQ	#1,TempRect+Bottom	; adjust bottom
			PEA 	TEMPRECT			; push the title rect
			_InverRect
@BW1									; END OF A B&W-ONLY SECTION	

DisposIt
			MOVE.L	A4,-(SP)			; push the region handle
			_DisposRgn					; deallocate it
;
; frame the body of the window
;
DrawFrame
			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor8			;

			MOVEQ	#wFrameColor,D0		; get the framecolor in Fore
			BSR		SetUpColor			;
			_RGBForeColor
@NoColor8								; END OF A COLOR-ONLY SECTION	
			MOVE.L	STRUCTRGN(A3),-(SP) ; push the structure
			_FrameRgn					; frame the body
			RTS

;
; BuildTBarRect builds a rectangle enclosing the titleBar in TempRect
;
BuildTBarRect
			LEA 	TEMPRECT,A0 		; get pointer to tempRect
			MOVE.L	STRUCTRGN(A3),A1	; get structure region handle
			MOVE.L	(A1),A1 			; get strucRgn pointer
			ADDQ	#RGNBBOX,A1 		; point A1 at the bounding box
			MOVE.L	(A1)+,(A0)			; copy bounding box into tempRect
			MOVE.L	(A1),4(A0)
;
;  make bottom := top + height
;
			MOVE	Top(A0),D0			; get top
			ADD.W	WHeight(A6),D0		; add in height 						<EHB 7Aug85>
			MOVE	D0,Bottom(A0)		; update bottom
			SUBQ	#1,Right(A0)		; inset right
			RTS 						; return to caller
;
; EORGoAway hilites/unhilites the goAway button.  It falls through into PlotGoAway
;
EorGoAway
			BSR.S	BuildTBarRect		; build the bounding rect
			LEA 	GoAwaySymbol,A1 	; get the bitMap
			ADD.W	#32,A1				; bump to the EOR Mask
			MOVEQ	#SrcXOR,D1			; set EOR as the plot mode
;
; PlotGoAway plots the goAway button.  A1 holds the symbol, D1 the plotting mode
;
PlotGoAway
			LEA 	TempRect,A0 		; point to temprect 					<7Aug85>
			MOVE.W	WBoxDelta(A6),D0	; get offset from top to GABox			<7Aug85>
			ADD.W	D0,(A0) 			; add offset to top 					<7Aug85>
			SUBQ.W	#1,(A0) 			; align bitmap							<7Aug85>
			ADDQ.W	#8,2(A0)			; add margin to left					<7Aug85>
			MOVE.L	(A0)+,(A0)			; bottom/right = top/left				<7Aug85>
			MOVEQ	#16,D0				; get a constant						<7Aug85>
			ADD.W	D0,(A0)+			; Bottom = top + 16 					<7Aug85>
			ADD.W	D0,(A0) 			; Right = Left + 16 					<7Aug85>

			MOVE	D1,D0				; set plotting mode
			MOVE.L	#$00100010,D1
			BSR.S 	PlotSymbol			; plot it in tempRect
			BSR.S	BuildTBarRect		; rebuild tempRect
			RTS

;
;  PlotSymbol -- plot the little 16 by 16 symbol bitmap pointed to by A1 into the rectangle
;  pointed held in TempRect. D0 holds the mode.
;
PlotSymbol
			LEA 	IconBitMap,A0		; get pointer to source bitmap
			MOVE.L	A1,(A0) 			; update base address of bitMap
			MOVE	#2,4(A0)			; update rowBytes
			MOVE.L	#$00100010,10(A0)	; adjust boundsRect
;
; push parameters for CopyBits call to transfer arrow bitMap
;
			MOVE.L	A0,-(SP)			; push pointer source bitmap
			MOVE.L	GrafGlobals(A5),A1		; get lisaGraf global baseaddress
			MOVE.L	THEPORT(A1),A1		; get thePort
			PEA 	PORTBITS(A1)		; that's the destination bitmap
;
			PEA 	BOUNDS(A0)			; boundsRect of bitmap is source
			PEA 	TempRect			; tempRect is the destination
			MOVE.W	D0,-(SP)			; theMode is in D0
			CLR.L	-(SP)				; no mask region
;
; transfer the bitMap (stretching as necessary...)
;
			_CopyBits					; let Bill stretch those bits
			RTS 						; return to caller
;
; DoTitleString is the common code that draws the title centered in tempRect
;
DoTitleString	; on entry, temprect is title rect inset by one

			BSR 	BuildTBarRect		; calculate title bar rect

; compute indent factor based on GoAwayButton state

@1			MOVE.W	TempRect+Right,D3	; get right
			SUB.W	TempRect+Left,D3	; compute width

			SUB.W	WTITLEWIDTH(A3),D3	; compute extra x
			ASR.W	#1,D3				; divide by 2
;
; if there's a goAway button, make sure the margin is at least 28 pixels
;
			TST.B	WGoAway(A3) 		; is there a go away button
			BEQ.S	@2					; skip if there's not

			TST 	D3					; is it negative?
			BMI.S	@3					; if so, pin at 28
			CMP.W	#28,D3				; if goAway button, must have some margin
			BGT.S	@2
@3			MOVEQ	#28,D3

@2			ADD 	TempRect+Left,D3	; compute x position
			MOVE.W	D3,-(SP)			; and push for MoveTo

			MOVE.W	TempRect+Top,D0 	; get top						<7Aug85>
			ADD.W	WAscent(A6),D0		; move down to baseline 		<7Aug85>
			ADDQ.W	#2,D0				; add a little white space		<7Aug85>
			MOVE.W	D0,-(SP)			; push baseline 				<7Aug85>
			_MoveTo

			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor9			; no, so skip

			MOVE.W	txMode(A3),-(SP)	; save the xfer mode
			MOVE.W	#notsrcCopy,-(SP)	; set the text mode				<C407/13Nov86> DAF
			_TextMode
@NoColor9								; END OF A COLOR-ONLY SECTION

; draw the string

			MOVE.L	WTITLEHANDLE(A3),A0 ; get titleHandle
			_HLock						; lock that puppy			<C491/08Dec86> DAF
			MOVE.L	(A0),-(SP)			; push title pointer
			_DrawString 				; draw it
			MOVE.L	WTITLEHANDLE(A3),A0 ; get titleHandle again		<C491/08Dec86> DAF
			_HUnlock					; unlock it					<C491/08Dec86> DAF

			TST.B	IsColor(A6)			; is it color?
			BEQ.S	@NoColor10			; no, so skip
			_TextMode					; and restore textMode		<26Apr86>
@NoColor10								; END OF A COLOR-ONLY SECTION

DoneDString
			RTS 						; all done drawing title...

;
;  GetRadPoint returns the radius in D0 of the round rect parameter defined
; by the selector parameter
;
GetRadPoint
			MOVE.L	RadiusTable(D5),D0
			RTS

RadiusTable
			DC.L	$00100010			; (16,16)
			DC.L	$00040004			; (4,4)
			DC.L	$00060006			; (6,6)
			DC.L	$00080008			; (8,8)
			DC.L	$000A000A			; (10,10)
			DC.L	$000C000C			; (12,12)
			DC.L	$00140014			; (20,20)
			DC.L	$00180018			; (24,24)
;
;  MakeRoundRegion -- makes a round region given a bounding rectangle and a radius
;  value.  Also, half round regions (top round, bottom square) are supported
;  by the topRound,botRound booleans
;
;	  MakeRoundRegion( theRgn:RegionHandle
;			 theRect:		 Rect
;			 xRad,yRad:  INTEGER
;			 topRound,botRound: BOOLEAN)
;
MakeRoundRegion 						; ???? was ...Rgn
			LINK	A6,#0				; set up stack frame
			MOVE.L	A3,-(SP)			; save work registers
			TST.L	8(A6)				; are flags both	false?
			BEQ.S	PlainRect			; if so, its just a rectangle
			TST.L	12(A6)				; is radius factor 0?
			BNE.S	ComplexRect 		; if not, its a round one
;
; optimize for the rectangular case
;
PlainRect
			MOVE.L	20(A6),-(SP)		; push region handle
			MOVE.L	16(A6),-(SP)		; push	rectangle pointer
			_RectRgn					; make a	rectangular region
			BRA.S	MMRDone 			; all done!
;
; make a region with top and bottom corners rounded
;
ComplexRect
			_HidePen					; hide the pen
			_OpenRgn					; start recording the region
;
			MOVE.L	16(A6),-(SP)		; push the rectangle pointer
			MOVE.L	12(A6),-(SP)		; push the radius point
			_FrameRoundRect 			; define the region
			MOVE.L	20(A6),-(SP)		; push region handle
			_CloseRgn					; assign roundRect region
;
			_ShowPen					; enable drawing again
;
; now square up either the top or bottom of the region (or neither)
;
			MOVE.L	16(A6),A0			; get rectangle pointer
			TST.W	8(A6)				; examine 'botRound' flag
			BNE.S	CheckTRound 		; if true, see if top needs squaring
			MOVE	BOTTOM(A0),D1		; get bottom y coordinate
			MOVE	D1,D0
			SUBQ	#8,D0				; compute top
			BRA.S	SquareIt
;
CheckTRound
			TST.W	10(A6)				; examine 'topRound' flag
			BNE.S	MMRDone 			; if that true, we're done
			MOVE	Top(A0),D0			; get top y coordinate
			MOVE	D0,D1
			ADDQ	#8,D1				; get bottom
;
; here we build a rect in ToolScratch that has the same X as tempRect, but centered
; around the top or bottom
;
SquareIt
			LEA 	ToolScratch,A1		; get pointer to dest Rect
			MOVE	D0,(A1)+			; update top
			MOVE	Left(A0),(A1)+		; copy left
			MOVE	D1,(A1)+			; update bottom
			MOVE	Right(A0),(A1)		; copy	right
;
; now make a region out of that rectangle
;
			CLR.L	-(SP)				; make space for result
			_NewRgn 					; allocate a new region
			MOVE.L	(SP),A3 			; keep a copy in	A3
			PEA 	ToolScratch 		; push the rectangle pointer
			_RectRgn					; make the rectangular region
;
; now union with the parameter region to square up the edges
;
			MOVE.L	20(A6),-(SP)		; push destination region
			MOVE.L	A3,-(SP)			; push square region
			MOVE.L	20(A6),-(SP)		; dest gets the result
			_UnionRgn
;
; all done -- deallocate the temporary region
;
			MOVE.L	A3,-(SP)
			_DisposRgn
;
MMRDone
			MOVE.L	(SP)+,A3			; restore work reg
			UNLK	A6					; unlink stack frame
			MOVE.L	(SP)+,A0			; get return address
			ADD 	#16,SP				; strip parameters
			JMP 	(A0)				; all done!

; HitDoc -- perform a hit test on the document.  On entry, D3 contains the mousePoint
; in global coordinates while A3 holds the window pointer
;
HitDoc
			MOVEQ	#16,D4				; keep 16 in a register to save code
			CLR.W	-(SP)				; make room for function	result
			MOVE.L	D3,-(SP)			; push the mouse	point
			MOVE.L	CONTRGN(A3),-(SP)	; push content region handle
			_PtInRgn					; is the point in the content region?
			TST.B	(SP)+				; well, is it?
			BEQ.S	NotInContent		; if not, go check out drag region

; the point is in the content region so return a '1'

justContent
			MOVEQ	#wInContent,D0		; return in content
			BRA.S	DoneHitDoc			; go store function result and return

; its not in the content -- see if its in the dragRgn (content extended by titleBar)

NotInContent

			CLR.W	-(SP)
			MOVE.L	D3,-(SP)
			MOVE.L	StructRgn(A3),-(SP)
			_PtInRgn
			TST.B	(SP)+
			BEQ.S	DoneHit1

			CLR.W	-(SP)				; make room for function result
			MOVE.L	D3,-(SP)			; push the mouse point
			MOVE.L	ContRgn(A3),A4		; get content region handle
			MOVE.L	(A4),A4 			; get region ptr
			ADDQ	#RgnBBox,A4 		; get bounding box ptr
			MOVE.W	WHeight(A6),D0		; get height of title bar				<7Aug85>
			SUB.W	D0,Top(A4)			; decrease by height of title bar		<7Aug85>
			MOVE.L	A4,-(SP)			; push the rect
			_PtInRect					; is the point in the title bar?
			MOVE.W	WHeight(A6),D0		; get height of title bar				<7Aug85>
			ADD.W	D0,Top(A4)			; and fix the bounding box up			<7Aug85>

			TST.B	(SP)+				; examine result
			BEQ.S	DoneHit1			; if not, return 0 (do nothing)

; see if its in leftmost 16 of drag, which is the goAway button

			TST.B	WGoAway(A3) 		; is there a goAway button?
			BEQ.S	ItsInDrag			; if not, skip
			TST.B	WHilited(A3)		; only draw it for the active one
			BEQ.S	ItsInDrag

			MOVE	D3,D0				; get mousePt
			MOVE.L	A3,A0				; copy the windowPtr for PortToMap	<C424/18Nov86> DAF
			BSR		PortToMap			; convert it						<C424/18Nov86> DAF	
			ADD 	Bounds+Left(A0),D0	; convert to local					<C424/18Nov86> DAF
			SUB 	PortRect+Left(A3),D0	; compensate for origin
			CMP 	#18,D0				; is it too far right?
			BGT.S	ItsInDrag			; if so, its in drag
			SUBQ	#8,D0				; it must be at least 8
			BMI.S	ItsInDrag

			MOVE.L	D3,D0				;; now check vertical
			SWAP	D0					;; which is high word of D3
			ADD.W	Bounds+Top(A0),D0	;; convert to local	(A0 is still valid)	<C424/18Nov86> DAF
			SUB.W	PortRect+Top(A3),D0 	;; compensate for origin

; D0 is aligned with 0 as the bottom of the title bar.

			ADD.W	WBoxDelta(A6),D0		; below box?				<7Aug85>
			BPL.S	ItsInDrag				; => yes					<7Aug85>
			ADD.W	#11,D0					; in box?					<7Aug85>
			BMI.S	ItsInDrag				; => no 					<7Aug85>

; its in the goAway button so signal it

			MOVEQ	#wInGoAway,D0
			BRA.S	DoneHitDoc

ItsInDrag
			MOVEQ	#wInDrag,D0 		; flag in drag region
DoneHitDoc
			MOVE.L	D0,20(A6)			; update function result
DoneHit1	RTS


; CalcDoc  -- calculate the structure and content regions for the window pointed
; to by A3.

CalcDoc
			LEA 	TEMPRECT,A0 		; get a pointer to the work rectangle
			MOVE.L	A0,-(SP)			; push for later offset
			MOVE.L	PORTRECT(A3),(A0)+	; copy topLeft of portRect
			MOVE.L	PORTRECT+4(A3),(A0) ; copy botLeft of portRect

; offset it to global coordinates

			MOVE.L	A3,A0				; copy window pointer				<C424/18Nov86> DAF
			BSR		PortToMap			; convert pointer, if necessary		<C424/18Nov86> DAF
			MOVE.L	BOUNDS(A0),-(SP)	; push topLeft of port.portBits.bounds <C424/18Nov86> DAF
			NEG 	2(SP)				; negate	offset
			NEG 	(SP)
			_OffsetRect 				; offset	tempRect to global coordinates

; make the content region square for fast updating

			MOVE.L	CONTRGN(A3),A0		; A0 holds the content region
			CLR 	D1					; topround is false
			BSR.S	GOMAKERGN			; go make the region into content region

; now do the structure region.	First correct the bounding rectangle (tempRect) for
; structure instead of content

			PEA 	TEMPRECT			; push a	pointer to the rect
			MOVE.L	MinusOne,-(SP)		; make 1	pixel bigger, all around
			_InsetRect					; make it bigger

			MOVE.W	WHeight(A6),D0		; move up to top of window				<7Aug85>
			SUBQ.W	#1,D0				; tweak it								<7Aug85>
			SUB.W	D0,TempRect+Top 	; and set top of struct region			<7Aug85>

			MOVEQ	#1,D1				; topRound is true
			MOVE.L	STRUCTRGN(A3),A0	; A0 holds the structRgn	pointer

GoMakeRgn
			MOVE.L	A0,-(SP)			; push the region handle
			PEA 	TEMPRECT			; push bounding rectangle pointer
			BSR 	GETRADPOINT 		; get the radius	factor
			MOVE.L	D0,-(SP)			; push it
			MOVE.W	D1,-(SP)			; topRound is in	D1
			ST		-(SP)				; so is botRound
			BSR 	MakeRoundRegion 	; go make the region

; all done with CalcDocRgns

			RTS

;
; BitMap for default GoAway button

GoAwaySymbol
			DC.W	$0000,$0000,$7FF0,$4010
			DC.W	$4010,$4010,$4010,$4010
			DC.W	$4010,$4010,$4010,$4010
			DC.W	$7FF0,$0000,$0000,$0000

; brand-new, centered mask						<Cxxx/06Oct86> DAF

			DC.W	$0000,$0000,$7FF0,$4210
			DC.W	$5250,$4A90,$4010,$5DD0
			DC.W	$4010,$4A90,$5250,$4210
			DC.W	$7FF0,$0000,$0000,$0000

			END 
;



