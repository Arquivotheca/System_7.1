;
;	File:		ScriptMgrExtTail.a (formerly SMgrExtTail.a)
;
;	Contains:	Installation and initialization code at the end of the Script Mgr extensions patch, ptch 27.
;
;	Written by:	PKE	Peter Edberg
;				SMB	Sue Bartalo
;				JH	John Harvey
;				KSM	Kevin MacDonell
;				YK	Yousuke Kurita
;
;	Copyright:	© 1989-1992 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;		<62>	 6/17/92	HA		#1029756,<PKE>: #1029756 <PKE> make sure that we stuff the real
;									vector of StyledLineBreak after moving it to ptch 27.
;		<61>	 5/19/92	PKE		#1030321,<jh>: Add installation of private interface to existing
;									NFindScriptRun routine.
;		<60>	 5/14/92	PKE		#1027061,<ha>: Add installation of private ScriptToRange
;									routine.
;		<59>	 5/10/92	SMB		#1026551,<pke>: Deleted patch installation code for
;									ptchDrawMenuBar since no longer patching this. (See
;									ScriptMgrKeyGetSet.a comments for new strategy.)
;		<58>	 4/30/92	DTY		Get rid of debugger breaks that Jeff left lying around.
;		<57>	 4/29/92	JSM		Don’t include ScriptMgrDispatch.a and ScriptMgrKetGetSet.a here,
;									link them in instead, delete some unneeded include files.
;		<56>	 4/28/92	JSM		Move all resident code to ScriptMgrExtensions.a. Leave tail
;									patch ptchLwrString here (compiled only when FixCacheAndStr2Date
;									is true), it now jumps to ScriptMgrExtensions.a. Also leave
;									GetScaledFontInfo routine here, and make sure it only compiles
;									when useInterChar is true since the only place that calls it is
;									in RomanNewJust.a under the same condition. This saves some
;									space in CubeE. Note that these two things are the only pieces
;									of resident code now left in this file, and under the current
;									conditional settings none of them are compiled. They probably
;									don’t work anyway and should be removed, but I left it here.
;									Only fix up ROM binds if there are any (i.e. if either of the
;									above routines are compiled). Don’t include GestaltEqu.a or use
;									smgrSysVers conditional anymore.
;		<55>	 4/22/92	PKE		#1026767: (no reviewer before check-in: it is late at night,
;									nobody is around, I am going out of town early tomorrow morning,
;									and I have to have this in for the a7 build) Don't load handles
;									in itl2/itl4 cache, since we no longer cache handles, just IDs.
;		<54>	 4/22/92	PKE		#1027368,<FM>: Move Roman CharType here and make it handle
;									direction bit for R-L scripts.
;		<53>	 4/10/92	SMB		#1026551,<pke>: Install head patch to DrawMenuBar to handle
;									disabling for Keyboard Menu state.
;		<52>	 4/10/92	PKE		#1026778,<amw>: To make FindWord not depend on having script
;									code passed in d2 (script code will not be in d2 when it is
;									called from one-byte extension), need to have script code in new
;									scriptID field of ScriptRecord. InitScripts must set this up at
;									boot.
;		<51>	  4/8/92	PKE		#1025369,<cv>: Holding down Shift should disable loading of
;									Simple Scripts (e.g. Cyrillic).
;		<50>	  4/2/92	PKE		#1025998,<ha>: (actually part of fix for bugs #1025998,
;									#1025364, #1025998, #1024837) Move Roman GetScript/SetScript
;									here and change them to not require selector on the stack, so
;									they will work if called from one-byte extension. They used to
;									just branch to the unimplemented routine handler, which needed
;									the selector. This also fixes an old bug in which Roman
;									SetScript did not return the correct error code for bad verbs.
;		<49>	 2/13/92	PKE		#1021419, Cube-E: Change Roman dispatch table to have nil
;									(instead of address of unimplemented routine) for IsSpecialFont
;									& RawPrinterValues. This makes one-byte extension handle them
;									properly.
;		<48>	 2/11/92	DCL		Changed the name of TSMEqu.[aph] to TextServices.[aph] for
;									better read-ability.
;		<47>	  1/7/92	JH		InitScripts has a subroutine called FixFond that claims that a2
;									contains a ptr to some scripts globals. In actual case, a3
;									contains said pointer and a2 contains a ptr to the script's
;									itlb. So changing FixFond to reflect this.
;		<46>	12/11/91	SMB		For CubeE, updated dependencies to include TSMequ.a &
;									Component.a.
;		<45>	12/10/91	PKE		#1017754: For non-ROM builds, move PrintAction here for all
;									CPUs, and change it to leave ScriptRecord ptr in a0.
;		<44>	 12/6/91	PKE		#1017161: Make TestLetter available through private Script Mgr
;									selector, for use by script systems. Move it to resident code
;									section.
;		<43>	11/21/91	YK		InputUtils were gone.  What was that!?
;		<42>	 11/8/91	SMB		#1015613 (for CubeE & Bruges) - Update dependencies to include
;									MenuMgrPriv.a.
;		<41>	10/28/91	PKE		#1014968 (for Cube-E & Bruges): InitScripts should set
;									SysFontFam and ApFontId to the values it believes are correct
;									even the values already there are in the correct script.
;		<40>	10/25/91	YK		Don't load an InputUtils resource at init.  Unnecessary clearing
;									code was commented out.
;		<39>	10/23/91	YK		Added InitDictionaryMgr and InitInputUtils at the end of
;									SMgrInstallExt.
;		<38>	 10/8/91	PKE		For Cube-E (and Bruges): Move remainder of LwrString here from
;									ScriptMgrPatch.a (ptch 4), modify to use GetScriptItl and
;									SCTransliterate, and add SCLwrString entry; install new
;									(currently private) RealScript, Font2RealScript, SCLwrString
;									routines in dispatch table (needed for bugs #1013149, #1012949).
;									Include IntlUtilsPriv.a. Clean up some more conditionals.
;		<37>	 9/26/91	PKE		For Cube-E (and Bruges): Update InitScripts to initialize
;									TESysJust from 'itlc' resource, and to set smgrBidirect and
;									smgrDoubleByte according to enabled scripts. Fix
;									auto-initialization so Opt-E (on any keyboard!) disables simple
;									scripts too; to do this, make some changes in IsCmdChar so we
;									can share code. Also conditionalize out some code related to
;									interchar spacing in Roman (not used). Remove some conditionals
;									for smgrSysVers>=$700 and smgrSysVers>=$606, and remove some old
;									code for smgrSysVers<$700.
;		<36>	 8/22/91	KSM		PKE,#Bruges: Nobody told me the ScriptMgr dispatcher left its
;									selector on the stack...
;		<35>	 2/15/91	PKE		JSM,#54736: Redo conditionals to move change <34> to Post 7.0.
;									Object compare identical to <33>.
;		<34>	 1/28/91	JH		PKE,#54736: Added a comefrom patch to _LowerString so that
;									String2Time could use the new Date Cache structure.
;		<33>	 1/14/91	PKE		(stb, except that routine in here by KSM was reviewed by PKE,
;									with algorithm review by dba): Allocate handle to ClientLLRecord
;									and put handle in SMgrRecord. Add Kevin’s private FindCharInSet
;									routine to be called by Dialog Mgr and Finder.
;		<32>	12/10/90	PKE		(VL) Add private ReInitScripts routine to be called after net
;									booting switches system files. It cleans up Script Mgr data
;									structures based on resources in old file, then calls
;									InitScripts to set up new structures based on current file.
;		<31>	 9/17/90	SMB		(PKE) NEEDED FOR SIXPACK & SS-606. Must test for itl2 extensions
;									before loading FindScriptTable. Bug fixes in FindScriptRun code:
;									needed to branch unsigned, special case for length of 1, used .w
;									rather than .l when adding to pointers, and slight
;									size/performance improvement.
;		<30>	  9/1/90	PKE		When expanding the Roman dispatch table, need to fill in
;									BitBucket entries for the two special Kanji selectors, which are
;									not implemented in Roman. Otherwise print driver may try to call
;									IsSpecialFont or RawPrinterValues for Roman, and crash.
;		<29>	 8/24/90	PKE		CleanupScriptApp should reset ExpandMemRec.emScriptAppGlobals to
;									0 to ensure that we don’t try to use a disposed handle.
;		<28>	  8/2/90	PKE		Initialize application-specific Script Mgr globals to all 0.
;		<27>	 7/25/90	PKE		Add private InitScriptApp and CleanupScriptApp routines to be
;									called when apps are launched and closed in order to set up and
;									delete the new application-specific script globals (which, for
;									now, just contain the application itl cache). Renamed
;									emItlAppCacheHndl to emScriptAppGlobals.
;		<26>	 7/20/90	PKE		Changes to InitScripts, AddScriptFonts, and patch
;									initialization: (1) Move FixSMgrWorld code to InitScripts and
;									patch out ROM version entirely. Change script enable loop so IT
;									copies extended itlb info into ScriptRecord, instead of doing it
;									in patch initialization separately for Roman and simple scripts.
;									We now get extended font info from script’s itlb resource
;									regardless of the state of the auto-initialization bit. (2) Move
;									setting of smgrRegionCode to InitScripts. (3) InitScripts now
;									pre-loads the sys itl cache. (4) InitScripts now loops through
;									each enabled script and calls its scriptAvail vector (if ≠0).
;									(4) AddScriptFonts now loops through each enabled script and
;									calls its scriptAddFonts vector (if ≠0). Also, don’t bother
;									doing ReleaseResource on purgeable resources.
;		<25>	 7/16/90	PKE		Use new names for fields in ExpandMemRec: emItlCache2Ptr becomes
;									emItlSysCachePtr, emItlAppCachePtr becomes emItlAppCacheHndl.
;									Renamed Cache2Rec to NewItlCacheRec.
;		<24>	 7/11/90	PKE		Added private routine IsCmdChar for checking Command-key combos
;									in an international way (needed mainly for Command-period, and
;									needed by new standard Filter Proc for dialogs…).
;		<23>	  7/2/90	PKE		Initialize emItlAppCachePtr to -1.
;		<22>	 6/13/90	PKE		Install private RebuildKeybdMenu routine in Script Mgr dispatch
;									table.
;		<21>	  6/7/90	PKE		Move GetScaledFontInfo routine here from RomanNewJust. Use BINDs
;									so that we jump into ROM code for most of it. Rearrange its
;									parameter order for efficiency. Initialize new emNumer and
;									emDenom fields in ExpandMemRec.
;		<20>	  6/5/90	SMB		Fixed odd address bug when initializing Roman scriptRecord
;									fields scriptValidStyles and scriptAliasStyle from Roman 'itlb'.
;		<19>	 5/31/90	PKE		Install new private routine SetKbdMenuInfo. Initialize Roman
;									scriptRecord fields scriptValidStyles and scriptAliasStyle from
;									Roman 'itlb'.
;		<18>	 5/29/90	PKE		NEEDED FOR SIXPACK DISK: Moved ParseTable here from ptch 4 so we
;									can fix an old unbalanced stack bug in both RAM and ROM
;									versions. Also, for 6.x, don’t override version number set in
;									ROM or ptch 4. The new sections are flagged with <18>.
;		<17>	 5/24/90	PKE		Moved ScriptUtil dispatcher and FontScript, Font2Script,
;									IntlScript here (ptch 27) from ScriptMgrUtil.a (ptch 4).
;									Combined ScriptUtil dispatcher with special FindWord patches
;									that were already here. Changed FontScript, Font2Script,
;									IntlScript to default to system script instead of Roman. These
;									routines are all in a separate file, ScriptMgrDispatch.a, which
;									is included here.
;		<16>	 5/11/90	PKE		Add _AddScriptFonts routine and its installation.
;		<15>	  5/8/90	PKE		Added the meat to InitScripts: it now initializes new sort cache
;									and script/lang map tables.
;		<14>	  5/5/90	PKE		NEEDED FOR 6.0.7 AND 7.0: Fixed a bug introduced in <13>: Simple
;									scripts were not getting initialized correctly because one of
;									the new SimpleTable entries had a value of 0, which terminated
;									the table. Changed terminator to be -1. Relevant lines are
;									marked <**>. NEEDED ONLY FOR 7.0: Added private ScriptUtil
;									routine InitScripts (called by StartSystem.a); it calls
;									FixSMgrWorld and then does other extensions that have yet to be
;									added. Install InitScripts and Sue’s InitKeyboardMenu routine
;									into Script Mgr dispatch table. Added Sue’s installation for her
;									SystemMenu patch. Added doExpandSMgrDispTable conditional
;									symbol.
;		<13>	 4/26/90	PKE		NEEDED FOR 6.0.7: Cleaned up script auto-initialize stuff - use
;									SimpleTable loop to initialize scriptVersion, scriptCreator,
;									scriptFile instead of of explicitly initializing them.
;		<12>	 4/10/90	PKE		Moved KeyScript, Get/SetEnvirons, and Get/SetScript into a
;									separate file ScriptMgrKeyGetSet.a, which is included here.
;									Moved all of the roman routines that handle justified text into
;									a separate file RomanNewJust.a, which is assembled separately
;									and linked in. Moved TruncString, TruncText, and ReplaceText
;									into another separate file ScriptMgrTruncRepl.a which is also
;									assembled separately and linked in. Adjusted the includes
;									accordingly. Wrong version was being put into simple script
;									ScriptRecords; fixed it.
;		<11>	 3/26/90	PKE		Conditionalize so ptch 27 can be used in Sys 6.0.7+ to get
;									script auto-initialize capability. Use new conditionals
;									doScriptMgrGestalt, doScriptMgrLwrString2; otherwise just
;									conditionalize on smgrSysVers (need to improve this later).
;		<10>	 3/22/90	PKE		Now initialize Roman font data from 'itlb' resource. Get Help
;									Mgr font/size from 'itlb' for all scripts.
;		 <9>	 3/21/90	PKE		Changed scrTable so GetScript and SetScript support new
;									smScriptAppFondSize and smScriptHelpFondSize verbs.
;		 <8>	 3/21/90	SMB		For 7.0, move FindScriptRun here from ptch 4 and modify it to
;									handle any simple script using optional table in itl2. Add
;									automatic installation of simple scripts.
;		 <7>	  3/5/90	PKE		In TruncString/TruncText, changed NTruncX selectors to TruncX.
;		 <6>	  3/2/90	PKE		Use new name nItl4Rec for 7.0 extended version of Itl4Rec.
;		 <5>	 2/22/90	PKE		For 7.0, moved Char2Pixel, DrawJust, MeasureJust here because we
;									patch them out entirely for ROM; added these to NewRomanTable so
;									their vectors get filled in. Added new InitJustData,
;									AdjustSpChExtra, and RestoreSpChExtra utility routines for
;									handling justification parameters with intercharacter spacing,
;									using new JustDataRec structure. Added other utility routines
;									GetFontSize, DrawGap, SignFixRound. Rewrote (N)PortionText,
;									(N)DrawJust, (N)MeasureJust, (N)Char2Pixel and (N)Pixel2Char
;									routines to fully implement the new justification model, using
;									the above utility routines. Also made the ‘N’ versions standard
;									for these routines, so that the old interfaces just redo the
;									stack and fall through to the new routines.
;		 <4>	 1/18/90	PKE		Fixed bug introduced in <2>: for most of the installation code,
;									a4 was assumed to point to SMgrRecord, but the RomanUtil
;									dispatch table update in <2> made it point to the Roman
;									ScriptRecord, messing up subsequent initializations; we now
;									point it back to SMgrRecord after the RomanUtil dispatch table
;									update. Now initialize smgrRegionCode from the itlc resource.
;		 <3>	 1/17/90	PKE		Added handling of new GetEnvirons verb smRegionCode.
;		 <2>	 1/11/90	PKE		Moved Roman PortionText and Pixel2Char here so we can fix them
;									later for all systems (deal with color grafPorts, etc.) and also
;									to reduce duplication of code in new interfaces. We may move
;									other Roman routines here later. Added crude implementations of
;									some new interfaces: NPortionText, NDrawJust, NMeasureJust,
;									NChar2Pixel, and NPixel2Char. These ignore styleRunPosition, but
;									otherwise behave as specified. Added code to expand the
;									RomanUtil dispatch table if necessary (i.e. for ROM version of
;									ScriptMgr) and fill in vectors for PortionText, Pixel2Char, and
;									new interfaces listed above. Updated header to be in BBS format.
;		 <1>	12/18/89	CCH		Adding for the first time into BBS. Changed include 'inc.sum.a'
;									to load 'StandardEqu.d'. Updated file name references.
;	(BBS versions above, EASE versions below)
;	   <1.8>	 12/8/89	PKE		FOR 7.0: Patch LwrString to handle 2-byte chars via
;									Transliterate (yuck), including extensions to handle LwrString
;									opcode bits.
;	   <1.7>	 11/8/89	PKE		Modify TruncString and TruncText to support both new and old
;									calling conventions (with and without truncWhere parameter).
;									Implement handling of center truncation (in TruncText).
;	   <1.6>	 10/2/89	PKE		Added code in GetEnvirons/SetEnvirons to handle new smKCHRCache
;									verb.
;	   <1.5>	 9/18/89	PKE		Moved KeyScript here from ptch 4 so we can move 'itlk'
;									GetResource after the point at which meta-script numbers are
;									mapped to real script numbers and checks are made for script
;									installed and enabled. Replaced the _GetScript call in this
;									'itlk' stuff with a direct access to ScriptRecord since we have
;									already done the validity checking.
;	   <1.4>	 9/17/89	PKE		Better error reporting in TruncText, ReplaceText. Moved
;									gestaltScriptMgr function, GetEnvirons/SetEnvirons and
;									GetScript/SetScript here from ptch 4 for 7.0 so we can remove
;									gestaltScriptMgr and Get/SetScript from PTCH files and so we
;									don't have to also add Get/SetEnvirons there. Added new
;									smDoubleByte verb for Get/SetEnvirons. Also moved initialization
;									of new ScriptRecord font/size fields for Roman system here from
;									ptch 4 and PTCH files. Updated Roman Script System version using
;									new romanVersPriv constant.
;	   <1.3>	 9/15/89	PKE		Change NFindWord references to xNFindWord, do install it again
;									in dispatch table - we'll permit direct calls in addition to
;									getting to it from the old FindWord selector via the glue. Add
;									and install framework code for TruncString, TruncText,
;									ReplaceText. Stuff correct version number in SMgrRecord.
;	   <1.2>	  9/5/89	PKE		Add ScriptUtil patch which checks for FindWord call, sets up and
;									checks tables, and decides between new or old FindWord. Don't
;									install NFindWord address in trap table anymore. Include
;									'PackMacs.a'.
;	   <1.1>	  9/4/89	PKE		Put new routine addresses into dispatch table pointed to by
;									smgrDispTable, expanding it if necessary (i.e. for ROM version
;									of Script Mgr).
;	   <1.0>	  9/1/89	PKE		Set up framework for 'ptch' resource 27, which contains 7.0
;									extensions for Script Mgr. This file and ScriptMgrExtHead.a
;									replace SMgrExt.a.
;___________________________________________________________________________________________________
;	To Do:
;			Figure out best way to use FindWord glue for ROM too.
;			Figure out best way to use new initialization stuff for ROM too.
;
;___________________________________________________________________________________________________

			blanks	on
			string	asis
		
			LOAD	'StandardEqu.d'
			include 'ScriptPriv.a'
			include	'PatchMacros.a'
	
; =============================================================================
; RESIDENT CODE
; Code that is not in ROM															<56>
; Note: as the conditionals stand now, none of the following code is used.
; =============================================================================

			ROMVersions	MacPlus,MacSE,MacII,Esprit,Aurora

FixCacheAndStr2Date		equ		0			; do this for 7.1? (not 7.0.1)		<35>
useInterChar			equ		0			; Turn off code related to interchar spacing in Roman	<37>
											; also defined in RomanNewJust.a

		IF FixCacheAndStr2Date THEN			;									<34><35>

;
; for ptchComeFromString2Time
; note all the MacPlus,$0 kind of parameters this is only to keep the FixRomAddress macro happy
; the patch code will never be reached on a Plus,SE, or II since String2Time doesn't exist in the ROM

ROMMatchStringJSR		BIND	(MacPlus,$0),(MacSE,$0),(MacII,$0),(Aurora,$1F664),(Esprit,$19142)
ROMStr2TimeUprText		BIND	(MacPlus,$0),(MacSE,$0),(MacII,$0),(Aurora,$1F64C),(Esprit,$1912A)

ptchLwrString	proc	export

; If we are coming from String2Time on Portable or IIci ROMs, change return
; address so we return to ROM through our tail patch. Makes changes in String2Time
; to accomodate new cache structure. Slime central.
			bra.s	@protection
			BackToTrap	oldLwrString2	; Jump back to the Rom
@protection
			move.l	RomBase,a1			; note: preserve a0,d0,d1 for LwrString
			move.w	8(a1),d2			; get ROM number as word
			cmp.w	#Esprit,d2			; is this a Portable?
			beq.s	@tweakRetnAddr		; if so, see if we're in String2Time
			cmp.w	#Aurora,d2			; is this IIci family?
			bne.s	@beginRealPatch		; if not, skip check for String2Time
@tweakRetnAddr
			CMPBIND	ROMStr2TimeUprText,OSTrapReturnAddressDepth(sp)	; From String2Time?
			bne.s	@beginRealPatch					; if not, just continue with patch
			lea		ptchComeFromString2Time,a1		; addr for LwrString to return to
			move.l	a1,OSTrapReturnAddressDepth(sp)	; so trap returns to patch, not ROM
@beginRealPatch
		
		import		NewLwrString		; in ScriptMgrExtensions.a					<56>
		bra.s		NewLwrString		;											<56>

		endproc

; ----------------------------------------------------------------------------
; Tail patch to LwrString, changes String2Time to use new cache structure			<34>
; ----------------------------------------------------------------------------

; include new cache record here
; it will redefine TimeLen, NumTimeStrings

Str15			EQU	16				; length of string[15]
Str4			EQU 5				; length of string[4]	added for more space-efficient cache <1-8-91jh><10>
Str8			EQU 9				; length of string[8]	ditto					<34>

TimeLen			equ	4				; length of time strings
NumDays 		EQU	7				; length of various arrays
NumMonths		EQU	12
NumTimeStrings	equ	4				; number of time strings ( we now have AM, PM, 24 hour AM, 24 hour PM)

DayList 		EQU	NumDays*Str15
MonthList		EQU	NumMonths*Str15

maxExtraSeps	equ		10			; count of extra seps in cache, must be at least 1!!							<10>
	  IF maxExtraSeps<1 THEN		;												<34>
		aerror	&concat('maxExtraSeps wrong: ',&i2s(maxExtraSeps))	;				<34>
	  ENDIF							;												<34>

;========================IMPORTANT NOTE,POTENTIAL DANGER===================================
;
;	The Data structure below is actually 6 bytes longer than the size of a
;	DateCacheRecord.  Initially, I fixed it so that the Record fit within 512 bytes
;	but that change forced very large patches to String2Date and String2Time in the 
;	aurora and esprit ROMs.
;
;	Since these patches were large and required a fair amount of change to ScriptMgrROMPatch.a
;	we rethought fixing the cache so that it fit into 512 bytes and instead opted
;	for keeping the fields in identical offsets.
;
;	This is not as bad as it sounds (although it is bad, let there be no doubt about that)
;	since the last 32 bytes of a tokenBlock are reserved and at this time (7.0 and earlier)
;	are neither read from nor written to.  For that reason, the fact that the declaration
;	below is 6 bytes longer than the memory provided for it is only a forgiveable bit
;	of forgetfulness.
;
;	However, do NOT read or write any values past the itlResource field of the token block.
;	And do NOT do what inside mac and the published headers say to do which is zero out
;	the last 32 bytes of the token block.  Doing that will TRASH memory. DON'T DO IT.
;========================================================================================

Cache			RECORD	0
version			ds.w	1
CurrentDate		DS		LongDateRec
BaseDate		DS		LongDateRec

theDays 		DS.B	DayList
theMonths		DS.B	MonthList

theEveStr		DS.B	Str4			;use new string definitions to make room for altseps
theMornStr		DS.B	Str4			;
the24hrAMStr	DS.B	Str4			;
the24hrPMStr	DS.B	Str4			;
countAltSeps	DS.W	1				;number of separator tokens				<1-8-91, jh>
AltSeps			DS.W	maxExtraSeps	;contains an array of separator tokens	<1-8-91, jh>
filler			DS.B	6

theTimeSep		DS.W	1
theDateSep		DS.W	1
theDateOrder	DS.b	1
longDateOrder	ds.b	1
theAbbrLen		DS.W	1
TBlock			DS		tokenBlock
CacheSize		equ		*
theTimeStrings	equ		theEveStr
				ENDR


ptchComeFromString2Time
;ok we came from the _UpperText call in String2Time so set up the stack for a JSR to matchString
;and then JMP back
			CLR.W	-(SP)					; attempt to find a time string which matches alpha token
			MOVE.L	A2,-(SP)
		WITH	TokenRec,Cache
			MOVE.W	length+2(a3),-(SP)		; push length as integer
			MOVE.W	#2,-(SP)				; push minlen as integer				<2/23/88med>
			PEA		theTimeStrings(a4)		; array
		ENDWITH
	
			MOVE.W	#TimeLen,-(SP)
			MOVE.W	#NumTimeStrings,-(SP)
			JMPBIND	ROMMatchStringJSR		; jump to the JSR MatchString in the old String2Time

			endproc
			
		ENDIF								; FixCacheAndStr2Date

		IF useInterChar THEN				; only called in RomanNewJust.a when this conditional is true <56>

; for GetScaledFontInfo																<21>
ROMGetFontInfoPlus14H	BIND (MacPlus,$8E98),(MacSE,$13608),(MacII,$19A88),(Esprit,$20046),(Aurora,$29434)

;------------------------------------------										<5><21>
;
;  PROCEDURE GetScaledFontInfo(VAR info: FontInfo; numer, denom: Point);
;
;  Just modifies the beginning of GetFontInfo, then jumps into ROM for
;  the rest.
;
		proc
		export	GetScaledFontInfo

NUMER			EQU 	-4					;POINT
DENOM			EQU 	NUMER-4 			;POINT
VARSIZE 		EQU 	DENOM				;TOTAL LOCALS

GetScaledFontInfo
		move.l	(sp)+,a0					; pop return address
		move.l	(sp)+,d1					; pop denom
		move.l	(sp)+,d0					; pop numer
		move.l	a0,-(sp)					; restore return address
		
; Now we are set up like GetFontInfo call, but scaling params are in d0 and d1.
		
		LINK	A6,#VARSIZE 				;ALLOCATE LOCALS
		MOVE.L	d0,NUMER(A6)				;set numer to scaling value
		MOVE.L	d1,DENOM(A6)				;set denom to scaling value
	
		JMPBIND	ROMGetFontInfoPlus14H		; jump into ROM

		endproc

	ENDIF									; useInterChar				<56>

; =============================================================================
; END RESIDENT CODE
; =============================================================================

CutBackPt	Proc		Export

;			EntryTable	YourTrap,YourTrapID
			EntryTable	0					; <=== Last table entry

			EndProc

; =============================================================================
; BEGIN INSTALL CODE
; =============================================================================

SMgrInstallExt Proc		Export				; init routine
			Import		CutBackPt
			Import		CodeEntry
			With		SMgrRecord
			
; begin init code
; -----------------------------------------------------------------------------
; The FixRomAddresses macro has to be located after the last bind macro in the
; code, but has to be executed before any of them. So we put it at the end and
; BSR to it.

	IF (FixCacheAndStr2Date OR useInterChar) THEN	; <56>

			bsr			DoFixRomAddresses	; there are only ROM binds if one of the above is true
			
	ENDIF									; <56>
			movem.l		d3/a2-a4,-(sp)
			GetSMgrCore	a4					; get pointer to SMgrRecord
; -----------------------------------------------------------------------------
; update ScriptUtil dispatch table
;

smLowCall32 equ	smLowCall++$FFFF0000		; make longint; assumes smLowCall<0

			move.l		smgrDispTable(a4),a3 ; get pointer to DispTable
			move.w		smgrDispLow(a4),d1	; get old low limit
			cmp.w		#smLowCall,d1		; how low does table go?
			ble.s		@tableSizeOk		; if low enough, skip resizing

; need to allocate bigger table, copy old contents
			
			moveq		#0,d0				; for longizing
			move.w		smgrDispHigh(a4),d0	; get current high limit
			add.w		d0,d0				; make long offset
			move.l		d0,d2				; save for later
			sub.w		#2*(smLowCall32-2),d0 ; subtract new low offset (negative)
			_NewPtr		sys,clear			; now a0 points to new space
			bne			ErrExit				; if error, bail
			lea			-2*smLowCall32(a0),a2 ; ptr to new entry for selector=0
			add.w		d1,d1				; old low offset
			lea			0(a3,d1.w),a0		; pointer to start of old table vectors
			move.l		a0,a3				; save for _DisposPtr
			lea			0(a2,d1.w),a1		; pointer to same place in new table
			move.l		d2,d0				; high offset; already longized!
			sub.w		d1,d0				; subtract low offset
			addq		#4,d0				; need 1 long more than difference
			_BlockMove						; move old vectors to new place
			bne			ErrExit				; if error, bail
			move.l		a3,a0				; pointer to start of old space
			_DisposPtr						; dispose of it; don't care if we fail
			move.l		a2,a3				; new DispTable pointer in a3
			move.l		a3,smgrDispTable(a4) ; new DispTable pointer in globals
			move.w		#smLowCall,smgrDispLow(a4) ; new low limit in globals
@tableSizeOk

; now fill in real addresses for new routines.

			lea			NewUtilTable,a1
			lea			CodeEntry,a2
@fillLoop
			move.l		(a1)+,d0			; routine offset in low word
			beq.s		@doneFill			; if terminator, quit
			lea			0(a2,d0.w),a0		; get routine address
			swap		d0					; get selector from high word
			add.w		d0,d0				; make long offset
			move.l		a0,0(a3,d0.w)		; put in dispatch table
			bra.s		@fillLoop
@doneFill

; -----------------------------------------------------------------------------
; update RomanUtil dispatch table												<2>

			move.l		smgrEntry+(smRoman*4)(a4),d0	; Roman ScriptRecord ptr
			beq.s		@romanDoneFill					; if 0, no disp table!
			move.l		d0,a4							; copy pointer

			with		ScriptRecord
			move.l		scriptDispTable(a4),a3		; get pointer to DispTable

			move.w		scriptDispHigh(a4),d1		; get old high limit
			cmp.w		#sisHighCall,d1				; how high does table go?
			bge.s		@romanTableSizeOk			; if high enough, skip resizing

; need to allocate bigger table, copy old contents
			
			moveq		#0,d0						; for longizing
			move.w		#sisHighCall+2,d0			; get desired high limit (>0)
			sub.w		scriptDispLow(a4),d0		; subtract current low limit (>0)
			add.w		d0,d0						; size for longs, not words
			_NewPtr		sys,clear					; now a0 points to new space
			bne			ErrExit						; if error, bail
			move.l		a0,a2						; save new pointer
			move.l		a3,a0						; beginning of old table
			move.l		a2,a1						; beginning of new table
			moveq		#0,d0						; for longizing
			move.w		scriptDispHigh(a4),d0		; get old high limit
			sub.w		scriptDispLow(a4),d0		; subtract old low limit
			addq.w		#2,d0
			add.w		d0,d0						; now we have size of old table
			_BlockMove								; move old vectors to new place
			bne			ErrExit						; if error, bail
			move.l		a3,a0						; pointer to start of old space
			_DisposPtr								; dispose of it; don't care if we fail
			move.l		a2,a3						; new DispTable pointer in a3
			move.l		a3,scriptDispTable(a4)		; new DispTable pointer in globals
			move.w		#sisHighCall,scriptDispHigh(a4)	; new low limit in globals
@romanTableSizeOk

; now fill in real addresses for new routines.
; assumes new scriptDispTable pointer in a3, ScriptRecord pointer in a4

			lea			NewRomanTable,a1
			lea			CodeEntry,a2
@romanFillLoop
			move.l		(a1)+,d0				; get routine offset in low word
			beq.s		@romanDoneFill			; if terminator, quit
			movea.l		#0,a0					; assume 0 entry in dispatch table		<49>
			tst.w		d0						; is this what we want?					<49>
			beq.s		@gotAddress				; if so, leave it as 0					<49>
			lea			0(a2,d0.w),a0			; otherwise get real routine address
@gotAddress										;										<49>
			swap		d0						; get selector from high word
			sub.w		scriptDispLow(a4),d0	; make word offset in table
			add.w		d0,d0					; make long offset
			move.l		a0,0(a3,d0.w)			; put in dispatch table
			bra.s		@romanFillLoop
			endwith
@romanDoneFill

; -----------------------------------------------------------------------------
; install ScriptUtil patch <1.2>		remove conditionals		<37>

			InstToolTp		xScriptUtil,$0B5

; -----------------------------------------------------------------------------
; update version number <1.3>
;
; The GetSMgrCore below was commented out; uncomment it because we blew a4 away
; with the RomanUtil dispatch table update in <2> above. <4>

			GetSMgrCore	a4							; get pointer to SMgrRecord
			move.w		#smgrVersPriv,smgrVersion(a4)	;						<18>

; -----------------------------------------------------------------------------	<45>
; Install new PrintAction routine

;;			GetSMgrCore	a4					; get pointer to SMgrRecord
			import	PrintAction				;									<56>
			lea		PrintAction,a0
			move.l	a0,smgrPrint(a4)

; -----------------------------------------------------------------------------
; Inactivate sVectFixSMgrWorld vector.											<14><25>
;
; We want to inactivate the old sVectFixSMgrWorld vector by stuffing the
; address of an rts. This ensures that any calls from the ROM InitWindows
; or InitResources to FixSMgrWorld will be harmless.

;;			GetSMgrCore	a4					; get pointer to SMgrRecord
			import	KillOldFixWorldVec		;									<56>
			lea		KillOldFixWorldVec,a0
			move.l	a0,sVectFixSMgrWorld(a4)

; -----------------------------------------------------------------------------
; Initialize new emNumer and emDenom fields in ExpandMem						<21>
; Also initialize emScriptAppGlobals field.										<23><27>
;
			with	ExpandMemRec
			move.l	ExpandMem,a0
			move.l	#$00010001,d0
			move.l	d0,emNumer(a0)
			move.l	d0,emDenom(a0)
			move.l	#-1,emScriptAppGlobals(a0)			;						<23><27>
			endwith	;ExpandMemRec

; -----------------------------------------------------------------------------
; update Roman version no.	<1.4><11>
;
; moved initialization of Roman font and style info from here to InitScripts	<26>
;

			with		ScriptRecord
;;			GetSMgrCore	a4								; get pointer to SMgrRecord
			move.l		smgrEntry+(smRoman*4)(a4),a2	; Roman ScriptRecord pointer
			
			move.w		#romanVersPriv,scriptVersion(a2)	; set version no. <1.4>
			endwith		;ScriptRecord

; -----------------------------------------------------------------------------
; Install Script Manager's Gestalt selectors.								<1.4>

			import	gestaltScriptMgr,gestaltSMgrTable

			lea		gestaltSMgrTable,a2		; table of Gestalt selectors
											;   and GetEnvirons verbs
@loopInstallGestalt
			move.l	(a2)+,d0				; get next Gestalt selector
			beq.s	@doneInstallGestalt		; 0 means we're done
			addq.l	#2,a2					; skip GetEnvirons verb
			lea		gestaltScriptMgr,a0		; push gestaltFunction ProcPtr
			_NewGestalt
											; ignore OSErr in d0 (what can
											;   we do if it is not noErr?)
			bra.s	@loopInstallGestalt
@doneInstallGestalt

; -----------------------------------------------------------------------------
; install LwrString patch for 2-byte chars										<1.8>
	
		IF FixCacheAndStr2Date THEN			;											<34><35>
			PatchOSJump	oldLwrString2,$56	; for our _LwrString come from patch in
											;	String2Date (aurora, esprit only)
			InstOSTp	ptchLwrString,$56	; …and then install patch
		ELSE								;											<56>
			InstOSTp	NewLwrString,$56	; in ScriptMgrExtensions.a					<56>
		ENDIF

; -----------------------------------------------------------------------------
; Allocate handle to ClientLLRecord and put handle in SMgrRecord.				<33>

	IF useInterChar THEN					; <33><37>
	
			with	ClientLLRecord
			move.l	IntlSpec,a1
			move.l	#cllRecSize,d0
			_NewHandle
			bne.s	@doneAllocClientLLRec
			move.l	a0,smgrClientLLRecHndl(a1)
			endwith	;ClientLLRecord
@doneAllocClientLLRec

	ENDIF									; <33>

; -----------------------------------------------------------------------------
; Perform auto-initialization of script	systems based on info in their itlb		<8>

; Skip if Opt-E or Shift															<37><51>
		btst	#0,KeyMap+7		; shift key down?									<51>
		bne		DoneAutoInit	; if yes, skip script install						<51>
		btst	#2,KeyMap+7		; option key down?									<37>
		beq.s	@noSkipInstall	; no, skip check.									<37>
		subq	#2,sp			; make room for Boolean result						<37>
		move.w	#'e',-(sp)		; push 'e' as the char to test for					<37>

		import	iTestLetter		;													<56>
		bsr		iTestLetter		; returns TRUE if key with Roman 'e' being pressed	<37>44>

		tst.b	(sp)+			; what was the result?								<37>
		bne		DoneAutoInit	; if Opt-e, skip script install						<37>
@noSkipInstall					;													<37>

; no Opt-E, go ahead
		with	scriptRecord,itlbRecord,ItlbExtRecord
		GetSMgrCore	a4							; reset a4 to point to SMgrRecord
		move.w	#smgrCount-1,d3					; for all entries.
			
@SimpleLoopStart
		move.w	d3,d0							; copy index.
		lsl.w	#2,d0							; long word offset.
		move.l	smgrEntry(a4,d0.w),d0			; script installed?
		bne		@NextSimple						; yes -> try next entry.
		
		subq.l	#4,sp							; make room for handle.
		move.l	#'itlb',-(sp)					; push bundle type.
		move.w	d3,-(sp)						; push bundle number.
		_GetResource							; load the resource.
		move.l	(sp)+,d0						; handle = nil?
		beq		@NextSimple						; yes -> try next entry.

; we have a prospective itlb, so check if the simple bit is on
		move.l	d0,a3							; load bundle handle.
		move.l	(a3),a0							; load bundle pointer.
		btst.b	#smsfAutoInit,itlbFlags+1(a0)	; auto-init it? (+1 for mem test)
		beq		@ReleaseSimple					; no, try next one

; we have a simple script, so allocate the record, load the font numbers

		move.l	itlbLocalSize(a0),d0			; requested size for script locals
		cmp.l	#scriptSize,d0					; must be ≥ ScriptRecord size
		bcc.s	@doneFixLocalRecordSize			; if it already is, skip fix
		move.l	#scriptSize,d0					; if too small, fix it
@doneFixLocalRecordSize
		_NewPtr	sys,clear						; allocate script local data
		bne		ErrExit							; if error, bail
		move.l	a0,a2							; save entry pointer.
		move.w	d3,d0							; get script number
		asl.w	#2,d0							; *4 for long array
		move.l	a2,smgrEntry(a4,d0.w)			; store in SMgr globals.
	
; Use SimpleTable to initialize scriptVersion, scriptCreator, scriptFile instead		<13>
; of explicitly initializing them here.

; Copy font information from itlb, and check it.
; For 7.0, this is moved to InitScripts.												<26>

; copy relevant entries from Roman ScriptRecord to simple ScriptRecord
; a2=simple ScriptRecord

		move.l	smgrEntry+(smRoman*4)(a4),a0	; address of roman globals
		lea		SimpleTable,a1					; load table pointer.
@SimpleEntryLoop	
		move.w	(a1)+,d0						; get offset (and trap code).
		blt.s	@ReleaseSimple					; last entry is -1.						<14><**>
		move.w	0(a0,d0.w),0(a2,d0.w)			; copy Roman word to simple scriptRecord
		bra.s	@SimpleEntryLoop				; do the next routine.

@ReleaseSimple
; Don't bother releasing anymore														<26>
		
@NextSimple		
		subq	#1,d3							; don't do Roman
		bgt.s	@SimpleLoopStart				; keep going until 0 or less
		bra		DoneAutoInit					; clean exit							<37>
		endWith									;

; -----------------------------------------------------------------------------
; Table of ScriptRecord fields to copy from Roman when auto-initializing
; a script.
;
; Moved initialization of scriptVersion, scriptCreator, scriptFile here instead	<13>
; of explicitly initializing them above.
;
; Changed terminator to be -1, cause one of the fields we want to initialize	<14><**>
; with this table has an offset of 0.
; -----------------------------------------------------------------------------

SimpleTable
			with	ScriptRecord
			dc.w	scriptVersion				;								<13>
			dc.w	scriptCreator				;								<13>
			dc.w	scriptCreator+2				; (long)						<13>
			dc.w	scriptFile					;								<13>
			dc.w	scriptFile+2				; (long)						<13>
			dc.w	scriptDispTable
			dc.w	scriptDispTable+2			; (long)
			dc.w	scriptDispLow
			dc.w	scriptDispHigh
			dc.w	scriptPrint
			dc.w	scriptPrint+2				; (long)
			dc.w	scriptTrap
			dc.w	scriptTrap+2				; (long)
			dc.w	scriptName
			dc.w	scriptName+2				; (long)
			dc.w	$ffff						; now -1 is terminator			<14><**>
			endwith

DoneAutoInit
	
;____________________________________________________________________________	<14>
;	Installing head patch to SystemMenu to handle Keyboard Menu.

			import	ptchSystemMenu

			move.w	#$1B5,d0					; SystemMenu trap number
			_GetTrapAddress						; returns in a0
			move.l	IntlSpec,a1
			move.l	a0,sVectOldSystemMenu(a1)
			InstToolTp	ptchSystemMenu,$1B5

;------------------------------------------------------------------------------
;
			bsr			InitDictionaryMgr

; -----------------------------------------------------------------------------
; end init code

Exit
			movem.l		(sp)+,d3/a2-a4
			lea			CutBackPt,a0		; <=== Keep these two lines…
			Rts								; <=== in any case
ErrExit			
			move.w		#dsSysErr,d0		; load generic error
			_SysError						; system error!
			bra.s		Exit


;=======================================================================
;
;	InitDictionaryMgr
;		Called to load the 'dimg' file which contains the 
;		Dictionary Manager code.  We load the resources stick
;		them into expand mem, and call it a day.
;		JH, 10-9-91
;========================================================================

InitDictionaryMgr
			with	ExpandMemRec
			clr.l	-(sp)								;room for our handle
			move.l	#'dimg',-(sp)						;looking for a 'dimg' resource
			move.w	#-16385,-(sp)						;with an id of -16385
			move.w	#MapFalse,RomMapInsert				;don't load it
			_GetResource								;see if we can get it
			move.l	ExpandMem,a0						;ptr to expandmem rec into a0
			move.l	(sp)+,emDictionaryMgrPackHandle(a0)	;move the handle into our expandmem handle
	;		move.w	#0,emDictionaryMgrUseCount(a0)		;0 our count
			rts
			endwith	;ExpandMemRec

; -----------------------------------------------------------------------------
; *** We need a better way to handle the conditionals here. The table here needs	<14>
; *** to be sized depending on the min and max codes for a given set of
; *** conditionals, and the installation code needs to fill in BitBucket for any
; *** holes. This won't work correctly if any of the conditionals below happen
; *** not to be equal to (smgrSysVers >= $700).

NewUtilTable

			import	FontScript								;	<17>
			dc.w	smFontScript,FontScript-CodeEntry		;	<17>
			import	IntlScript								;	<17>
			dc.w	smIntlScript,IntlScript-CodeEntry		;	<17>
			import	Font2Script								;	<17>
			dc.w	smFont2Script,Font2Script-CodeEntry		;	<17>

			import	RealScript									;	<38>
			dc.w	smRealScript,RealScript-CodeEntry			;	<38>
			import	Font2RealScript								;	<38>
			dc.w	smFont2RealScript,Font2RealScript-CodeEntry	;	<38>
			import	SCLwrString									;	<38>
			dc.w	smSCLwrString,SCLwrString-CodeEntry			;	<38>
			import	xTestLetter									;	<44>
			dc.w	smTestLetter,xTestLetter-CodeEntry			;	<44>
			import	ScriptToRange								;	<60>
			dc.w	smScriptToRange,ScriptToRange-CodeEntry		;	<60>
			import	NFindScriptRun								;	<61>
			dc.w	smNFindScriptRun,NFindScriptRun-CodeEntry	;	<61>

			import	StyledLineBreak							;	<62>
			dc.w	-2,StyledLineBreak-CodeEntry			;	<62>

			import	GetEnvirons								;	<1.4><12>
			dc.w	smGetEnvirons,GetEnvirons-CodeEntry		;	<1.4><12>
			import	SetEnvirons								;	<1.4><12>
			dc.w	smSetEnvirons,SetEnvirons-CodeEntry		;	<1.4><12>
			import	GetScript								;	<1.4><12>
			dc.w	smGetScript,GetScript-CodeEntry			;	<1.4><12>
			import	SetScript								;	<1.4><12>
			dc.w	smSetScript,SetScript-CodeEntry			;	<1.4><12>
			import	KeyScript								;	<1.5><12>
			dc.w	smKybdScript,KeyScript-CodeEntry		;	<1.5><12>

			import	xNFindWord								;	<1.3>
			dc.w	smNFindWord,xNFindWord-CodeEntry		;	<1.3>
			import	TruncString								;	<1.3><12>
			dc.w	smTruncString,TruncString-CodeEntry		;	<1.3><12>
			import	TruncText								;	<1.3><12>
			dc.w	smTruncText,TruncText-CodeEntry			;	<1.3><12>
			import	ReplaceText								;	<1.3><12>
			dc.w	smReplaceText,ReplaceText-CodeEntry		;	<1.3><12>
			import	InitScripts								;	<14>
			dc.w	smInitScripts,InitScripts-CodeEntry		;	<14>
			import	AddScriptFonts								;	<16>
			dc.w	smAddScriptFonts,AddScriptFonts-CodeEntry	;	<16>
			import	IsCmdChar									;	<24>
			dc.w	smIsCmdChar,IsCmdChar-CodeEntry				;	<24>
			import	InitScriptApp									;	<27>
			dc.w	smInitScriptApp,InitScriptApp-CodeEntry			;	<27>
			import	CleanupScriptApp								;	<27>
			dc.w	smCleanupScriptApp,CleanupScriptApp-CodeEntry	;	<27>
			import	ReInitScripts									;	<32>
			dc.w	smReInitScripts,ReInitScripts-CodeEntry			;	<32>
			import	FindCharInSet									;	<33>
			dc.w	smFindCharInSet,FindCharInSet-CodeEntry			;	<33>

			import	InitKeybdMenu									;	<14>
			dc.w	smInitKeybdMenu,InitKeybdMenu-CodeEntry			;	<14>
			import	SetKbdMenuInfo									;	<19>
			dc.w	smSetKbdMenuInfo,SetKbdMenuInfo-CodeEntry		;	<19>
			import	RebuildKeybdMenu								;	<22>
			dc.w	smRebuildKeybdMenu,RebuildKeybdMenu-CodeEntry	;	<22>

			dc.l	0										; terminator
			
NewRomanTable

			import	Char2Pixel								;	<5>
			dc.w	smChar2Pixel,Char2Pixel-CodeEntry		;	<5>
			import	Pixel2Char								;	<2>
			dc.w	smPixel2Char,Pixel2Char-CodeEntry		;	<2>
			import	DrawJust								;	<5>
			dc.w	smDrawJust,DrawJust-CodeEntry			;	<5>
			import	MeasureJust								;	<5>
			dc.w	smMeasureJust,MeasureJust-CodeEntry		;	<5>
			import	PortionText								;	<2>
			dc.w	smPortionText,PortionText-CodeEntry		;	<2>

;;			import	BitBucket								;	<30>
;;			dc.w	smIsSpecialFont,BitBucket-CodeEntry		;	<30>
;;			dc.w	smRawPrinterValues,BitBucket-CodeEntry	;	<30>
			dc.w	smIsSpecialFont,0						;	<49>
			dc.w	smRawPrinterValues,0					;	<49>

			import	NChar2Pixel								;	<2>
			dc.w	smNChar2Pixel,NChar2Pixel-CodeEntry		;	<2>
			import	NPixel2Char								;	<2>
			dc.w	smNPixel2Char,NPixel2Char-CodeEntry		;	<2>
			import	NDrawJust								;	<2>
			dc.w	smNDrawJust,NDrawJust-CodeEntry			;	<2>
			import	NMeasureJust							;	<2>
			dc.w	smNMeasureJust,NMeasureJust-CodeEntry	;	<2>
			import	NPortionText							;	<2>
			dc.w	smNPortionText,NPortionText-CodeEntry	;	<2>

			import	FindScriptRun							;	<8>
			dc.w	smFindScriptRun,FindScriptRun-CodeEntry	;	<8>

			import	ParseTable								;	<18>
			dc.w	smParseTable,ParseTable-CodeEntry		;	<18>

			import	RomanGetScript, RomanSetScript			;	<50>
			dc.w	smGetScript,RomanGetScript-CodeEntry	;	<50>
			dc.w	smSetScript,RomanSetScript-CodeEntry	;	<50>

			import	CharType								;	<54>
			dc.w	smCharType,CharType-CodeEntry			;	<54>

			dc.l	0
			
			EndWith

	IF (FixCacheAndStr2Date OR useInterChar) THEN			; <56> only needed if one of these is true

DoFixRomAddresses				;								<21>
			FixRomAddresses		; new macro						<21>
			rts					;								<21>

	ENDIF													; <56>

			EndProc

			END



