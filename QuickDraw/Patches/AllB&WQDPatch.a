;
;	File:		AllB&WQDPatch.a
;
;	Contains:	This linked patch gets loaded on all B&W machines.
;
;	Written by:	Konstanin Othmer
;
;	Copyright:	© 1990-1991 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;		<35>	  6/4/92	KON		For CubeE - Fix OpenCPicture on Classic machines (bug #1028642).
;									Look at the picSize rather than the picIndex for aligning for
;									PICT2. This was causing problems when the stdPutpic bottleneck
;									proc is replaced by a 3rd party. These bottnecks must update
;									picsize but don't update picIndex.
;		<34>	  2/3/92	KON		Fix problem with GetForeColor trashing memory on classicQD
;									machines.
;		<33>	 8/30/91	DTY		Define onMac to keep GrafTypes.m.a happy.  (It’s not a feature
;									in BBSStartup any more which is why it’s defined here.)  Also
;									define hasCQD to be false.  (This is a patchfile for black and
;									white machines, after all…)
;		<32>	 8/23/91	JSM		Remove benign redefinition of TRUE and FALSE, which are now
;									defined by the build script.
;		<31>	 7/10/91	JSM		Remove obsolete SysVers conditionals, remove code that is never
;									compiled.
;		<30>	 3/26/91	KON		csd, WRKSHT#RBN-QD-017: Plus patch to stdRgn calls putpicOp
;									which puts out a word if it's an OpenCPicture. The high part of
;									D0 is garbage, so this causes problems. With this change
;									putPicByte is called instead.
;		<29>	 3/20/91	KON		gbm, WRKSHT#SAH-QD-057: Rectangle size in picture header in
;									OpenCPicture was not calculated correctly.
;		<28>	 3/13/91	JT		Added the glyph state opcode support to picture drawing drawing
;									under old QuickDraw. This opcode records the state of the Font
;									Manager and TrueType so text will be drawn the same on picture
;									playback as it was during picture recording. Code checked by KON
;									and BAL. BRC numbers 82651 and 79185. Worksheet number KON-022.
;		<27>	 2/28/91	KON		csd: BRC# 83982 Patch StdRgn to patch PutRgn to handle
;									rectangular regions correctly. This was causing the Finder to
;									crash on the Plus.
;		<26>	 2/12/91	KON		SMC: BRC# unknown: Close picture opcode ($FF) is not padded to
;									even boundary when creating version 2 pictures on B&W machines.
;		<25>	  2/4/91	KON		smc: BRC# 81599: Fix calcmask and seedfill so it always scans
;									both up and down.
;		<24>	  2/1/91	KON		smc: BRC# 81818, Fix round ovals saved in PICT2 for SE, Plus,
;									Portable.
;		<23>	 1/25/91	KON		DDG: BRC# 81516, When saving to a picture, StdBits assumes that
;									the result will pack into 256 bytes or less. This is not a valid
;									assumption, and for large BitMaps can cause the stack to
;									overflow.
;		<22>	 1/16/91	KON		Comefrom patch on FixRatio to fix problem with drawing arcs.
;									[smc]
;		<21>	12/14/90	csd		& gbm: Change the jShowCursor patch to call the old version
;									instead of jumping into ROM. This allows people who patch
;									jShowCursor, like the Outbound, to work.
;		<20>	11/25/90	gbm		(with sab) Fix ROMBind addresses for PutPicLong and PutPicByte
;									on Portable
;		<19>	11/15/90	JSM		<bbm> Move _OpenCPort patch from <5> to QuickDrawPatches.a,
;									since it isn't installed on any B&W machines.
;		<18>	 11/8/90	KON		Stretch chokes when horizonally scaling bitmaps with rowbytes >=
;									$100. The problem is ratiocase assumes reg. D0 is cleared
;									(except the low byte) which it ain't. [CEL]
;		<17>	 9/23/90	KON		Patch stdbits and stdpoly on portable so Pict2 creation via
;									OpenCpicture works right.
;		<16>	 9/21/90	KON		Move StdBits patch from PatchSEROM.a, PatchPortableROM.a, and
;									PatchPlusROM.a to this file and make it a linked patch.  Added
;									openCpicture stuff for stdbits and stdpoly.
;		<15>	 9/14/90	KON		Added QDError, RGBForeColor, RGBBackColor, GetForeColor,
;									GetBackColor calls to classic machines.
;		<14>	 8/24/90	PKE		(per JT) Use new names picQdChExtra and picQdRunSlop instead of
;									picSMgrChar and picSMgrSlop.
;		<13>	 8/16/90	dba		use VisRgnChanged on II and IIci as well
;		<12>	 8/15/90	dba		improve the implementation of VisRgnChanged
;		<11>	 8/10/90	gbm		fix reference to JStdPutPic on the Plus
;		<10>	 7/16/90	dba		fix ROM binds ROMStdLineRtn, ROMStdLineNotPic, and
;									ROMShowCrsrEntry1 which were all wrong on the Plus
;		 <9>	 6/27/90	KON		Always clear the script manager state variables in the picture
;									save record.
;		 <8>	 6/27/90	KON		Always clear the script manager state information in a picture
;									save record.
;		 <7>	 6/26/90	KON		Fix show cursor so obscure, hide, show leaves cursor obscured.
;		 <6>	 6/20/90	KON		Add OpenCPicture call.
;		 <5>	 5/30/90	JT		Linked patches for OpenPort, OpenCPort, InitPort, SetPort, Line,
;									LineTo, Move, and MoveTo all reset the horizontal pen fraction
;									and fall into the original code.
;		 <4>	 5/27/90	JT		Clear the line layout variables in the picture state record.
;		 <3>	  5/3/90	JT		Set the SCRIPT_CHAR_EXTRA flag according to the system-wide
;									version number and include the Script Manager equates so the
;									various patch files will compile.
;		 <2>	  4/4/90	KON		Make it into a linked patch.
;				 3/26/90	KON		Created file, it's ptch 44.
;


INITFILE		EQU		0		;set to 1 for standalone install, 0 for ptchInstall
withFonts		EQU		1		;set to 1 to build with font name/ID binding
wholeErrors   	EQU 	1

	IF (&TYPE('SCRIPT_CHAR_EXTRA') = 'UNDEFINED') THEN		; <5> CEL
		IF forROM THEN
SCRIPT_CHAR_EXTRA		EQU		0
		ELSE
SCRIPT_CHAR_EXTRA		EQU		1
		ENDIF
	ENDIF

	IF (&TYPE('hasPenFraction') = 'UNDEFINED') THEN
		IF forROM THEN
hasPenFraction	EQU		0
		ELSE
hasPenFraction	EQU		1
		ENDIF
	ENDIF

	IF (&TYPE('hasGlyphState') = 'UNDEFINED') THEN
		IF forROM THEN
hasGlyphState			EQU		0
		ELSE
hasGlyphState			EQU		1
		ENDIF
	ENDIF

	if (&type('onMac') = 'UNDEFINED') then
		if forROM then
			onMac:		equ		0
		else
			onMac:		equ		1					; Define as true for non-ROM because this is the way it used to be in
		endif										; the System featurelist in BBSStartup.
	endif
	
	if (&type('hasCQD') = 'UNDEFINED') then
		hasCQD:		equ		0
	endif
	
		INCLUDE	'SysErr.a'
		INCLUDE 'Traps.a'
		INCLUDE	'QuickEqu.a'
		INCLUDE	'SysEqu.a'
		INCLUDE	'GrafTypes.m.a'
		INCLUDE	'LinkedPatchMacros.a'
		INCLUDE	'FixMath.a'
		INCLUDE 'ToolEqu.a'
		INCLUDE 'fontPrivate.a'

; Here's a couple of vectors used in a patch below
;
PStdPutPic_SE_Portable		EQU		$0E00+(4*$F0)
PStdPutPic_Plus				EQU		$0C00+(4*$F0)

;NOTE: $400000 is stripped from the actual rom address on SE and Plus and $900000 from Esprit
DPEntry		ROMBind	(Plus, $DAEC), (SE, $00018268), (Portable, $00025664)
GetVers		ROMBind	(Plus, $DDA2), (SE, $0001852E), (Portable, $000259C4)
;DPEntry+$FC
DPQuit		ROMBind	(Plus, $DBE8), (SE, $00018364), (Portable, $00025782)
;DPEntry+$120
DPGoHome	ROMBind	(Plus, $DC0C), (SE, $00018388), (Portable, $000257A6)
;GetVers+$24
OvalEnd		ROMBind	(Plus, $DDC6), (SE, $00018552), (Portable, $000259F0)
;GetVers+$44
XOrigin		ROMBind	(Plus, $DDE6), (SE, $00018572), (Portable, $00025A0E)
;GetVers+$C6
RomLNOK		ROMBind	(Plus, $DE68), (SE, $000185F4), (Portable, $00025B26)
;GetVers+$13C
RomTextOP	ROMBind	(Plus, $DEDE), (SE, $0001866A), (Portable, $00025B9C)
;GetVers+$180
RomRectOP	ROMBind	(Plus, $DF22), (SE, $000186AE), (Portable, $00025BEE)
;GetVers+$19A
RomRRectOP	ROMBind	(Plus, $DF3C), (SE, $000186C8), (Portable, $00025C16)
;GetVers+$1BC
RomOvalOP	ROMBind	(Plus, $DF5E), (SE, $000186EA), (Portable, $00025C46)
;GetVers+$1E0
RomArcOP	ROMBind	(Plus, $DF82), (SE, $0001870E), (Portable, $00025C78)
;GetVers+$1FA
RomPolyOP	ROMBind	(Plus, $DF9C), (SE, $00018728), (Portable, $00025CA6)
;GetVers+$22C
RomRgnOP	ROMBind	(Plus, $DFCE), (SE, $0001875A), (Portable, $00025CEA)
;GetVers+$326
RomBits		ROMBind	(Plus, $E0C8), (SE, $00018854), (Portable, $00025E58)
;GetVers+$33A
RomCommentOP	ROMBind	(Plus, $E0DC), (SE, $00018868), (Portable, $00025EEE)
;GetVers+$35E
RomLongCom	ROMBind	(Plus, $E100), (SE, $0001888C), (Portable, $00025F12)
;GetVers+$458
RomGetRect	ROMBind	(Plus, $E1FA), (SE, $00018986), (Portable, $00025FC8)
;GetVers+$4BC
RomKill1	ROMBind	(Plus, $E25E), (SE, $000189EA), (Portable, $00026052)
;GetVers+$4C4
RomAbort	ROMBind	(Plus, $E266), (SE, $000189F2), (Portable, $0002605A)
;GetVers+$4CC
RomDone		ROMBind	(Plus, $E26E), (SE, $000189FA), (Portable, $00026062)
;DPEntry+$1EC
RomXClip	ROMBind	(Plus, $DCD8), (SE, $00018454), (Portable, $000258E0)
;DPEntry+$1F8
RomXClip2	ROMBind	(Plus, $DCE4), (SE, $00018460), (Portable, $000258EC)
;DPEntry+$272
RomXPnSize	ROMBind	(Plus, $DD5E), (SE, $000184DA), (Portable, $00025974)

ROMPutPicData	ROMBind	(SE, $18A1A), (Plus, $0E28E), \
							(Portable,$263FA)	;Trap=KillPicture
							
ROMDPutPicByte	ROMBind	(SE, $18A30), (Plus, $0E2A4), \
							(Portable,$26410)	;Trap=KillPicture


ROMPutPicRgn	ROMBind	(Plus, $E32C), (SE, $00018AB8), (Portable, $00026498)
ROMCopyRgn		ROMBind	(Plus, $BDFE), (SE, $0001656E), (Portable, $00023654)
ROMEqualRgn		ROMBind	(Plus, $BFA0), (SE, $00016710), (Portable, $000237F6)


;xxx Fix Me: portable needs putPicByte address

ROMPutPicByte	ROMBind	(SE, $18A36), (Plus, $0E2AA), \
							(Portable,$26416)	;Trap=KillPicture

ROMPutPicWord	ROMBind	(SE, $18A48), (Plus, $0E2BC), \
							(Portable,$26428)	;Trap=KillPicture
							
ROMPutPicLong	ROMBind	(SE, $18A5A), (Plus, $0E2CE), \
							(Portable,$2643A)	;Trap=KillPicture

;Open Picture + $34
OpenPictptchEntry	ROMBind	(Plus, $DA20), (SE, $0001819C), (Portable, $00025598)
;Open Picture + $B2
OpenPictDone	ROMBind	(Plus, $DA9E), (SE, $0001821A), (Portable, $00025616)

;Close Picture + $E
ClosePictptchEntry	ROMBind	(Plus, $DAB6), (SE, $00018232), (Portable, $0002562e)
ClosePictptchEntryNew	ROMBind	(Plus, $DABC), (SE, $00018238), (Portable, $00025634)
;Close Picture + $36
ClosePictGoHome	ROMBind	(Plus, $DADE), (SE, $0001825A), (Portable, $00025656)

; put data to picture routines


ROMStdBitsStart2	ROMBind	(Plus, $CA06), (SE, $17182), (Portable, $24510)
ROMStdBitsOK		ROMBind	(Plus, $CA0A), (SE, $17186), (Portable, $24514)
ROMStdBitsNotPic	ROMBind	(Plus, $CA0C), (SE, $17188), (Portable, $24516)



ROMStdLineRtn		ROMBind	(Plus, $967C), (SE, $13DEC), (Portable, $20832)
ROMStdLineNotPic	ROMBind	(Plus, $96E8), (SE, $13E58), (Portable, $2089E)

ROMStdRectRtn		ROMBind	(Plus, $9E96), (SE, $14606), (Portable, $2104C)
ROMStdRectNotPic	ROMBind	(Plus, $9EA4), (SE, $14614), (Portable, $2105A)			

ROMStdRRectRtn		ROMBind	(Plus, $ACA8), (SE, $15418), (Portable, $21E5E)
ROMStdRRectNotPic	ROMBind	(Plus, $ACB6), (SE, $15426), (Portable, $21E6C)

ROMStdOvalRtn		ROMBind	(Plus, $AD64), (SE, $154D4), (Portable, $21F1A)
ROMStdOvalNotPic	ROMBind	(Plus, $AD72), (SE, $154E2), (Portable, $21F28)

ROMStdArcRtn		ROMBind	(Plus, $AF70), (SE, $156E0), (Portable, $22126)
ROMStdArcNotPic		ROMBind	(Plus, $AF8E), (SE, $156FE), (Portable, $22144)

ROMStdRgnRtn		ROMBind	(Plus, $BC0E), (SE, $1637E), (Portable, $23464)
ROMStdRgnNotPic		ROMBind	(Plus, $BC20), (SE, $16390), (Portable, $23476)

ROMStdComment		ROMBind	(Plus, $D8D0), (SE, $1804C), (Portable, $2544E)

ROMShowCrsr			ROMBind	(Plus, $1CE6), (SE, $18E18), (Portable, $267F8)

ROMStdPolyRtn		ROMBind	(Portable, $22B50)
ROMStdPolyNotPic	ROMBind	(Portable, $22B60)
PortableStdBitsNotPict	ROMBind	(Portable, $24516)
PortableStdBitsRtn		ROMBind	(Portable, $243E8)

;
; Binds for CalcMask and SeedFill
;
ROMGoHome		ROMBind	(Plus, $CE7C), (SE, $175F8), (Portable, $24986)
ROMSeedFill		ROMBind	(Plus, $CDBC), (SE, $17538), (Portable, $248C6)

;
; the following Plus and SE binds were taken from QuickPolysClassicPatch.a
; and are used by that file only
;

ROMShowCursor	ROMBIND	(SE, $12A2E), (Plus, $82F8)
ROMShieldCursor	ROMBIND	(SE, $12A34), (Plus, $82FE)
ROMMaskTab		ROMBIND	(SE, $12B6E), (Plus, $8438)
ROMPatExpand	ROMBIND	(SE, $12BCE), (Plus, $8498)
ROMColorMap		ROMBIND	(SE, $12C96), (Plus, $8560)
ROMXorSlab		ROMBIND	(SE, $12D78), (Plus, $8642)
ROMDrawSlab		ROMBIND	(SE, $12DBC), (Plus, $8686)
ROMSlabMode		ROMBIND	(SE, $12E4C), (Plus, $8716)
ROMFastSlabMode	ROMBIND	(SE, $12EA6), (Plus, $8770)
ROMPushVerb		ROMBIND	(SE, $14650), (Plus, $9EE0)
ROMRSect		ROMBIND	(SE, $14880), (Plus, $A110)
ROMSeekMask		ROMBIND	(SE, $15DC4), (Plus, $B654)
ROMFrPoly		ROMBIND	(SE, $162D0), (Plus, $BB60)
ROMTrimRect		ROMBIND	(SE, $1692A), (Plus, $C1BA)		
ROMInitRgn		ROMBIND	(SE, $16A36), (Plus, $C2C6)
ROMDrawRect		ROMBIND	(SE, $146C8), (Plus,$9F58)
;PutPicVerb		Equ		$418AD6			;call routine in this file instead
;ROMPutPicRgn	Equ		$418AB8			;already defined

;------------------
; GetPMData trap
;
		INCLUDE		'GetPMData.a'
;
;------------------

;
; ----- Add GWorld calls.  This needs to broken off into it's own file --------
;
		include	'QDOffscreenEqu.a'
		
; put these in some romantic equate file when you are inspired

		macro
		_NewHandleCommaTemp
		import	NewHandleCommaTemp
		jsr		NewHandleCommaTemp
		endm

		macro
		rtd_a0 &params
			if &eval(&params) = 0 then
				rts
			else
				if &setting('MACHINE') <> 'MC68000' then
					rtd #&params
				else
					if &eval(&params) = 4 then
						move.l (sp)+,(sp)
						rts
					elseif &eval(&params) <= 8 then
						move.l (sp)+,a0
						addq #&params,sp
						jmp (a0)
					else
						move.l (sp)+,a0
						lea &params(sp),sp
						jmp (a0)
					endif
				endif
			endif
		endm

		INCLUDE		'ClassicGWorld.a'
;
; --------------- End of ClassicGWorld stuff -----------------
;
;=========================================================================================
;=========================================================================================
;
;	ComeFrom patch on FixRatio to see if from arc drawing 
;
;=========================================================================================
;=========================================================================================

FromDrawArc		ROMBind	(Plus, $B17E), (SE, $158EE), (Portable, $22334)

newFixRatio ComeFromPatchProc _FixRatio, FromDrawArc, (Plus,SE,Portable)
			IMPORT FromDrawArc

;------------------------------------------------
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE		EQU 	20				;TOTAL SIZE OF PARAMETERS
DSTRECT 		EQU 	PARAMSIZE+8-4			;ADDR OF RECT
HOLLOW			EQU 	DSTRECT-2			;BOOLEAN
OVALWIDTH		EQU 	HOLLOW-2			;INTEGER
OVALHEIGHT		EQU 	OVALWIDTH-2 		;INTEGER
MODE			EQU 	OVALHEIGHT-2		;INTEGER
PAT 			EQU 	MODE-4				;LONG, ADDR OF PATTERN
STARTANGLE		EQU 	PAT-2				;INTEGER
ARCANGLE		EQU 	STARTANGLE-2		;INTEGER

;------------------------------------------------------
;
;  OFFSETS IN AN OVAL STATE RECORD:
;
OVALTOP 		EQU 	0				;INTEGER
OVALBOT 		EQU 	OVALTOP+2			;INTEGER
OVALY			EQU 	OVALBOT+2			;INTEGER
RSQYSQ			EQU 	OVALY+2 			;LONGINT
SQUARE			EQU 	RSQYSQ+4			;64 BIT LONGFIX
ODDNUM			EQU 	SQUARE+8			;64 BIT LONGFIX
ODDBUMP 		EQU 	ODDNUM+8			;64 BIT LONGFIX
LEFTEDGE		EQU 	ODDBUMP+8			;32 BIT FIXED POINT
RIGHTEDGE		EQU 	LEFTEDGE+4			;32 BIT FIXED POINT
ONEHALF 		EQU 	RIGHTEDGE+4 		;32 BIT FIXED POINT
OVALSIZE		EQU 	ONEHALF+4			;SIZE OF AN OVALREC

;-------------------------------------------------
;
;  A6 OFFSETS OF LOCAL VARIABLES AFTER LINK:
;
EXPAT			EQU 	-64 			;16 LONGS
MINRECT 		EQU 	EXPAT-8 			;RECT
STATEA			EQU 	MINRECT-RGNREC			;RGN STATE RECORD
STATEB			EQU 	STATEA-RGNREC			;RGN STATE RECORD
STATEC			EQU 	STATEB-RGNREC			;RGN STATE RECORD
SAVESTK 		EQU 	STATEC-4			;LONG
RECTFLAG		EQU 	SAVESTK-2			;WORD
MASKBUF 		EQU 	RECTFLAG-4			;LONG
BUFLEFT 		EQU 	MASKBUF-2			;WORD
BUFSIZE 		EQU 	BUFLEFT-2			;WORD
MODECASE		EQU 	BUFSIZE-4			;LONG
DSTLEFT 		EQU 	MODECASE-4			;LONG
SAVEA5			EQU 	DSTLEFT-4			;LONG
PORT			EQU 	SAVEA5-4			;LONG
FASTFLAG		EQU 	PORT-2				;BYTE
EXTRARECT		EQU 	FASTFLAG-8			;RECT
INNEROVAL		EQU 	EXTRARECT-OVALSIZE		;OVAL RECORD
OUTEROVAL		EQU 	INNEROVAL-OVALSIZE		;OVAL RECORD
SKIPTOP 		EQU 	OUTEROVAL-2 		;WORD
SKIPBOT 		EQU 	SKIPTOP-2			;WORD
ARCFLAG 		EQU 	SKIPBOT-1			;BYTE FLAG
SKIPFLAG		EQU 	ARCFLAG-1			;BYTE FLAG
STOPANGLE		EQU 	SKIPFLAG-2			;INTEGER
MIDVERT 		EQU 	STOPANGLE-2 		;INTEGER
MIDHORIZ		EQU 	MIDVERT-2			;INTEGER
WIDTH			EQU 	MIDHORIZ-2			;INTEGER
HEIGHT			EQU 	WIDTH-2 			;INTEGER
SLOPE1			EQU 	HEIGHT-4			;LONG, FIXED POINT
SLOPE2			EQU 	SLOPE1-4			;LONG, FIXED POINT
LINE1			EQU 	SLOPE2-4			;LONG, FIXED POINT
LINE2			EQU 	LINE1-4 			;LONG, FIXED POINT
FLAG1			EQU 	LINE2-2 			;WORD
FLAG2			EQU 	FLAG1-2 			;WORD
OUTERLEFT		EQU 	FLAG2-2 			;WORD
OUTERRIGHT		EQU 	OUTERLEFT-2 		;WORD
INNERLEFT		EQU 	OUTERRIGHT-2			;WORD
INNERRIGHT		EQU 	INNERLEFT-2 		;WORD
PATINDEX		EQU 	INNERRIGHT-2			;WORD
VARSIZE 		EQU 	PATINDEX			;SIZE OF LOCAL VARIABLES

		
		MOVE.L	DSTRECT(A6),A0				;POINT TO DSTRECT
		MOVE	TOP(A0),A1														
		ADD 	BOTTOM(A0),A1
		MOVE.L	A1,D0
		ASR.L 	#1,D0
		MOVE	D0,MIDVERT(A6)				;MID VERT := (DSTBOT+DSTTOP)/2

		MOVE	LEFT(A0),A1
		ADD 	RIGHT(A0),A1
		MOVE.L 	A1,D0
		ASR.L 	#1,D0
		MOVE	D0,MIDHORIZ(A6) 			;MID HORIZ := (DSTLEFT+DSTRIGHT)/2

		jmpOld

			ENDPROC

;---------------- This stuff taken from PatchSEROM and PatchPlusROM ---------
;___________________________________________________________________________
; Patch PMA361	18Jan88 AWC 	StdPoly from QuickPolysClassicPatch.a
;
;					Fix File	Date		Patch#		Fix Routine(s)			Routine(s) Fixed
;AppleSystemPatch 	PatchSEROM.a	18Jan88		#PMA361 	(StdPoly) 				(StdPoly)
;
;	This patch speeds up polygons ENORMOUSLY (well, maybe just a fair bit).
;	But wait -- there's more!  You also get this non-explosive way of drawing polygons!

PatchPMA361	PROC	EXPORT
			INCLUDE	'QuickPolysClassicPatch.a'

;---------------- End of stuff taken from PatchSEROM and PatchPlusROM -------

VisRgnChanged	PROC	EXPORT				;<26MAR90 KON>
;-----------------------------------------------------------
;
;  Procedure VisRgnChanged(thePort: GrafPort);
;
; This call will be needed for video windows so the mask plane
; for touchstone can be updated.  Non-video QD simply returns.
;
		rts
		ENDPROC

StretchBits PROC  EXPORT	
		IMPORT RgnBlt,RSect,ShieldCursor,ShowCursor
		IMPORT InitRgn,SeekRgn,SetupStretch,ColorMap,XorSlab
;--------------------------------------------------------------
;
;  PROCEDURE StretchBits(srcBits,dstBits: BitMap;
;			 srcRect,dstRect: Rect;
;			 mode:		  INTEGER
;			 rgnA,rgnB,rgnC:  RgnHandle);
;
;  Transfer a rectangle of bits from srcBits to dstBits,
;  stretching or compressing according to srcRect and dstRect.
;  The transfer is clipped to the intersection of rgnA, rgnB, and rgnC.
;
;
;  Restrictions:
;
;	  transfer mode 0..7 only.
;	  if numer <> denom, then src and dst bitmaps do not overlap.
;
;
;  COPYRIGHT APPLE COMPUTER INC.
;  DESIGNED AND WRITTEN BY BILL ATKINSON
;


;----------------------------------------------------
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE		EQU 	30				;TOTAL BYTES OF PARAMETERS
SRCBITS 		EQU 	PARAMSIZE+8-4			;LONG, ADDR OF BITMAP
DSTBITS 		EQU 	SRCBITS-4			;LONG, ADDR OF BITMAP
SRCRECT 		EQU 	DSTBITS-4			;LONG, ADDR OF RECT
DSTRECT 		EQU 	SRCRECT-4			;LONG, ADDR OF RECT
MODE			EQU 	DSTRECT-2			;WORD
RGNA			EQU 	MODE-4				;RGNHANDLE
RGNB			EQU 	RGNA-4				;RGNHANDLE
RGNC			EQU 	RGNB-4				;RGNHANDLE


;-------------------------------------------------
;
;  A6 OFFSETS OF LOCAL VARIABLES AFTER LINK:
;
NUMER			EQU 	-4				;POINT
DENOM			EQU 	NUMER-4 			;POINT
VERROR			EQU 	DENOM-4 			;INTEGER
MINRECT 		EQU 	VERROR-8			;RECT
SRCBUF			EQU 	MINRECT-4			;LONG
DSTBUF			EQU 	SRCBUF-4			;LONG
SRCLONGS		EQU 	DSTBUF-2			;WORD
DSTLONGS		EQU 	SRCLONGS-2			;WORD
STATEA			EQU 	DSTLONGS-RGNREC 		;RGN STATE RECORD
STATEB			EQU 	STATEA-RGNREC			;RGN STATE RECORD
STATEC			EQU 	STATEB-RGNREC			;RGN STATE RECORD
SAVESTK 		EQU 	STATEC-4			;LONG
RECTFLAG		EQU 	SAVESTK-2			;WORD
MASKBUF 		EQU 	RECTFLAG-4			;LONG
BUFLEFT 		EQU 	MASKBUF-2			;WORD
BUFSIZE 		EQU 	BUFLEFT-2			;WORD
SRCADDR 		EQU 	BUFSIZE-4			;LONG
DSTADDR 		EQU 	SRCADDR-4			;LONG
SRCROW			EQU 	DSTADDR-4			;LONG
DSTROW			EQU 	SRCROW-4			;LONG
SRCLIMIT		EQU 	DSTROW-4			;LONG
VERT			EQU 	SRCLIMIT-2			;WORD
MODECASE		EQU 	VERT-4				;LONG
PAT 			EQU 	MODECASE-4			;LONG, ADDR OF PAT
RATIOCASE		EQU 	PAT-4				;LONG
HORIZFRACTION	EQU 	RATIOCASE-2 		;WORD
VARSIZE 		EQU 	HORIZFRACTION		;SIZE OF LOCAL VARIABLES

		LINK	A6,#VARSIZE 			;ALLOCATE LOCAL VARIABLES
		MOVEM.L D0-D7/A1-A4,-(SP)			;SAVE REGS
		MOVE.L	SP,SAVESTK(A6)				;REMEMBER STACK FOR LATER

;----------------------------------------------------------------
;
;  CALC NUMER AND DENOM BASED ON DSTRECT AND SRCRECT.
;  IF NUMER = DENOM THEN JUST CALL RGNBLT.
;
		MOVE.L	DSTRECT(A6),A0				;POINT TO DSTRECT
		MOVE	BOTTOM(A0),D0
		SUB 	TOP(A0),D0				;CALC DST HEIGHT
		SWAP	D0					;PUT IN HI WORD
		MOVE	RIGHT(A0),D0
		SUB 	LEFT(A0),D0 			;CALC DST WIDTH

		MOVE.L	SRCRECT(A6),A0				;POINT TO SRCRECT
		MOVE	BOTTOM(A0),D1
		SUB 	TOP(A0),D1				;CALC SRC HEIGHT
		SWAP	D1					;PUT IN HI WORD
		MOVE	RIGHT(A0),D1
		SUB 	LEFT(A0),D1 			;CALC SRC WIDTH
		CMP.L	D0,D1					;ARE BOTH RECTS SAME SIZE
		BNE.S	STRETCH 				;NO, CAN'T USE RGNBLT

XRGNBLT
		jmpROM	ROMXRGNBLT					;back to the ROM
;		MOVE.L	SRCBITS(A6),-(SP)			;PUSH SRCBITS
;		MOVE.L	DSTBITS(A6),-(SP)			;PUSH DSTBITS
;		MOVE.L	SRCRECT(A6),-(SP)			;PUSH SRCRECT
;		MOVE.L	DSTRECT(A6),-(SP)			;PUSH DSTRECT
;		MOVE	MODE(A6),-(SP)				;PUSH MODE
;		MOVE.L	PAT(A6),-(SP)				;PAT ONLY USED FROM BELOW
;		MOVE.L	RGNA(A6),-(SP)				;PUSH RGNA
;		MOVE.L	RGNB(A6),-(SP)				;PUSH RGNB
;		MOVE.L	RGNC(A6),-(SP)				;PUSH RGNC
;		JSR 	RGNBLT					;CALL RGNBLT
;		BRA 	GOHOME					;AND QUIT

MiniHeadPatch
		moveq	#0,d0						;								<KON 6NOV90>
MyJumpLoc	
		jmp		$40800000					;								<KON 6NOV90>

STRETCH MOVE.L	D0,NUMER(A6)				;NUMER := DST SIZE
		MOVE.L	D1,DENOM(A6)				;DENOM := SRC SIZE
		jsrROM 	ROMSetupStretch				;CALC CASEJUMP AND HORIZ FRACT	<KON 6NOV90>
		lea		MyJumpLoc+2,a1				;								<KON 6NOV90>
		move.l	a0,(a1)						;Save address of routine		<KON 6NOV90>
		lea		MiniHeadPatch,a0			;Address of my head patch		<KON 6NOV90>
		jmpROM	ROMBackToROM				;								<KON 6NOV90>
;		MOVE.L	A0,RATIOCASE(A6)			;SAVE CASE JUMP FOR LATER
;		MOVE	D0,HORIZFRACTION(A6) 		;SAVE FRACTION FOR LATER


ROMXRGNBLT		ROMBind	(Plus, $D09A), (SE, $17816), (Portable, $24BD4)
ROMSetupStretch	ROMBind	(Plus, $D52E), (SE, $17CAA), (Portable, $25068)
ROMBackToROM	ROMBind	(Plus, $D0D2), (SE, $1784E), (Portable, $24C0C)
			
		ENDPROC

NewStdGetPic FUNC	EXPORT	
;------------------------------------------------------------------
;
;  PROCEDURE StdGetPic(dataPtr: QDPtr; byteCount: INTEGER);
;					Fix File	Date			Patch#		Fix Routine(s)		Routine(s) Fixed
;AppleSystemPatch 	DrawPicturePatch.a	01Jan1904		#???		(StdGetPic) 		(StdGetPic)		
;
;

		MOVE.L	(SP)+,A0						;POP RETURN ADDR
		MOVE	(SP)+,D1						;POP BYTECOUNT
		MOVE.L	(SP)+,A1						;POP DATAPTR
		MOVE.L	A0,-(SP)						;PUSH RETURN ADDR
		MOVE.L	GRAFGLOBALS(A5),A0				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	PLAYINDEX(A0),D0				;GET PLAYINDEX
		MOVE.L	PLAYPIC(A0),A0					;GET PLAY PICHANDLE
		MOVE.L	(A0),A0 						;DE-REFERENCE IT
		ADD.L	D0,A0							;ADD PLAYINDEX
		BRA.S	START							;GO TO LOOP START
NXTBYTE MOVE.B	(A0)+,(A1)+ 					;COPY ONE BYTE
START	DBRA	D1,NXTBYTE						;LOOP FOR ALL BYTES
		RTS 									;AND RETURN


;----------------------------------


;
; procedure RGBForeColor (Color : RGBColor);
; procedure RGBBackColor (Color : RGBColor);
; procedure GetForeColor (VAR Color : RGBColor);
; procedure GetBackColor (VAR Color : RGBColor);
; <14Sept90 KON>
;
RGBForeColor PROC  	EXPORT
				EXPORT	RGBBackColor
				IMPORT	RGB2OLD
				
		MOVEQ		#FGCOLOR,D0					; get offset to index field

SHARE	MOVE.L		4(SP),A1					; point at the RGB color
		MOVE.L		GRAFGLOBALS(A5),A0			; get the QuickDraw globals pointer
		MOVE.L		THEPORT(A0),A0				; point at the port
		PEA			0(A0,D0)					; save pointer to the index field
		JSR			RGB2OLD						; else convert RGB to old color
		
DONE	MOVE.L		(SP)+,A0					; get pointer to index field
		MOVE.L		D0,(A0)						; and set the index field
		RTD_a0		4							; all done			
				
;
; procedure RGBBackColor (Color : RGBColor);
;
;	This routine takes an RGB triple and sets the current Graf- or CGrafPort
;	fields so that drawing will take place with the best match of the
;	requested color, using the current GDevice's color matching rules.  The
;	appropriate fields are set depending on portType.
;

RGBBackColor

		MOVEQ		#BKCOLOR,D0					; get offset to the index field
		BRA.S		SHARE						; => and use common code
		ENDPROC
		
;
; PROCEDURE GetForeColor (VAR Color: RGBColor);
;
; Return the RGB components of the current foreground color
; Works for old and new ports.


GetForeColor	PROC	EXPORT
				EXPORT	GetBackColor

		MOVEQ		#FGCOLOR,D0					; get offset to the index field
		MOVEQ		#RGBFgColor,D1				; get offset to RGB field

SHARE	MOVE.L		4(SP),A1					; point at the RGB color
		MOVE.L		GRAFGLOBALS(A5),A0			; get the QuickDraw globals pointer
		MOVE.L		THEPORT(A0),A0				; point at the port
; USE CMYB BITS IN COLOR TO DERIVE PROPER RGB COMPONENTS

		MOVE.L		(A0,D0),D0					; get planar color from port
		LSR			#1,D0						; CHECK FOR WHITE (I CMYB rgbw)
		BCS.S		@BLACK						; =>NOT WHITE
		OR			#$00E0,D0					; ELSE SET WHITE BITS (CMY = 111)
@BLACK	LSR			#5,D0						; SHIFT ICMY INTO LOW NIBBLE
		AND			#$7,D0						; CLEAR ALL BUT CMY
		lea			InLineQDColors,A0			; GET DEFAULT COLORS
;		LEA			2(A0,D0*8),A0				; point to proper entry
		lsl.w		#3,d0						;d0*8
		lea			2(a0,d0),a0					;point to entry

		MOVE.L		(A0)+,(A1)+					; copy red, green
		MOVE		(A0)+,(A1)+					; copy blue

;		MOVE.L		red(A0,D1),red(A1)			; copy red and green components from the port 	<34>
;		MOVE.W		blue(A0,D1),blue(A1)		; and blue too									<34>
		
DONE	MOVE.L		(SP)+,A0					; get the return address
		ADDQ		#4,SP						; get rid of the parameter
		JMP			(A0)						; and return

;
; On color machines this table resides in low memory pointed to by the QDColors global
; variable.
;
InLineQDColors
		dc.w	$0000, $0000, $0000, $0000			;0 black
		dc.w	$0001, $FC00, $F37D, $052F			;1 yellow
		dc.w	$0002, $F2D7, $0856, $84EC			;2 magenta
		dc.w	$0003, $DD6B, $08C2, $06A2			;3 red
		dc.w	$0004, $0241, $AB54, $EAFF			;4 cyan
		dc.w	$0005, $0000, $8000, $11B0			;5 green
		dc.w	$0006, $0000, $0000, $D400			;6 blue
		dc.w	$0007, $FFFF, $FFFF, $FFFF			;7 white
		
;
; PROCEDURE GetBackColor (VAR Color: RGBColor);
;
; Return the RGB components of the current background color
; Works for old and new ports.
;

GetBackColor

		MOVEQ		#BKCOLOR,D0					; get offset to the index field
		MOVEQ		#RGBBkColor,D1				; get offset to RGB field
		BRA.S		SHARE						; and use common code

		ENDPROC

QDError	PROC	EXPORT
		clr.w	4(a7)
		rts
		ENDPROC

OpenCPicture FUNC  	EXPORT
			IMPORT	HidePen,NewRgn,ClipRect,DPutPicOp,DPutPicByte,PUTPICWORD,PUTPICDATA
;------------------------------------------------------
;
;  Offsets in parameter block passed to OpenCPicture
;
ppSrcRect		EQU 	0					;Rect
ppHRes			EQU 	ppSrcRect+8			;Fixed
ppVRes			EQU 	ppHRes+4 			;Fixed
ppVersion 		EQU 	ppVRes+4 			;Word (=0)
ppReserved 		EQU 	ppVersion+2			;Word
ppReserved2		EQU 	ppReserved+2		;Long
PicParamSize	EQU 	ppReserved2+4		;size of a PICT2 header record


;------------------------------------------------------
;
;  New offsets in a PICT2 header record:
;
hdrVersion 		EQU 	0					;Word (=-2)
hdrReserved 	EQU 	hdrVersion+2		;Word
hdrHRes			EQU 	hdrReserved+2		;Fixed
hdrVRes			EQU 	hdrHRes+4 			;Fixed
hdrSrcRect		EQU 	hdrVRes+4			;Rect
hdrReserved2	EQU 	hdrSrcRect+8		;Long
picHdrSize		EQU 	hdrReserved2+4		;size of a PICT2 header record
;------------------------------------------------------------------

;
;  FUNCTION OpenCPicture(picParams: params): cPicHandle;
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	4
RESULT			EQU 	PARAMSIZE+8 			;LONG, PICHANDLE
params			EQU 	RESULT-4				;ptr to input params

SAVEVERSION		EQU 	-2						;PICTURE VERSION NUMBER
picHdrRec		EQU 	SAVEVERSION-picHdrSize	;PICT2 header record
defaultFrame	EQU		picHdrRec-8				;pic frame to be recorded in picture
VARSIZE 		EQU 	defaultFrame			;TOTAL BYTES OF LOCALS

		LINK	A6,#VARSIZE						;MAKE STACK FRAME
		MOVE	#npicVersion,SAVEVERSION(A6)	;SAVE VERSION NUMBER
		
	;copy input parameters into pict 2 header record and compute picFrame
		
		move.l	params(a6),a0					;point to input parameters
		move.l	ppSrcRect(a0),picHdrRec+hdrSrcRect(a6)
		move.l	ppSrcRect+bottom(a0),picHdrRec+hdrSrcRect+bottom(a6)
		move.l	ppHRes(a0),picHdrRec+hdrHRes(a6)
		move.l	ppVRes(a0),picHdrRec+hdrVRes(a6)
		move.w	ppVersion(a0),d0				;orginal version?
		bne.s	@newversion
		move.w	#-2,picHdrRec+hdrVersion(a6)
		clr.w	picHdrRec+hdrReserved(a6)
		clr.l	picHdrRec+hdrReserved2(a6)
		bra.s	@computePicFrame

@newversion										;fill out additional fields
		move.w	d0,picHdrRec+hdrVersion(a6)
		move.w	ppReserved(a0),picHdrRec+hdrReserved(a6)
		move.l	ppReserved2(a0),picHdrRec+hdrReserved2(a6)

@computePicFrame
		
		move.l	picHdrRec+hdrSrcRect+top(a6),d0		;get topLeft in d0
		move.l	picHdrRec+hdrSrcRect+bottom(a6),d1	;get botRight in d1
		move.l	d0,defaultFrame+top(a6)				;set default new height
		move.l	d1,defaultFrame+bottom(a6)			;set default new width
		sub.w	d0,d1								;get width in d1.w
		move.w	d1,d2								;save width in d2.w
		swap	d0
		swap	d1
		sub.w	d0,d1							;get height in d1.w
		moveq	#72,d0
		mulu.w	d0,d1							;d1.L = height*72
		move.l	d1,a0							;save height*72 in a0
		mulu.w	d0,d2							;d2.L = width*72
		
;		swap	d2								;<29>
;		moveq	#0,d1							;extend d1 to long in copy: don't trash high word <KON>
;		move.w	d2,d1							;<29>
;		clr.w	d2								;<29>
		move.l	picHdrRec+hdrHRes(a6),d0		;<29>
		beq.s	@skip							;<29>
		
		move.l	a0,-(sp)						;save d1 (which has been moved to a0
		subq	#4,sp
		move.l	d2,-(sp)						;longint/fixed = longint
		move.l	d0,-(sp)
		_FixDiv
		move.l	(sp)+,d2						;longint result, only interested in bottom word portion
;<29>	swap	d2								;get quotient (decimal part) in low word
		move.l	(sp)+,d1						;restore d1
		
;		divu.l	d0,d1:d2						;d2.w = (width*72)/vRes

   		move.l	picHdrRec+hdrVRes(a6),d0
		beq.s	@skip

		clr.l	defaultFrame+top(a6)			;force topLeft to be 0,0
		move.w	d2,defaultFrame+right(a6)		;right = new width

;		moveq	#0,d2							;<29>
;		swap	d1								;<29>
;		move.w	d1,d2							;<29>
;		clr.w	d1								;<29>

		subq	#4,sp
		move.l	d1,-(sp)						;longint/fixed = longint
		move.l	d0,-(sp)
		_FixDiv
		move.l	(sp)+,d1						;longint result, only interested in low word	<29>
;<29>	swap	d1								;get quotient (decimal part) in low word

;		divu.l	d0,d2:d1						;d1.w = (height*72)/vRes
		move.w	d1,defaultFrame+bottom(a6)		;bottom = new height
@skip		
		MOVEM.L D3/A3-A4,-(SP) 					;SAVE REGS
		CLR.L	RESULT(A6)						;INIT FCN RESULT TO NIL

;  Abort OpenPicture if heap doesn't have at least 1500 bytes.	<16Jan89 KON>

		MOVE.L	#1500,D0 						;GET BYTE COUNT
		_NewHandle								;AT LEAST 1000 BYTES IN THE HEAP ?
		BNE 	DONE							;NO, RETURN NIL AND QUIT
		_DisposHandle							;YES, Discard test handle
		
		MOVE.L	GRAFGLOBALS(A5),A4				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A4),A3					;GET CURRENT GRAFPORT
		TST.L	PICSAVE(A3) 					;ARE WE ALREADY SAVING ?
		BNE 	DONE							;YES, RETURN NIL AND QUIT
		_HidePen 								;NO, TURN OFF DRAWING
		
;  ALLOCATE PICSAVE RECORD

		MOVE.L	#picSaveRec,D0					;GET BYTE COUNT
		_NewHandle								;ALLOCATE PICSAVE RECORD
		MOVE.L	A0,A4							;GET RESULT HANDLE
		MOVE.L	A4,PICSAVE(A3)					;SAVE RESULT IN THEPORT
;
;  ALLOCATE PICCLIPRGN (leave on stack for now)
;
		CLR.L	-(SP)							;MAKE ROOM FOR FCN RESULT
		_NEWRGN									;ALLOCATE A NEW REGION
;
;  ALLOCATE THEPIC PICHANDLE
;
		MOVE.L	#256,D0 						;BYTE COUNT = 256
		_NewHandle								;ALLOCATE NEWHANDLE(256)
		MOVE.L	A0,A1							;GET THEPIC HANDLE
		MOVE.L	A1,RESULT(A6)					;PUT HANDLE IN FCN RESULT
;
;  NOW FILL THEPIC'S PICSIZE AND PICFRAME
;
		MOVE.L	(A4),A4 						;DE-REFERENCE PICSAVE HANDLE
		MOVE.L	A1,(A4)+						;SAVE PICHANDLE IN THEPIC
		MOVE.L	(A1),A1 						;DE-REFERENCE PICHANDLE
		MOVE	#10,(A1)+						;INSTALL PICSIZE = 10
		lea		defaultFrame(A6),A0 			;POINT TO PICFRAME
		MOVE.L	(A0)+,(A1)+ 					;COPY RECT INTO PICTURE
		MOVE.L	(A0)+,(A1)+
;
;  INIT STATE VARIABLES FOR PICTURE CAPTURE
;
		MOVE.L	#256,(A4)+						;PICMAX := 256;
		MOVE.L	#10,(A4)+						;PICINDEX := 10
		MOVE.L	(SP)+,(A4)+ 					;INSTALL PICCLIPRGN
		CLR.L	(A4)+							;PICBKPAT := WHITE
		CLR.L	(A4)+
		CLR.L	(A4)+							;PICTXFONT = 0, PICTXFACE = []
		MOVE	#1,(A4)+						;PICTXMODE := SRCCOPY
		CLR 	(A4)+							;PICTXSIZE := 0
		CLR.L	(A4)+							;PICSPEXTRA := 0.0
		MOVE.L	#$00010001,D0					;GET (1,1)
		MOVE.L	D0,(A4)+						;PICTXNUMER := (1,1)
		MOVE.L	D0,(A4)+						;PICTXDENOM := (1,1)
		CLR.L	(A4)+							;PICTXLOC := (0,0)
		CLR.L	(A4)+							;PICPNLOC := (0,0)
		MOVE.L	D0,(A4)+						;PICPNSIZE := (1,1)
		MOVE	#8,(A4)+						;PICPNMODE := PATCOPY
		MOVEQ	#-1,D0							;GET SOME BLACK
		MOVE.L	D0,(A4)+						;PICPNPAT := BLACK
		MOVE.L	D0,(A4)+
		MOVE.L	D0,(A4)+						;PICFILLPAT := BLACK
		MOVE.L	D0,(A4)+
		CLR.L	(A4)+							;PICTHERECT := (0,0,0,0)
		CLR.L	(A4)+
		CLR.L	(A4)+							;PICOVSIZE := (0,0)
		MOVE.L	PORTRECT+TOPLEFT(A3),(A4)+		;PICORIGIN := CURRENT ORIGIN
		MOVE.L	#blackColor,(A4)+				;PICFGCOLOR := blackColor
		MOVE.L	#whiteColor,(A4)+				;PICBKCOLOR := whiteColor
		clr.l	(a4)+							;picQdChExtra := 0
		clr.l	(a4)+							;picQdRunSlop := 0
	
;
; Allocate handle for fond id's we have seen so far
;
;		Format of picFontList handle is:
;			handle size [long]
;			# of entries - 1 used [word]
;				id1, id2, ... idn

FontListSize	equ		50*2

doFontList	
		moveq	#FontListSize+6,d0				;initial size for 50 entries
		_NewHandle
		move.l	picSave(a3),a1					;get picSave handle
		move.l	(a1),a1
		move.l	a0,picFontList(a1)				;save picFontList handle in picSave record
		beq.s	@noHandle
		
		move.l	(a0),a0							;point into fontList
		moveq	#FontListSize+6,d0				;initial size for 50 entries
		move.l	d0,(a0)+
		clr.l	(a0)							; 1 entry, first entry = 0

@noHandle

; INIT GLYPH STATE TO INVALID

		move.l	#$80808080,picGlyphState(a1)	; set glyph state to invalid values

; PUT VERSION NUMBER TO PICTURE

		move.w	#1,picVersion(a1)				;picVersion := new picture (non-zer)
		MOVEQ	#opVersion,D0					;GET VERSION OPCODE
		JSR		DPutPicOp						;PUT TO PICTURE
		MOVE	SAVEVERSION(A6),D0				;GET VERSION NUMBER
		
; For new pictures, put version as word, followed by header
		
@NotPic	MOVE	D0,-(SP)						;ELSE PUSH VERSION
		JSR 	PUTPICWORD						;AND PUT ENTIRE WORD FOR NEW PICTURES
		
; HEADER EXTENSION = [OP] [SIZE] [BBOX] [RESERVED]

		MOVE	#ngHeaderOp,D0					;GET HEADER OPCODE
		JSR		DPutPicOp						;PUT TO PICTURE
		
		pea		picHdrRec(a6)					;PUSH POINTER TO DATA
		MOVE	#24,-(SP)						;PUSH SIZE OF DATA
		JSR		PUTPICDATA						;AND BLAST IT TO THE PICTURE

DONE	MOVEM.L (SP)+,D3/A3-A4 					;RESTORE REGS
		UNLINK	PARAMSIZE,'OPENCPIC'

	
PutPicPat PROC	EXPORT	
		IMPORT PutPicData
;------------------------------------------------------
;
;  PROCEDURE PutPicPat(pat: Pattern);
;
		MOVE.L	(SP)+,A0				;POP RETURN ADDR
		MOVE	#8,-(SP)				;PUSH BYTECOUNT = 8
		MOVE.L	A0,-(SP)				;PUSH RETURN ADDR
		JMP 	PutPicData

PutPicVerb PROC  EXPORT 	
		IMPORT DPutPicByte,PutPicWord,PutPicLong,PutPicPat,DoPict2
;------------------------------------------------------
;
;  PROCEDURE PutPicVerb(verb: GrafVerb);
;
;  check additional picture params associated with
;  this verb, and add those that have changed to thePic.
;
PARAMSIZE		EQU 	2
VERB			EQU 	PARAMSIZE+8-2			;BYTE

		LINK	A6,#0					;NO LOCAL VARS
		MOVEM.L D5-D7/A3-A4,-(SP)			;SAVE REGS
		MOVE.L	GRAFGLOBALS(A5),A4			;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A4),A3				;POINT TO CURRENT PORT
		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE
		MOVE.L	(A4),A4 				;DE-REFERENCE PICSAVE
		MOVE.B	VERB(A6),D7 			;GET VERB
		CMP.B	#PAINT,D7				;CASE JUMP BASSED ON VERB
		BLT		FRAME1
		BEQ 	PAINT1					;YES CHECK PNMODE, PNPAT
		CMP.B	#INVERT,D7				;IS VERB INVERT ?
		BEQ 	DONE					;YES, NOTHING TO CHECK
		BLT.S	ERASE1

FILL1	MOVE.L	FILLPAT(A3),D5				;GET FILLPAT
		MOVE.L	FILLPAT+4(A3),D6
		CMP.L	PICFILLPAT(A4),D5			;SAME AS PICFILLPAT ?
		BNE.S	@1					;NO, PUT CHANGE TO THEPIC
		CMP.L	PICFILLPAT+4(A4),D6
		BEQ 	DONE
@1		MOVE.L	D5,PICFILLPAT(A4)			;UPDATE STATE VARIABLE
		MOVE.L	D6,PICFILLPAT+4(A4)
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$0A,D0 				;PUSH FILLPAT OPCODE
		JSR 	DPutPicByte 			;ADD TO THEPIC
		PEA 	FILLPAT(A3)
		JSR 	PutPicPat				;PUT PATTERN DATA
		BRA 	DONE					;AND QUIT

ERASE1	MOVE.L	BKPAT(A3),D5				;GET BKPAT
		MOVE.L	BKPAT+4(A3),D6
		CMP.L	PICBKPAT(A4),D5 			;SAME AS PICBKPAT ?
		BNE.S	NEWBK					;NO, PUT CHANGE TO THEPIC
		CMP.L	PICBKPAT+4(A4),D6
		BEQ 	DONE
NEWBK	MOVE.L	D5,PICBKPAT(A4) 			;UPDATE STATE VARIABLE
		MOVE.L	D6,PICBKPAT+4(A4)
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$02,D0 				;BKPAT OPCODE
		JSR 	DPutPicByte 			;ADD TO THEPIC
		PEA 	BKPAT(A3)
		JSR 	PutPicPat				;PUT PATTERN DATA
		BRA		DONE					;AND QUIT

FRAME1	MOVE.L	PNSIZE(A3),D6				;GET PNSIZE
		CMP.L	PICPNSIZE(A4),D6			;HAS IT CHANGED ?
		BEQ.S	PAINT1					;NO, CONTINUE
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$07,D0
		JSR 	DPutPicByte 			;YES, PUT PNSIZE OPCODE
		MOVE.L	D6,-(SP)
		JSR 	PutPicLong				;PUT NEW PNSIZE
		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE
		MOVE.L	(A4),A4 				;DE-REFERENCE PICSAVE
		MOVE.L	D6,PICPNSIZE(A4)			;AND UPDATE STATE VARIABLE

PAINT1	MOVE	PNMODE(A3),D6				;GET PNMODE
		CMP 	PICPNMODE(A4),D6			;HAS IT CHANGED ?
		BEQ.S	MODEOK					;NO, CONTINUE
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$08,D0
		JSR 	DPutPicByte 			;YES, PUT PNMODE OPCODE
		MOVE	D6,-(SP)
		JSR 	PutPicWord				;PUT NEW PNMODE
		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE
		MOVE.L	(A4),A4 				;DE-REFERENCE PICSAVE
		MOVE	D6,PICPNMODE(A4)			;AND UPDATE STATE VARIABLE

MODEOK	MOVE.L	PNPAT(A3),D5				;GET PNPAT
		MOVE.L	PNPAT+4(A3),D6
		CMP.L	PICPNPAT(A4),D5 			;SAME AS PICPNPAT ?
		BNE.S	@1					;NO, PUT CHANGE TO THEPIC
		CMP.L	PICPNPAT+4(A4),D6
		BEQ.S	DONE
@1		MOVE.L	D5,PICPNPAT(A4) 			;UPDATE STATE VARIABLE
		MOVE.L	D6,PICPNPAT+4(A4)
;
; Do alignment for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$09,D0 				;PNPAT OPCODE
		JSR 	DPutPicByte 			;ADD TO THEPIC
		PEA 	PNPAT(A3)
		JSR 	PutPicPat				;PUT PATTERN DATA

DONE
;
; Do alignment for new pictures: align for next opcode
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEM.L (SP)+,D5-D7/A3-A4			;RESTORE REGS
		UNLINK	PARAMSIZE,'PUTPICVERB'
		ENDP
		
PutPicData PROC  EXPORT 
			EXPORT	DPutPicByte, PutPicByte, PutPicWord, PutPicLong
			IMPORT	ROMDPutPicByte, ROMPutPicByte, ROMPutPicWord, ROMPutPicLong
			
	jmpROM		ROMPutPicData
DPutPicByte
	jmpROM		ROMDPutPicByte
PutPicWord	
	jmpROM		ROMPutPicWord
PutPicLong
	jmpROM		ROMPutPicLong
PutPicByte
	jmpROM		ROMPutPicByte
			ENDPROC
			
DPutPicOp	PROC 	EXPORT	
			EXPORT	PutPicOp,PutPicOp2
			IMPORT	PutPicData,PutPicPad
;------------------------------------------------------
;
;  PROCEDURE PutPicOp(data: word);
;
;  Put a byte if PICT; Put a word if NPIC.
;
		MOVE.L	(SP)+,A0						;POP RETURN ADDR
		MOVE	D0,-(SP)						;PUSH DATA WORD
		MOVE.L	A0,-(SP)						;PUSH RETURN ADDR
PutPicOp
		JSR		PutPicPad						;PAD TO WORD BOUNDARY
PutPicOp2
		MOVE.L	GRAFGLOBALS(A5),A0				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A0),A0					;GET CURRENT GRAFPORT
		MOVE.L	PICSAVE(A0),A0					;GET PICSAVE HANDLE
		MOVE.L	(A0),A0 						;DE-REFERENCE PICSAVE
		MOVEQ	#2,D0							;ASSUME IT'S A NEW PICTURE
		LEA		4(SP),A1						;GET ADDR OF DATA
		tst.w	PICVERSION(A0)					;IS IT AN OLD PICTURE?
		BNE.S	NEWPIC							;=>NO, TWO-BYTE OPCODES
		MOVEQ	#1,D0							;ELSE ONE-BYTE OPCODES
		ADDQ	#1,A1							;POINT TO DATA
NEWPIC	MOVE.L	A1,-(SP)						;PUSH ADDRESS OF DATA
		MOVE	D0,-(SP)						;PUSH BYTECOUNT
		JSR 	PutPicData						;CALL PutPicData
		MOVE.L	(SP)+,A0						;POP RETURN ADDR
		TST.W	(SP)+							;STRIP PARAM
		JMP 	(A0)							;AND RETURN

PutPicPad	PROC 	EXPORT	
			IMPORT	DPutPicByte
;------------------------------------------------------
;
;  PROCEDURE PutPicPad;
;
;  If picture is an NPIC and the current PicSize is odd, then put a 0 pad byte.
;
		MOVE.L	GRAFGLOBALS(A5),A0				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A0),A0					;GET CURRENT GRAFPORT
		MOVE.L	PICSAVE(A0),A0					;GET PICSAVE HANDLE
		MOVE.L	(A0),A0 						;DE-REFERENCE PICSAVE
		tst		PICVERSION(A0)					;IS IT AN OLD PICTURE?	<KON 12FEB90>
		BEQ.S	DONE							;=>YES, DON'T PAD
		MOVE.L	THEPIC(A0),A0					;GET THEPIC HANDLE
		MOVE.L	(A0),A0							;POINT AT THE PIC
		MOVE	PICSIZE(A0),D0					;GET THE LOW WORD OF THE SIZE
		BTST	#0,D0							;IS SIZE ODD?
		BEQ.S	DONE							;=>NO, JUST RETURN
		MOVEQ	#0,D0							;GET A PAD BYTE IN D0
		JSR		DPutPicByte						;PUT THE BYTE TO THE PICTURE
DONE	RTS										;AND RETURN
		ENDPROC
			
;____________________________________________________________________________________
; PB399  StdBits Patch
;
;					Fix File	Date		Patch#		Fix Routine(s)		Routine(s) Fixed
;AppleSystemPatch 	PatchPlusROM.a	21Feb88		PMAB399		StdBits 			StdBits
;
; An earlier patch fixed PackBits to work with scanlines longer than 127 bytes.  Unfortunately,
;	when pict recording, StdBits JSRs rather than traps to PackBits, so the earlier patch
;	didn't help that much.  This (big) patch fixes StdBits to trap to the new routine.
;

PatchStdBits	PROC  EXPORT
				IMPORT	CheckPic, DoPict2
				IMPORT PutPicByte,PutPicWord,PutPicData

;---------------------------------------------------------------
;
;  PROCEDURE StdBits(VAR srcBits: BitMap;
;			 VAR srcRect: Rect;
;			 VAR dstRect: Rect;
;			 mode:	  INTEGER;
;			 maskRgn:	  RgnHandle);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	18
SRCBITS 		EQU 	PARAMSIZE+8-4		;LONG, ADDR OF BITMAP
SRCRECT 		EQU 	SRCBITS-4			;LONG, ADDR OF RECT
DSTRECT 		EQU 	SRCRECT-4			;LONG, ADDR OF RECT
MODE			EQU 	DSTRECT-2			;WORD
MASKRGN 		EQU 	MODE-4				;LONG, RGNHANDLE

MYBITS			EQU 	-14 				;BITMAP
SRCPTR			EQU 	MYBITS-4			;LONG
DSTPTR			EQU 	SRCPTR-4			;LONG
PACKBUF			EQU		DSTPTR-4			;POINTER TO PACKING BUFFER
SAVEDSP			EQU		PACKBUF-4			;PRESERVE STACK POINTER
VARSIZE			EQU		SAVEDSP


		LINK	A6,#VARSIZE 			;ALLOCATE STACK FRAME
		MOVEM.L D3-D7/A2-A4,-(SP)		;SAVE REGS
		JSR 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BGT.S 	@100					;BRANCH IF PICSAVE
		JMPROM	ROMStdBitsNotPic					;continue in ROM
@100
		MOVE.L	SP,SAVEDSP(A6)			;PRESERVE STACK POINTER
		MOVEQ	#8,D6
;
;  TRIM SRCBITS
;
		MOVE.L	SRCBITS(A6),A0				;GET ADDR OF SRCBITS
		LEA 	MYBITS(A6),A1				;POINT TO MY COPY
		MOVE.L	BASEADDR(A0),A3 			;GET BASEADDR (CLOBBERS A3)
		MOVE	ROWBYTES(A0),D4 			;GET OLD ROWBYTES
		MOVE.L	BOUNDS+TOPLEFT(A0),BOUNDS+TOPLEFT(A1)	 ;COPY BOUNDS TOPLEFT
		MOVE.L	BOUNDS+BOTRIGHT(A0),BOUNDS+BOTRIGHT(A1)  ;COPY BOUNDS BOTRIGHT
		MOVE.L	SRCRECT(A6),A0				;POINT TO SRCRECT
		MOVE	TOP(A0),D0					;GET SRCRECT.TOP
		SUB 	BOUNDS+TOP(A1),D0			;SKIPTOP:=SRCRECT.TOP-BOUNDS.TOP
		BLE.S	TOPOK						;CONTINUE IF SKIPTOP NEG
		ADD 	D0,BOUNDS+TOP(A1)			;NEWTOP := SRCRECT TOP
		MULU	D4,D0						;CALC VERT OFFSET
		ADD.L	D0,A3						;ADJUST BASEADDR

TOPOK	MOVE	BOTTOM(A0),D0				;GET SRCRECT.BOTTOM
		CMP 	BOUNDS+BOTTOM(A1),D0		;IS SRCRECT BOT < BOUNDS BOT ?
		BGE.S	BOTOK						;NO, CONTINUE
		MOVE	D0,BOUNDS+BOTTOM(A1)		;YES, TRIM BOUNDS BOTTOM

BOTOK	MOVE	LEFT(A0),D0 				;GET SRCRECT.LEFT
		SUB 	BOUNDS+LEFT(A1),D0			;CALC SKIPLEFT
		BLE.S	LEFTOK						;CONTINUE IF SKIPLEFT NEG
		LSR 	#3,D0						;DIV BY 8 FOR SKIP BYTES
		ADD 	D0,A3						;OFFSET BASEADDR HORIZ
		LSL 	#3,D0						;BYTES TIMES 8 FOR DOTS
		ADD 	D0,BOUNDS+LEFT(A1)			;ADD DOTS TO BOUNDS.LEFT

LEFTOK	MOVE	RIGHT(A0),D0				;GET SRCRECT.RIGHT
		SUB 	BOUNDS+LEFT(A1),D0			;CONVERT TO GLOBAL
		ADD 	#7,D0						;ROUND UP
		LSR 	#3,D0						;TO NEXT MULT OF 8
		LSL 	#3,D0
		ADD 	BOUNDS+LEFT(A1),D0			;RETURN TO LOCAL
		CMP 	BOUNDS+RIGHT(A1),D0 		;IS RESULT < BOUNDS.RIGHT ?
		BGE.S	RIGHTOK 					;NO, CONTINUE
		MOVE	D0,BOUNDS+RIGHT(A1) 		;YES, TRIM RIGHT
RIGHTOK
;
;  CALC NEW ROWBYTES AFTER TRIMMING
;
		MOVE	BOUNDS+RIGHT(A1),D5 		;GET TRIMMED RIGHT
		SUB 	BOUNDS+LEFT(A1),D5			;CALC WIDTH
		ADD 	#15,D5					;ROUND UP
		LSR 	#4,D5					;DIV BY 16
		BGT.S	@200					;continue if greater than 0
;		MOVE.L	SAVEDSP(A6),SP				;RESTORE STACK POINTER
		JMPROM	ROMStdBitsOK			;IGNORE IF NEWROW <= 0
@200
		ADD 	D5,D5					;DOUBLE FOR NEW ROWBYTES
		MOVE	D5,ROWBYTES(A1)			;COPY ROWBYTES

		MOVE.B	#$90,-(SP)				;PUSH OPCODE=BITSRECT
		TST.L	MASKRGN(A6) 			;IS MASKRGN NIL ?
		BEQ.S	NOTRGN					;YES, CONTINUE
		ADD.B	#1,(SP) 				;REPLACE OPCODE=BITSRGN (IE. $91)
NOTRGN	CMP 	D6,D5					;IS NEWROW < 8 ?
		BLT.S	NOPACK					;YES, DONT BITPACK
		ADD.B	#8,(SP) 				;SET BIT 3 FOR BITPACK
NOPACK
		jsr		DoPict2					;align for PICT2			<17Sept90 KON>
		JSR 	PutPicByte				;PUT OPCODE TO THEPIC

		PEA 	MYBITS+ROWBYTES(A6) 	;PUSH ADDR OF ROWBYTYES,BOUNDS
		MOVE	#10,-(SP)				;PUSH BYTECOUNT = 10
		JSR 	PutPicData				;PUT ROWBYTES,BOUNDS TO THEPIC

		MOVE.L	SRCRECT(A6),-(SP)
		MOVE	D6,-(SP)
		JSR 	PutPicData				;PUT SRCRECT
		MOVE.L	DSTRECT(A6),-(SP)
		MOVE	D6,-(SP)
		JSR 	PutPicData				;PUT DSTRECT
		MOVE	MODE(A6),-(SP)
		JSR 	PutPicWord				;PUT MODE

		TST.L	MASKRGN(A6) 			;IS MASKRGN NIL ?
		BEQ.S	NOMASK					;YES, SKIP IT
		MOVE.L	MASKRGN(A6),-(SP)		;NO, PUSH MASKRGN
		JSRROM 	ROMPutPicRgn			;PUT MASKRGN TO THEPIC
NOMASK
;
;  NOW PUT THE BITMAP DATA:  IF NEWROW >= 8 THEN USE PACKBITS
;
		LEA 	MYBITS(A6),A2			;POINT TO (TRIMMED) BITMAP
		MOVE	BOUNDS+BOTTOM(A2),D7
		SUB 	BOUNDS+TOP(A2),D7		;HEIGHT := BOUNDS BOT - TOP

		CMP 	D6,D5					;IS NEWROW < 8 ?
		BGE.S	@PackIt					;No, use packing
;		MOVE.L	SAVEDSP(A6),SP			;RESTORE STACK POINTER
		jmpROM	ROMStdBitsStart2		;continue in ROM

;----------------------------------------------------------------
;
;  MAKE SURE THE STACK IS ON A LONGWORD BOUNDARY (FOR FAST BUFFERS)
;
@PackIt
		MOVE.L	SP,D1						;GET THE STACK POINTER
		AND.B	#$FC,D1						;FORCE LONG ALIGNMENT
		MOVE.L	D1,SP						;USE IT

;----------------------------------------------------------------
;
;  ALLOCATE PACKBUF ON THE STACK
;
		SUB		D5,SP						;SET SIZE OF PACKBUF
		SUB		D5,SP						;TO 2*ROWBYTES FOR LONG ALIGNMENT
		MOVE.L	SP,PACKBUF(A6)				;POINT TO PACKBUF
		
;----------------------------------------------------------------
;
;  ROWBYTES >= 8, WRITE THE PACKED BIT/PIXMAP TO THE PICTURE
;
;  PACKED FORMAT = [BYTECOUNT][DATA]  FOR EACH SCANLINE
;
;  IF ROWBYTES > 250 THEN BYTECOUNT IS A WORD, ELSE IT IS A BYTE
;
		BRA.S	START1						;GO TO LOOP START
MORE1	MOVE.L	A3,SRCPTR(A6)			;SRCPTR := ^SCANLINE DATA
		move.l 	PACKBUF(A6),A0
		MOVE.L	A0,DSTPTR(A6)			;DSTPTR := @PACKBUF
		PEA 	SRCPTR(A6)				;PUSH VAR SRCPTR
		PEA 	DSTPTR(A6)				;PUSH VAR DSTPTR
		MOVE	D5,-(SP)				;PUSH SRCBYTES = NEWROW
		_PackBits						;PACK ROW INTO PACKBUF (here's the fix!)     <PMA399/DAF>
		MOVE.L	DSTPTR(A6),D6			;GET UPDATED DSTPTR
		move.l 	PACKBUF(A6),A0			;POINT TO PACKBUF
		SUB.L	A0,D6					;CALC PACKED BYTECOUNT
		CMP		#250,D5						;IS ROWBYTES > 250?
		BGT.S	@1							;=>YES, PUT WORD
		MOVE.B	D6,-(SP)					;ELSE PUSH THE BYTE
		JSR		PUTPICBYTE					;AND PUT TO PICTURE
		BRA.S	@2							;=>AND GO PUT DATA
@1		MOVE.W	D6,-(SP)					;PUSH PACKED BYTECOUNT
		JSR		PUTPICWORD					;PUT THE WORD
@2		MOVE.L 	PACKBUF(A6),-(SP)
		MOVE	D6,-(SP)
		JSR 	PutPicData					;PUT PACKED DATA TO THEPIC
		ADD 	D4,A3						;ADD OLDROW TO BITS PTR
START1	DBRA	D7,MORE1					;LOOP FOR HEIGHT ROWS
		MOVE.L	SAVEDSP(A6),SP				;RESTORE STACK POINTER
		jmpROM	ROMStdBitsOK			;and continue in ROM


PortablePatchStdPoly	PROC	EXPORT
		IMPORT CheckPic
;---------------------------------------------------------------
;
;  PROCEDURE StdPoly(verb: GrafVerb; poly: PolyHandle);
;
;  A6 OFFSETS OF PARAMS AND LOCALS AFTER LINK:
;
PARAMSIZE		EQU 	6
VERB			EQU 	PARAMSIZE+8-2	;GRAFVERB
POLY			EQU 	VERB-4			;LONG, PolyHandle

MINRECT 		EQU 	-8				;RECT
VARSIZE 		EQU 	MINRECT 		;TOTAL BYTES OF LOCALS

		LINK	A6,#VARSIZE 			;ALLOCATE STACK FRAME
		MOVEM.L D5-D7/A2-A4,-(SP)		;SAVE REGS
		MOVE.B	VERB(A6),D7 			;GET VERB
		JSR 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)
		peaROM	ROMStdPolyRtn
		jmp 	PutPicVerb				;PUT ADDIONAL PARAMS TO THEPIC
NotPic
		jmpROM	ROMStdPolyNotPic
		ENDPROC


PatchStdRect PROC  EXPORT
		IMPORT CheckPic
;---------------------------------------------------------------
;
;  PROCEDURE StdRect(verb: GrafVerb; r: Rect);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	6
VERB			EQU 	PARAMSIZE+8-2			;GRAFVERB
RECT			EQU 	VERB-4				;LONG, ADDR OF RECT

		LINK	A6,#0					;NO LOCALS
		MOVEM.L D7/A3-A4,-(SP)				;SAVE REGS
		MOVE.B	VERB(A6),D7 			;GET VERB
		jsr 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)				;PUSH VERB
		peaROM	ROMStdRectRtn
		jmp 	PutPicVerb				;PUT ADDIONAL PARAMS TO THEPIC
NotPic
		jmpROM	ROMStdRectNotPic
		
		ENDPROC

PatchStdLine PROC  EXPORT
		IMPORT CheckPic
;---------------------------------------------------------------
;
;  PROCEDURE StdLine(newPt: Point);
;
PARAMSIZE		EQU 	4
NEWPT			EQU 	PARAMSIZE+8-4

		LINK	A6,#0					;NO LOCAL VARS
		MOVEM.L D5-D7/A3-A4,-(SP)			;SAVE REGS
		jsr 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	#FRAME,-(SP)			;PUSH VERB
		peaROM	ROMStdLineRtn
		jmp 	PutPicVerb				;CHECK pnSize, pnMode, pnPat
NotPic
		jmpROM	ROMStdLineNotPic
		
		ENDPROC

PatchStdRRect PROC  EXPORT	
		IMPORT CheckPic, DoPict2
;---------------------------------------------------------------
;
;  PROCEDURE StdRRect(verb: GrafVerb; r: Rect; ovWd,ovHt: INTEGER);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	10
VERB			EQU 	PARAMSIZE+8-2			;GRAFVERB
RECT			EQU 	VERB-4				;LONG, ADDR OF RECT
OVWD			EQU 	RECT-2				;WORD
OVHT			EQU 	OVWD-2				;WORD

		LINK	A6,#0					;NO LOCALS
		MOVEM.L D7/A3-A4,-(SP)				;SAVE REGS
		MOVE.B	VERB(A6),D7 			;GET VERB
		jsr 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)				;PUSH VERB
		jsr		PutPicVerb
;
;  CHECK FOR NEW OVAL SIZE
;
		MOVE.L	PICSAVE(A3),A0				;GET PICSAVE HANDLE
		MOVE.L	(A0),A0 				;DE-REFERENCE PICSAVE
		MOVE.L	OVHT(A6),D0 			;GET OVWD AND OVHT
		CMP.L	PICOVSIZE(A0),D0			;SAME AS CURRENT OVAL SIZE ?
		BEQ.S	OVALOK					;YES, CONTINUE
		MOVE.L	D0,PICOVSIZE(A0)			;NO, UPDATE STATE VARIABLE
		MOVE.L	D0,-(SP)				;PUSH OVSIZE FOR PutPicLong CALL
		MOVEQ	#$0B,D0
		JSR 	DPutPicByte 			;PUT OVSIZE OPCODE
		JSR 	PutPicLong				;PUT NEW OVAL SIZE DATA
		jsr		DoPict2
OVALOK	
		jmpROM	ROMStdRRectRtn

NotPic
		jmpROM	ROMStdRRectNotPic
		ENDPROC

PatchStdOval PROC  EXPORT
		IMPORT CheckPic
;---------------------------------------------------------------
;
;  PROCEDURE StdOval(verb: GrafVerb; r: Rect);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	6
VERB			EQU 	PARAMSIZE+8-2			;GRAFVERB
RECT			EQU 	VERB-4				;LONG, ADDR OF RECT

OVWD			EQU 	-2				;WORD
OVHT			EQU 	OVWD-2				;WORD
VARSIZE 		EQU 	OVHT				;TOTAL BYTES OF LOCALS


		LINK	A6,#VARSIZE 			;ALLOCATE STACK FRAME
		MOVEM.L D7/A3-A4,-(SP)				;SAVE REGS
		MOVE.B	VERB(A6),D7 			;GET VERB
		jsr 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)				;PUSH VERB
		peaROM	ROMStdOvalRtn
		jmp 	PutPicVerb				;PUT ADDIONAL PARAMS TO THEPIC
NotPic
		jmpROM	ROMStdOvalNotPic
		ENDPROC

PatchStdArc	PROC  EXPORT
		IMPORT CheckPic
;---------------------------------------------------------------
;
;  PROCEDURE StdArc(verb: GrafVerb; r: Rect; startAngle,arcAngle: INTEGER);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	10
VERB			EQU 	PARAMSIZE+8-2			;GRAFVERB
RECT			EQU 	VERB-4				;LONG, ADDR OF RECT
STARTANG		EQU 	RECT-2				;WORD
ARCANG			EQU 	STARTANG-2			;WORD

OVWD			EQU 	-2				;WORD
OVHT			EQU 	OVWD-2				;WORD
VARSIZE 		EQU 	OVHT				;TOTAL BYTES OF LOCALS


		LINK	A6,#VARSIZE 			;ALLOCATE STACK FRAME
		MOVEM.L D4/D7/A3-A4,-(SP)			;SAVE REGS
		MOVE.B	VERB(A6),D7 			;GET VERB
		jsr 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)				;PUSH VERB
		peaROM	ROMStdArcRtn
		jmp 	PutPicVerb				;PUT ADDIONAL PARAMS TO THEPIC
NotPic
		jmpROM	ROMStdArcNotPic
		ENDPROC

PatchStdRgnSEPortable	PROC  EXPORT
		IMPORT CheckPic
;---------------------------------------------------------------
;
;  PROCEDURE StdRgn(verb: GrafVerb; rgn: RgnHandle);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	6
VERB			EQU 	PARAMSIZE+8-2			;GRAFVERB
RGN 		EQU 	VERB-4				;LONG, RGNHANDLE

		LINK	A6,#0					;NO LOCALS
		MOVEM.L D6-D7/A2-A4,-(SP)			;SAVE REGS
		MOVE.B	VERB(A6),D7 			;GET VERB
		jsr 	CHECKPIC				;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC					;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)				;PUSH VERB
		peaROM	ROMStdRgnRtn
		jmp 	PutPicVerb				;PUT ADDIONAL PARAMS TO THEPIC
NotPic
		jmpROM	ROMStdRgnNotPic
		ENDPROC
;
; Patch StdRgn differently on the Plus because PutRgn, which is called by
; StdDraw has a bug in it only on the Plus ROM.
;
PatchStdRgnPlus	PROC  EXPORT
		IMPORT CheckPic,MyPutRgn
ROMNotRgn		ROMBind	(Plus, $BC46)
ROMNotFr		ROMBind	(Plus, $BC4C)
;---------------------------------------------------------------
;
;  PROCEDURE StdRgn(verb: GrafVerb; rgn: RgnHandle);
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	6
VERB			EQU 	PARAMSIZE+8-2		;GRAFVERB
RGN 			EQU 	VERB-4					;LONG, RGNHANDLE

		LINK	A6,#0						;NO LOCALS
		MOVEM.L D6-D7/A2-A4,-(SP)			;SAVE REGS
		MOVE.B	VERB(A6),D7 				;GET VERB
		jsr 	CHECKPIC					;SET UP A4,A3 AND CHECK PICSAVE
		BLE.S	NOTPIC						;BRANCH IF NOT PICSAVE

		MOVE.B	D7,-(SP)					;PUSH VERB
		JSR		PutPicVerb					;PUT ADDITONAL PARAMS TO THEPIC
		MOVE	#$80,D0 					;PUT RGNNOUN IN HI NIBBLE
		ADD 	D7,D0						;PUT VERB IN LO NIBBLE
		JSR		DPutPicByte					;PUT OPCODE TO THEPIC				<30>
		MOVE.L	RGN(A6),-(SP)				;PUSH RGNHANDLE
		JSRROM 	ROMPutPicRgn				;PUT REGION TO THEPIC

NOTPIC	MOVE.L	RGN(A6),-(SP)				;PUSH RGNHANDLE
		jsrROM 	ROMPushVerb					;PUSH MODE AND PATTERN
		TST.B	D7							;IS VERB FRAME ?
		BNE.S	NOTFR						;NO, CONTINUE
		TST.L	RGNSAVE(A3) 				;YES, IS RGNSAVE TRUE ?
		BEQ.S	NOTRGN						;NO, CONTINUE
		MOVE.L	RGN(A6),-(SP)				;YES, PUSH RGNHANDLE
		MOVE.L	RGNBUF(A4),-(SP)			;PUSH RGNBUF
		PEA 	RGNINDEX(A4)				;PUSH VAR RGNINDEX
		PEA 	RGNMAX(A4)					;PUSH VAR RGNMAX
		JSR 	MyPutRgn					;ADD INVERSION PTS TO THERGN

NOTRGN	jmpROM	ROMNotRgn

;		JSR 	FrRgn					;FrRgn(rgn,pnMode,pnPat)
;		BRA.S	GOHOME

NOTFR	jmpROM	ROMNotFr

;		JSR 	DrawRgn 				;DrawRgn(rgn,mode,pat);

;GOHOME	MOVEM.L (SP)+,D6-D7/A2-A4			;RESTORE REGS
;		UNLINK	PARAMSIZE,'STDRGN  '
		ENDPROC

MyPutRgn	PROC
		IMPORT	SETHSIZE
PlusPutRgnDone	ROMBind	(Plus, $C8BA)
PlusNotRect		ROMBind	(Plus, $C8A0)
PlusSetHSize	ROMBind	(Plus, $8798)
;----------------------------------------------------------------
;
;  PROCEDURE PutRgn(Rgn: RgnHandle; bufHandle: Handle; VAR index,size: INTEGER);
;
;  Expands a region out to an array of inversion points.
;


;------------------------------------------------
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE		EQU 	16				;TOTAL SIZE OF PARAMETERS
RGNHANDLE		EQU 	PARAMSIZE+8-4			;LONG,RGNHANDLE
BUFHANDLE		EQU 	RGNHANDLE-4 		;LONG, HANDLE
INDEX			EQU 	BUFHANDLE-4 		;LONG, VAR
SIZE			EQU 	INDEX-4 			;LONG, VAR


		LINK	A6,#0					;NO LOCAL VARS
		MOVEM.L D7/A2-A4,-(SP)				;SAVE REGS

;-------------------------------------------------------
;
;  EXPAND BUF TO FIT WORST CASE BYTESNEEDED = RGNSIZE * 2
;
		MOVE.L	BUFHANDLE(A6),A4			;GET BUFHANDLE
		MOVE.L	RGNHANDLE(A6),A3			;GET RGNHANDLE
		MOVE.L	INDEX(A6),A2				;POINT TO CURRENT INDEX
		MOVE.L	(A3),A0 				;DE-REFERENCE RGN
		MOVE	(A0),D7 				;GET RGNSIZE
		ADD 	D7,D7					;TIMES 2
		ADD 	(A2),D7 				;ADD CURRENT INDEX
		MOVE.L	SIZE(A6),A1 			;POINT TO SIZE
		CMP 	(A1),D7 				;IS REQUIRED > CURRENT SIZE ?
		BLE.S	NOGROW					;NO, CONTINUE

		ADD 	#256,D7 				;GROW IN CHUNKS
		MOVE	D7,(A1) 				;UPDATE CURRENT SIZE
		MOVE.L	A4,-(SP)				;PUSH BUFHANDLE
		MOVE	D7,-(SP)				;PUSH NEW SIZE
		jsrROM 	PlusSetHSize 			;MAKE ROOM IN BUF
		MOVE.L	(A3),A0 				;RE-DEREFERENCE RGNHANDLE
		MOVE.L	INDEX(A6),A2			;GET ADDR OF INDEX AGAIN

NOGROW	MOVE.L	(A4),A1 				;DE-REFERENCE BUFHANDLE
		ADD 	(A2),A1 				;ADD INDEX TO BUFPTR
		CMP 	#10,RGNSIZE(A0) 			;IS REGION RECTANGULAR ?
		BNE.S	NOTRECT 				;NO, CONTINUE
		ADD 	#2,A0					;YES, POINT TO BBOX TOPLEFT
;
; Here's the patch that was left out of the Plus ROM <28FEB90 KON>
;
		MOVE.L	(A0),(A1)+ 				;COPY TOPLEFT					<EHB 26Sep86>
		MOVE	(A0)+,(A1)+				;COPY TOP						<EHB 26Sep86>
		MOVE	(A0)+,D0				;GET LEFT						<EHB 26Sep86>
		MOVE.L	(A0),D1					;GET BOTRIGHT					<EHB 26Sep86>
		MOVE	D1,(A1)+				;COPY RIGHT						<EHB 26Sep86>
		MOVE	(A0),(A1)+				;COPY BOT						<EHB 26Sep86>
		MOVE	D0,(A1)+				;COPY LEFT						<EHB 26Sep86>
		MOVE.L	D1,(A1)+ 				;COPY BOTRIGHT					<EHB 26Sep86>
		jmpROM	PlusPutRgnDone			;Back to ROM
;		BRA.S	DONE					;UPDATE INDEX AND QUIT

NOTRECT
		jmpROM	PlusNotRect
;		LEA 	RGNDATA(A0),A0			;POINT TO TOP VERT IN RGN
;NXTVERT MOVE.L	(A0)+,D7				;GET VERT AND HORIZ COORDS
;NXTHOR	MOVE.L	D7,(A1)+				;PUT LEFT POINT TO DST
;		MOVE	(A0)+,D7				;GET HORIZ COORD
;		MOVE.L	D7,(A1)+				;PUT RIGHT POINT TO DST
;		MOVE	(A0)+,D7				;GET NEXT HORIZ COORD
;		CMP 	#32767,D7				;END OF SCAN FLAG ?
;		BNE 	NXTHOR					;NO, GO FOR MORE
;		CMP 	#32767,(A0) 			;END OF REGION ?
;		BNE 	NXTVERT 				;NO, LOOP FOR MORE

;DONE	SUB.L	(A4),A1 				;CALC DSTPTR - DSTSTART
;		MOVE	A1,(A2) 				;UPDATE VAR INDEX
;GOHOME	MOVEM.L (SP)+,D7/A2-A4			 ;RESTORE REGISTERS
;		UNLINK	PARAMSIZE,'PUTRGN  '
		ENDPROC

PatchStdComment PROC  EXPORT
		IMPORT DoPict2
;---------------------------------------------------------------
;
;  PROCEDURE StdComment
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
		peaROM	ROMStdComment
		jmp		DoPict2
		ENDPROC

DoPict2	PROC	EXPORT
		IMPORT	DPutPicByte
;
; if we are recording a PICT2, align pixSize by padding with zeros
;
		MOVE.L	GRAFGLOBALS(A5),A0				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A0),A0					;GET CURRENT GRAFPORT
		MOVE.L	PICSAVE(A0),d0					;GET PICSAVE HANDLE
		beq.s	@AllDone
		move.l	d0,a0
		MOVE.L	(A0),A0 						;DE-REFERENCE PICSAVE
		tst		PICVERSION(A0)					;IS IT AN OLD PICTURE?
		BEQ.S	@AllDone						;=>YES, DON'T PAD
		MOVE.L	THEPIC(A0),A0					;GET THEPIC HANDLE				<KON 6/4/92>
		MOVE.L	(A0),A0							;POINT AT THE PIC				<KON 6/4/92>
		MOVE	PICSIZE(A0),D0					;GET THE LOW WORD OF THE SIZE	<KON 6/4/92>
		and.b	#1,d0							;odd?
		beq.s	@OneZero
		moveq	#0,d0
		jsr		DPutPicByte						;put d0=0 to picture
		moveq	#0,d0
@OneZero
		jsr		DPutPicByte						;should be odd aligned after this
@AllDone
		rts										;return to called ROM routine
		ENDPROC

CheckPic PROC  EXPORT	
		IMPORT ROMEqualRgn,ROMCopyRgn
		IMPORT DPutPicByte,PutPicLong
;---------------------------------------------------------------
;
;  PROCEDURE CheckPic;
;
;  PUT GRAFGLOBALS IN A4, THEPORT IN A3, AND CHECK PICSAVE.
;  IF PICSAVE IS NIL, RETURN FLAGS LE.
;
;  IF PICSAVE NOT NIL, RETURN FLAGS GT, AND
;  CHECK FOR CHANGES IN FGCOLOR, BKCOLOR, ORIGIN, AND CLIPRGN.
;
;
		MOVE.L	D7,-(SP)					;SAVE REGS
		MOVE.L	GRAFGLOBALS(A5),A4			;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A4),A3				;POINT TO CURRENT GRAFPORT
		TST.L	PICSAVE(A3) 				;ARE WE SAVING FOR A PICTURE ?
		BEQ 	DONE						;NO, QUIT
		CMP 	#-1,PNVIS(A3)				;IS PEN HIDDEN MORE THAN ONE ?
		BLT 	DONE						;YES, DON'T ADD TO THEPIC

		MOVE.L	PICSAVE(A3),A4				;YES, GET PICSAVE HANDLE
		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE
;
;  CHECK FOR CHANGES IN FOREGROUND COLOR
;
		MOVE.L	FGCOLOR(A3),D7				;GET FORGROUND COLOR
		CMP.L	PICFGCOLOR(A4),D7			;HAS IT CHANGED ?
		BEQ.S	FGCOLOK 					;NO, CONTINUE
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$0E,D0
		JSR 	DPutPicByte 			;PUT FGCOLOR OPCODE
		MOVE.L	D7,-(SP)
		JSR 	PutPicLong				;PUT FGCOLOR
		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE
		MOVE.L	(A4),A4 				;DE-REFERENCE PICSAVE
		MOVE.L	D7,PICFGCOLOR(A4)			;UPDATE CURRENT STATE
FGCOLOK
;
;  CHECK FOR CHANGES IN BACKGROUND COLOR
;
		MOVE.L	BKCOLOR(A3),D7				;GET BACKGROUND COLOR
		CMP.L	PICBKCOLOR(A4),D7			;HAS IT CHANGED ?
		BEQ.S	BKCOLOK 				;NO, CONTINUE
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$0F,D0
		JSR 	DPutPicByte 			;PUT BKCOLOR OPCODE
		MOVE.L	D7,-(SP)
		JSR 	PutPicLong				;PUT BKCOLOR PARAM
		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE
		MOVE.L	(A4),A4 				;DE-REFERENCE PICSAVE
		MOVE.L	D7,PICBKCOLOR(A4)			;UPDATE CURRENT STATE
BKCOLOK
;
;  CHECK FOR ORIGIN CHANGES
;
		MOVE.L	PORTRECT+TOPLEFT(A3),D0 		;GET PORTRECT.TOPLEFT
		CMP.L	PICORIGIN(A4),D0			;SAME AS PIC ORIGIN ?
		BEQ.S	ORIGNOK 				;YES, CONTINUE

		MOVE	PORTRECT+LEFT(A3),D7			;GET PORTRECT LEFT
		SUB 	PICORIGIN+H(A4),D7			;CALC DH
		ADD 	D7,PICORIGIN+H(A4)			;UPDATE STATE VARIABLE
		SWAP	D7					;PUT DH IN HI WORD

		MOVE	PORTRECT+TOP(A3),D7 		;GET PORTRECT TOP
		SUB 	PICORIGIN+V(A4),D7			;CALC DV
		ADD 	D7,PICORIGIN+V(A4)			;UPDATE STATE VARIABLE
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$0C,D0
		JSR 	DPutPicByte 		 ;PUT ORIGIN OPCODE TO THEPIC
		MOVE.L	D7,-(SP)
		JSR 	PutPicLong				;PUT DH,DV TO THEPIC
		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE
		MOVE.L	(A4),A4 				;DE-REFERENCE PICSAVE
;
;  CHECK FOR CLIPRGN CHANGES
;
ORIGNOK CLR.B	-(SP)					;MAKE ROOM FOR FCN VALUE
		MOVE.L	CLIPRGN(A3),-(SP)			;PUSH CLIPRGN
		MOVE.L	PICCLIPRGN(A4),-(SP)			;PUSH STATE VARIABLE
		JSRROM 	ROMEqualRgn				;ARE THEY THE SAME ?
		TST.B	(SP)+					;TEST RESULT
		BNE.S	CLIPOK					;QUIT IF SAME

		MOVE.L	CLIPRGN(A3),-(SP)			;SET UP FOR COPYRGN BELOW
		MOVE.L	PICCLIPRGN(A4),-(SP)
;
; Do alignement for new pictures
;
;		tst.w	picVersion(a4)
;		beq.s	@Pict1
		jsr		DoPict2					;align for PICT2
;@Pict1
		MOVEQ	#$01,D0
		JSR 	DPutPicByte 			;PUT CLIPRGN PARAM OPCODE
		MOVE.L	CLIPRGN(A3),-(SP)			;PUSH CLIPRGN HANDLE
		JSRROM 	ROMPutPicRgn				;PUT CLIPRGN TO THEPIC

		JSRROM 	ROMCOPYRGN 				;COPY CLIPRGN INTO PICCLIPRGN

CLIPOK
		MOVE.L	GRAFGLOBALS(A5),A4		;POINT TO QUICKDRAW GLOBALS
		MOVEQ	#1,D0					;CLEAR ZERO FLAG
DONE	MOVEM.L (SP)+,D7				;MOVEM FOR CC, RESTORE REGS
		RTS 					;AND RETURN

		
;----------------------------------
PatchOpenPicture FUNC  EXPORT	
;------------------------------------------------------------------
;
;  FUNCTION OpenPicture(picFrame: Rect): PicHandle;
;
;  A6 OFFSETS OF PARAMS AFTER LINK:
;
PARAMSIZE		EQU 	4
RESULT			EQU 	PARAMSIZE+8 		;LONG, PICHANDLE
RECT			EQU 	RESULT-4			;LONG, ADDR OF RECT

		LINK	A6,#0					;NO LOCALS
		MOVEM.L A3-A4,-(SP) 			;SAVE REGS
		CLR.L	RESULT(A6)				;INIT FCN RESULT TO NIL
		MOVE.L	GRAFGLOBALS(A5),A4			;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A4),A3				;GET CURRENT GRAFPORT
		TST.L	PICSAVE(A3) 			;ARE WE ALREADY SAVING ?
		BNE 	DONE					;YES, RETURN NIL AND QUIT
		_HidePen		 				;NO, TURN OFF DRAWING
;
;  Abort OpenPicture if heap doesn't have at least 500 bytes.
;
		MOVE.L	#500,D0 				;GET BYTE COUNT
		_NewHandle					;AT LEAST 500 BYTES IN THE HEAP ?
		BNE 	DONE					;NO, RETURN NIL AND QUIT
		_DisposHandle					;YES, Discard test handle

;
;  ALLOCATE PICSAVE RECORD
;
		MOVE.L	#PICSAVEREC,D0				;GET BYTE COUNT
		_NewHandle					;ALLOCATE PICSAVE RECORD
		MOVE.L	A0,A4					;GET RESULT HANDLE
		MOVE.L	A4,PICSAVE(A3)				;SAVE RESULT IN THEPORT

;
; Allocate handle for fond id's we have seen so far
;
;		Format of picFontList handle is:
;			handle size [long]
;			# of entries - 1 used [word]
;				id1, id2, ... idn

FontListSize	equ		50*2

doFontList
		moveq	#FontListSize+6,d0				;initial size for 50 entries
		_NewHandle
		move.l	picSave(a3),a1					;get picSave handle
		move.l	(a1),a1
		move.l	a0,picFontList(a1)				;save picFontList handle in picSave record
		beq.s	@noHandle
		
		move.l	(a0),a0							;point into fontList
		moveq	#FontListSize+6,d0				;initial size for 50 entries
		move.l	d0,(a0)+
		clr.l	(a0)							; 1 entry, first entry = 0

@noHandle
		clr.w	picVersion(a1)					;old picture

; Clear picQdRunSlop and picQdChExtra

		clr.l	picQdChExtra(a1)				; picQdChExtra := 0
		clr.l	picQdRunSlop(a1)				; picQdRunSlop := 0

; INIT GLYPH STATE TO INVALID

		move.l	#$80808080,picGlyphState(a1)	; set glyph state to invalid values

; Fall into original OpenPicture at the proper point.

		jmpROM	OpenPictptchEntry
Done	jmpROM	OpenPictDone


PatchClosePicture PROC  EXPORT		
;------------------------------------------------------------------
;
;  PROCEDURE ClosePicture;
;
		MOVEM.L D6-D7/A3,-(SP)				;SAVE REGS
		MOVE.L	GRAFGLOBALS(A5),A3			;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A3),A3				;GET CURRENT GRAFPORT
		MOVE.L	PICSAVE(A3),D7				;ARE WE SAVING A PICTURE ?
		BEQ.S	GOHOME					;NO, OOPS, EXIT

		MOVE.L	D7,A0					;GET PICSAVE HANDLE 	<Nov02-89 KON>
		MOVE.L	(A0),A0					;POINT TO PICSAVE RECORD <Nov02-89 KON>
		move.l	picFontList(a0),a0		;get fontList handle	<Nov02-89 KON>
		_DisposHandle
;		move	picVersion(a0),d0
;		bne.s	@DoNewPicture
;		jmpROM	ClosePictptchEntry
;@DoNewPicture

		MOVE	#opEndPic,-(SP)					;YES, PUSH ENDPIC OPCODE
		JSR 	PutPicOp						;PUT TO THEPIC
		jmpROM	ClosePictptchEntryNew
GoHome	jmpROM	ClosePictGoHome
		ENDPROC

PatchOpenPort patchProc _OpenPort, (Plus,SE,Portable,II,IIci)
;-------------------------------------------------------------
;
;  PROCEDURE OpenPort(port: GrafPtr);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchInitPort patchProc _InitPort, (Plus,SE,Portable,II,IIci)
;-------------------------------------------------------------
;
;  PROCEDURE InitPort(port: GrafPtr);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchSetPort patchProc _SetPort, (Plus,SE,Portable,II,IIci)
;----------------------------------------------------------
;
;  PROCEDURE SetPort(gp: GrafPtr);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchLineTo patchProc _LineTo, (Plus,SE,Portable,II,IIci)
;----------------------------------------------------------
;
;  PROCEDURE LineTo(h,v: INTEGER);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchLine patchProc _Line, (Plus,SE,Portable,II,IIci)
;----------------------------------------------------------
;
;  PROCEDURE Line(dh,dv: INTEGER);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchMoveTo patchProc _MoveTo, (Plus,SE,Portable,II,IIci)
;----------------------------------------------------------
;
;  PROCEDURE MoveTo(h,v: INTEGER);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchMove patchProc _Move, (Plus,SE,Portable,II,IIci)
;----------------------------------------------------------
;
;  PROCEDURE Move(dh,dv: INTEGER);
;
		move.l	grafGlobals(a5),a0				; load QuickDraw globals.
		move.w	#$8000,pnLocFixed(a0)			; reset pen fraction.
		jmpOld									; join the original ROM code.
		endproc

PatchShowCursor PROC EXPORT
;----------------------------------------------------------
;
;  PROCEDURE ShowCursor();
;

		MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
		ADDQ	#1,CRSRSTATE					;CURSOR HIDDEN ONE LESS DEEP
		BLT.S	DoneHide						;QUIT IF STILL HIDDEN
		clr.b	CrsrObscure						;unobscure if level goes +
		subq	#1,CrsrState					; setup for ROM’s ADDQ #1			<21>
		jmpOld									; call the ROM (or other patcher)	<21>
DoneHide
		jmpROM	ROMShowCrsr

		endproc

;=========================================================================================
;=========================================================================================
;
;	Patch SeedFill and CalcMask to check both up and down on the first pass of filling
;
;=========================================================================================
;=========================================================================================

SeedFill PROC	 EXPORT 
		EXPORT	CalcMask

;-------------------------------------------------------------------------
;
;  PROCEDURE SeedFill(srcPtr,dstPtr: Ptr;
;			  srcRow,dstRow,height,words: INTEGER;
;			  seedH,seedV: INTEGER)
;
		MOVE.L	(SP)+,A0				;pop return addr
		MOVEQ	#-1,D0					;get a long of -1
		MOVE.L	D0,-(SP)				;push edge = all ones
		BRA.S	SHARE					;share common code


;-------------------------------------------------------------------------
;
;  PROCEDURE CalcMask(srcPtr,dstPtr: Ptr;
;			  srcRow,dstRow,height,words: INTEGER);
;
CalcMask MOVE.L   (SP)+,A0			  ;pop return addr
		 MOVEQ	  #-1,D0			  ;get a long of -1
		 MOVE.L   D0,-(SP)			  ;push seed = (-1,-1)
		 CLR.L	  -(SP) 			  ;push edge = zeros
SHARE	 MOVE.L   A0,-(SP)			  ;restore return addr



;-------------------------------------------------------------------------
;
;  LOCAL PROCEDURE MakeMask(srcPtr,dstPtr: Ptr;
;				srcRow,dstRow,height,words: INTEGER;
;				seedH,seedV: INTEGER;
;				edge: LongInt);
;
;  A6 OFFSETS OF PARAMS AND LOCALS AFTER LINK:
;
PARAMSIZE		EQU 	24
srcPtr			EQU 	PARAMSIZE+8-4		;long
dstPtr			EQU 	srcPtr-4			;long
srcRow			EQU 	dstPtr-2			;word
dstRow			EQU 	srcRow-2			;word
height			EQU 	dstRow-2			;word
words			EQU 	height-2			;word
seedH			EQU 	words-2 			;word
seedV			EQU 	seedH-2 			;word
edge			EQU 	seedV-4 			;long


dstBump 		EQU 	-2					;word
saveStk 		EQU 	dstBump-4			;long
varSize 		EQU 	saveStk 			;total locals


		LINK	A6,#varSize 				;allocate stack frame
		MOVEM.L D3-D7/A2-A4,-(SP)			;save regs
		MOVE.L	SP,saveStk(A6)				;save stack pointer

;
;  prepare height and words for DBRA count.  Quit if either <= 0.
;
		MOVE	words(A6),D5				;get count of words
		BLE 	GOHOME						;quit if words <= 0
		SUB 	#1,D5						;subtract 1 for DBRA count
		SUB 	#1,height(A6)				;convert height to DBRA
		BLT 	GOHOME						;quit if height <= 0

;
;  init dst to all ones:
;
		MOVE	words(A6),D0				;get # of words
		ADD 	D0,D0						;double for bytes
		MOVE	dstRow(A6),D1				;get dstRow
		SUB 	D0,D1						;subtract bytes for dstBump
		MOVE	D1,dstBump(A6)				;save dstBump for later
		MOVE.L	dstPtr(A6),A2				;point to dst
		MOVEQ	#-1,D0						;get some black
		MOVE	height(A6),D3				;init DBRA rowCount
BLACK1	MOVE	D5,D2						;init DBRA wordCount
BLACK2	MOVE	D0,(A2)+					;put a word of black
		DBRA	D2,BLACK2					;loop all words in row
		ADD 	D1,A2						;bump to next row
		DBRA	D3,BLACK1					;loop height rows

;
;  clear one dst pixel at seedH,seedV
;
		MOVE	seedV(A6),D0				;get seed vert coord
		BLT.S	NOSEED						;skip if neg (no seed)
		MULU	dstRow(A6),D0				;mul times dst row
		MOVE.L	dstPtr(A6),A0				;point to dst
		ADD.L	D0,A0						;add vertical offset	<EHB 28-Oct-85>
		MOVE	seedH(A6),D0				;get seed horiz coord
		MOVE	D0,D1						;copy seedH
		ASR 	#3,D0						;div by 8 for byte
		NOT 	D1							;invert bit number
		BCLR	D1,0(A0,D0) 				;clear seed pixel
NOSEED
;
;  allocate a scanline buffer of ones or zeros on the stack:
;
		MOVE.L	edge(A6),D6 				;get zero or all ones
		MOVE	D5,D1						;get longCount
NEXTBUF MOVE	D6,-(SP)					;write a word of ones or zeros
		DBRA	D1,NEXTBUF					;loop all words

		MOVE.L	srcPtr(A6),A0				;point to top of src
		MOVE.L	dstPtr(A6),A2				;point to top of dst
		st		d7							;set dirty flag to force	<KON 24JAN91>
;		bra.s	FirstPass					;search up and down			<KON 24JAN91>
;NXTPASS SF		D7							;clear dirty flag
FirstPass
		jmpROM	ROMSeedFill
GoHome
		jmpROM	ROMGoHome
		ENDPROC


; ---------------------------------------------------------------------------

		INCLUDE	'DrawPicture32Patch.a'
		
; ---------------------------------------------------------------------------

		ROMs		Plus,SE,Portable

JShowCursor		EQU		$0804					;this shouldn't be here

		MakePatch	CalcMask,$A838			; CalcMask and SeedFill need to 	<KON 24JAN91>
		MakePatch	SeedFill,$A839			; always scan up as well as down	<KON 24JAN91>
		MakePatch	StretchBits, $AB27
		MakePatch	PatchShowCursor, JShowCursor
		MakePatch	PatchStdRect, $A8A0
		MakePatch	PatchStdLine, $A890
		MakePatch	PatchStdRRect, $A8AF
		MakePatch	PatchStdOval, $A8B6
		MakePatch	PatchStdArc, $A8BD
		MakePatch	PatchStdComment, $A8F1

		MakePatch	NewStdGetPic, $A8EE
		MakePatch	PatchOpenPicture, $A8F3
		MakePatch	PatchClosePicture, $A8F4
		MakePatch	GetPMData, $ABC4
		MakePatch	OpenCPicture, $AA20
		MakePatch	QDExtDispatcher, $AB1D
		MakePatch	VisRgnChanged, $A0A5, (Plus,SE,Portable,II,IIci)

		MakePatch	PatchStdBits, $A8EB			;used to be Plus, SE only

;
; RGBForeColor, RGBBackColor, GetForeColor, GetBackColor, and QDError
;
		MakePatch	RGBForeColor, $AA14
		MakePatch	RGBBackColor, $AA15
		MakePatch	GetForeColor, $AA19
		MakePatch	GetBackColor, $AA1A
		MakePatch	QDError, $AA40

; ---------------------------------------------------------------------------

		ROMs		Plus, SE

		MakePatch	PicItemPlusSE, $AB9A
		MakePatch	PatchStdPoly, $A8C5
		MakePatch	BitMapRgnptch, $A8D7
		MakePatch	PlusSEDrawPicture, $A8f6

		ROMs		Portable, SE
		MakePatch	PatchStdRgnSEPortable, $A8D1

		ROMs		Plus
		MakePatch	PatchStdRgnPlus, $A8D1
; ---------------------------------------------------------------------------

		ROMs		Portable
		MakePatch	PicItemPortable, $AB9A
		MakePatch	PortablePatchStdPoly, $A8C5
		MakePatch	PortableDrawPicture, $A8f6

; ---------------------------------------------------------------------------

				END
