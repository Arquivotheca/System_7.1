;EASE$$$ READ ONLY COPY of file “PaletteMgrPatch.a”; 1.0	BAL 11/19/1989 Changed name to avoid conflicts between system 6.0 and;		ROM/32-Bit QD versions.;  --  Revisions Of PaletteMgr.a Below  --; 1.5	SES 08/28/1989  Removed references to nFiles. Updated equates accordingly.; 1.4	BAL 06/26/1989 dvb For 6.0.4 Moved grayrgn test into initpalettes, removed initmenus; 1.3	BAL 06/12/1989 Altered patch to InitMenus to check grayRgn before calling _InitPalettes;•1.2	CEL 06/10/1989 Moved Private.a QuickDraw Equates into proper QuickDraw;		private file (colorequ.a), got rid of QuickDraw nFiles dependencies;		and fixed up necessary files…;•1.1	CCH 11/16/1988 Updated to newest version.;;_______________________________________________________________________________________; File: PaletteMgr.a;; Version 6.0.1;; Copyright 1987-1988 Apple Computer, Inc. All Rights Reserved;;_______________________________________________________________________________________;; modification history;; <02feb87>		 	AWC		new this date; <26mar87>	PB103	AWC		non-window manager version completed; <27mar87>			AWC		interface changed to support window manager; <27mar87>			EHB		window manager calls added; <29mar87> PB150   AWC     fixed nil pointers (RGBForeColor) and added WindowCopy; <30mar87> 		AWC/EHB background updates, ExitToShell fix, System Palette; <30Mar87>			JTC		Daisy chain the IAZInit routine properly.; <15Jul87>			AWC/FJL	SetPalette(Ptr(-1),...), Menu fix, update problems; <20Jul87> PB212	DAF		Removed GetNewCWindow portion of NewCWindow fix.  Changed;							myDisposeWindow to fix CloseWindow.  ; <22Jul87> PB221	AWC		fix to crash when there are no menus (see note @PB225); <22Jul87> PB222	AWC		CopyPalette implemented (see note @PB225); <22Jul87> PB223	AWC		fix to bug causing too many updates (see note @PB225); <22Jul87> PB224	AWC		added support for Juggler (see note @PB225); <22Jul87> PB225	AWC		NewPWindow implemented; NOTE: fixes PB221 through PB225;							were all added at once.  They are unique numbers solely;							for bureaucratic reasons.; <12Aug87> C864	RWH		Added ROMPaletteMgr Conditional flag (its defined outside this file;							in order to make Rom78Fix build work). Conditional-ed out calls;							at end of this file so it can be put in ROM.  Search for ;!!!!!;							Made ReDrawMenuBar an RTS for the ROM version.  Made the call to;							SortPoints use the macro from QDHooks.a.  ; <01Sep87> PB259	AWC		Fixed NewPWindow so it doesn't polymerize the stack.; 			C872			Same as PB259; <04Sep87> PB262	AWC		Fixed ActivatePalette to generate fewer color updates;			C886			Same as PB262; <16Nov87> PB302	AGH		Made changes for use with A/UX toolbox.; <01Feb88> PB377	AWC		Fixed 5 minor bugs in the Palette Manager (1st entry bug, screen;							dev. bug, D0 error bugs, protection bits bugs, PmBackColor/explicit;							bug); <02Feb88> PB378	AWC		Oops, I forgot one.  The 16th palette causes a crash...; <12Feb88>	PB392	AWC		Fixed a fix which short circuits the menu bar update code.; <23Mar88> PB438	DAF		Removed InitWindows fix, since it wasn't installed anyway.; <24Mar88>	PB439	AWC		Fixed SetPalette; removed pmWindow references; <07Apr88> PB457	AWC		Fixed ColorMore crash, implemented AppPalette, DisposeBit; <08Apr88>	PB462	AWC		Fixed lines out of order bug created in PB459; <18Apr88>	PB469	AWC		Blocked InitGraf from using the system resource file; <26Apr88>	PB480	AWC		Fixed PaletteMgr updates, animation of black, and set Palettes NoPurge; <29Apr88> PB485   AWC     Blocked spurious ActivatePalette's by checking wHilited; <13Jun88> PB500	AWC		Fixed AnimateEntry; made Palette Manager active even if;							no 'clut' devices are present; <17Jun88> PB506	AWC		Moved InitGraf fix to InitMenus; IAZNotify routine clears WindowList; <22Jun88> PB508	AWC		Added MenuBar updates and SingleFinder Desktop updates; made routines;							draw using the AppPalette; added DirtySeeds to correct update problem;;							blocked InitMenus from initializing AppPalette twice; now clear;							AppPalette in the event that its palette is disposed; <27Jun88>	PB520	AWC		Save grafPort across PaintOne; put InitMenus stuff into InitPalettes;;							removed NewPWindow (which was never publicized); generally cleaned;							things up for the ROM version.  Fixed unlocked handle in PmForeColor.; <12Jul88>	PB530	AWC		Fixed CopyPalette resize problem; changed behavior of explicit;							colors on direct devices;;___________________________________________________________________________XPalettes	PROC	EXPORT			; dummy procedure; return to globals			AWC.PB457			ENDPROC					;												AWC.PB457AppPalette	Equ		$DCC			; low memory global for layer palette			AWC.PB457UpdateMask	Equ		$E000			; bits used to record update flags in pmPrivate	AWC.PB457AllUpdates	Equ		$C000			; combination of CForeBit and CBackBIt			AWC.PB457plttUpdates	Equ		$0002			; value passed to SetPalette [short]			AWC.PB457; Here is what is left of the Patch Collator stuff.  The Palette Manager routines have never; been patches to the ROM - they were never in the original ROM, so there was nothing to; patch.  This is all there is.  The window manager patches are shown below and are marked; near the routine with another patch signal.  To find one, double click on the Patch Name; and search for that (Command-H under MPW 2.0).;;					File			Date		Patch#	PMgr Routines		Trap#;AppleSystemPatch 	PaletteMgr.a	10Mar87		#PB103	(InitPalettes)		$AA90;AppleSystemPatch 	PaletteMgr.a	10Mar87		#PB103	(NewPalette)		$AA91;AppleSystemPatch 	PaletteMgr.a	10Mar87		#PB103	(GetNewPalette)		$AA92;AppleSystemPatch 	PaletteMgr.a	10Mar87		#PB103	(DisposePalette)	$AA93;AppleSystemPatch 	PaletteMgr.a	10Mar87		#PB103	(ActivatePalette)	$AA94;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(SetPalette)		$AA95;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(GetPalette)		$AA96;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(PmForeColor)		$AA97;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(PmBackColor)		$AA98;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(AnimateEntry)		$AA99;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(AnimatePalette)	$AA9A;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(GetEntryColor)		$AA9B;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(SetEntryColor)		$AA9C;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(GetEntryUsage)		$AA9D;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(SetEntryUsage)		$AA9E;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(CTab2Palette)		$AA9F;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103	(Palette2CTab)		$AAA0;AppleSystemPatch 	PaletteMgr.a 	22Jul87		#PB222	(CopyPalette)		$AAA1;;					Fix File		Date		Patch#	Fixed Routines		Patch Routine Name;AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(RGBForeColor) 		(RGBForeColor);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(RGBBackColor) 		(RGBBackColor);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB506 	(InitMenus) 		(myInitMenus);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(NewCWindow) 		(myNewCWindow);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(NewWindow) 		(myNewWindow);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(HiliteWindow) 		(myHiliteWindow);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(MoveWindow) 		(myMoveWindow);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(SizeWindow) 		(mySizeWindow);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(CloseWindow) 		(myClose);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(ShowHide) 			(myShowHide);AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(MyExit) 			(myExit);;	Another routine which must be included for proper Palette Manager operation is;	GetNewCWindow which is patched in PatchIIROM.a;---------------------------------------------------;; PROCEDURE	InitPalettes; INLINE $AA90;;InitPalettes	PROC	EXPORT				IMPORT	RecordPaletteVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L D3-D4/A2-A4,-(SP) 		; save registers			moveq	#-1,d0					; get a useful value						<1.3>			cmp.l	grayRgn,d0				; has it been initialized?					<1.3>			beq		goHome					; no, don't call the brinker				<1.3>; Start by running down the device list, finding all active CLUT devices.  Count how many; there are and record them in PListHandle.			Move.L	PMgrHandle,D0			; get the Palette Manager handle			Cmp.L	#PMgrNil,D0				; is it nil?			Bne		ChkAppPltt				; we're initializaed - check for AppPalette	AWC.PB520; To start things up, allocate enough room for static Palette Manager data and 32 device table; slots.  Note that the current implementation of Color Quickdraw (not the architecture) sets; a limit on the color index model of 256 entries.  THIS NUMBER IS ASSUMED BY THE CODE BELOW,; but the structure will allow modification once 'clut's bigger than 256 entries are allowed.; This code also assumes that the cards have the potential of being 256 entry cards even if; set at a lower resolution, so it always allocates 256 entries in each device map (integer sized).; Note - the total space allocated for pm device table space is presumed (below) to; be long word aligned.  See the loop below at Clearing.			Move.L	#PMgrDataSz,D4			; set D4 to the required size				AWC.PB500			Move.L	D4,D0					; copy size to D0			_NewHandle ,SYS,CLEAR			; allocate our data area in the system heap			Bne		GoHome					; we got an error, so we quit			Move.L	A0,A3					; copy to A3 for later use			Move.L	A0,PMgrHandle			; and remember it in low memory			MoveQ	#0,D3					; zero our device count			Move.L	(A3),A4					; dereference PMgrHandle			AddA	#DevHandles,A4			; point A4 at our local device list			Clr.L	-(SP)					; push room for device handle				AWC.PB500			_GetDeviceList					; get the start of the device list			AWC.PB500			Move.L	(SP)+,A2				; put the device list in A2					AWC.PB500			Bra.S	DeviceEnd				; jump to the end of the loop				AWC.PB500DeviceLoop	Move.L	(A2),A0					; dereference device handle			Move	gdFlags(A0),D0			; get flags; is it an active device?			Bpl.S	NextDevice				; no => examine next device			BTst	#ScreenDevice,D0		; is it a screen device?			Beq.S	NextDevice				; no => examine next device					AWC.PB377			Move	gdType(A0),D0			; get the type of the device				AWC.PB377			Cmp		#ClutType,D0			; is it a Clut device?			Bne.S	NextDevice				; no => we only track Clut devices			AddQ	#1,D3					; yes => bump our device count by 1			Move.L	A2,DevHandle(A4)		; copy device handle						AWC.PB500			Clr.L	DevFrontMost(A4)		; clear device FrontMost field			AddQ	#DevInfoSz,A4			; bump A4 to the next device slot			Add.L	#256*PmDevSz,D4			; each device table is 1024 bytes (for now)			Cmp		#DevLimit,D3			; are we at the limit the PMgr can handle?	AWC.PB500			Bpl.S	EnoughDevs				; if so, we'll ignore any remaining devicesNextDevice	Move.L	gdNextGD(A0),A2			; grab next device							AWC.PB500DeviceEnd	Move.L	A2,D0					; CmpA #Nil,A2; is it nil?					AWC.PB500			Bne.S	DeviceLoop				; no => let's do it againEnoughDevs	Move.L	(A3),A4					; redereference PMgrHandle			Move	D3,nDevs(A4)			; save length of device list			Move	D3,D0					; make a copy of D3			Bne.S	SeedSizeOk				; make sure we have a minimum size seed		AWC.PB500			AddQ	#1,D0					; a kludge, but it's easier this way		AWC.PB500SeedSizeOk	Lsl		#2,D0					; multiply by 4								AWC.PB500			Move	D0,SeedHSize(A4)		; save size of SeedHSize handle			Clr		APalettes(A4)			; no animating palettes yet			Move	#ListSpace,FreeSpaces(A4)	; 16 free slots; we'll add more if needed			Move.L	D4,D0					; D4 is the required size of PMgrHandle			Move.L	A3,A0					; put handle in A0 for the call			_SetHandleSize					; and expand the handle up			Bne.S	ResizeFails				; it went badly			Move.L	#ListSpace,D0			; start with initial space for handles			Lsl 	#3,D0					; multiply by 8			_NewHandle SYS,CLEAR			; allocate and clear the handle			Beq.S	ClearAll				; if it works, continue			Move.L	A3,A0					; prepare to dispose the handle			_DisposHandle					; get rid of it			ResizeFails	Move.L	#PMgrNil,PMgrHandle		; it didn't work - zero the handle			Bra		GoHome					; head home with error in D0				AWC.PB508ClearAll	Move.L	(A3),A4					; redereference PMgrHandle			Move.L	A0,PListHandle(A4)		; save the list of handles			Move.L	A3,A0					; put PMgrHandle into A0			_HLock							; lock it down			Move	D3,D0					; get the number of devices			Lsl		#8,D0					; multiply by 1024/4 (1024 per device/4 per CLR.L)			Lea		PMgrDataSz(A4),A0		; calculate start of device links			Bra.S	ClearEnd				; jump into loopClearLoop	Clr.L	(A0)+					; clear a long word - see! long word alignedClearEnd	DBra	D0,ClearLoop			; repeat for all long words			Move.L	theZone,-(SP)			; save the current zone			Move.L	SysZone,theZone			; set the system zone			Clr.L	-(SP)					; clear some space for a handle			Clr		-(SP)					; push PaletteId = 0			_GetNewPalette					; try to get the system palette			Move.L	(SP)+,SysPalette(A4)	; save it; was it nil?			Bne.S	NoError					; no => we're done			Lea		SysColors,A0			; get a pointer to our default table			Move.L	#17*8,D0				; get size			_PtrToHand						; make a handle out of it			Move.L	A0,D3					; save it			Clr.L	-(SP)					; space for result			Move	#16,-(SP)				; push the number of entries			Move.L	A0,-(SP)				; push our handle			Move	#pmTolerant,-(SP)		; all tolerant entries			Move	#$4000,-(SP)			; reasonably tolerant entries, too			_NewPalette						; let's call ourselves to get a new palette			Move.L	(SP)+,SysPalette(A4)	; save the palette; we sure hope we got one			Move.L	D3,A0					; put handle back in A0			_DisposHandle					; snuff itNoError		Move.L	SysPalette(A4),A0			; get the palette for a moment			CmpA.L	#Nil,A0						; is there one?			Beq.S	Cleanup						; no => cleanup			Move.L	(A0),A0						; dereference SysPalette			BSet	#CForeBit,pmPrivate(A0)		; set the system update bits			BSet	#CBackBit,PmPrivate(A0)Cleanup		Move.L	(SP)+,theZone				; restore the current zone			Move.L	A3,A0						; get PMgrHandle			_HUnlock							; unlock it			Clr.L	AppPalette					; clear the applications's palette		AWC.PB457			Bra.S	LookForIt					; jump ahead							AWC.PB520			;	Notice that we rely upon AppPalette being initialized (or -1) every time we arrive here.  If;	it is non-zero, we assume this is an extra call to InitPalettes so we just leave.ChkAppPltt	Move.L	AppPalette,D0			; fetch AppPalette; is it nil?				AWC.PB520			Beq.S	LookForIt				; yes => look for a palette resource 0		AWC.PB508			AddQ.L	#1,D0					; bump it by 1; was it $FFFFFFFF?			AWC.PB508			Bne.S	GoHome					; no => must be good; abort					AWC.PB520			Move.L	D0,AppPalette			; clear the AppPalette						AWC.PB508LookForIt	Tst		CurApRefNum				; are we using the system resource file?	AWC.PB469			Beq.S	GoHome					; yes => forget installing an AppPalette	AWC.PB520			Clr		-(SP)					; function result							AWC.PB457			_CurResFile						; get the current resfile					AWC.PB457			Move	(SP)+,D3				; put it in D3								AWC.PB457			Cmp		CurApRefNum,D3			; need we change it?						AWC.PB457			Beq.S	ResFileOkay				; no => we've already got it				AWC.PB457			Move	CurApRefNum,-(SP)		; push the refnum back						AWC.PB457			_UseResFile						; use this resfile							AWC.PB457			Clr		-(SP)					; result word								AWC.PB506			_ResError						; see if this worked						AWC.PB506			Move	(SP)+,D0				; get the result							AWC.PB506			Bne.S	GoHome					; quit if we didn't get it					AWC.PB520ResFileOkay	Clr.L	-(SP)					; function result							AWC.PB457			Move.L	#'pltt',-(SP)			; push the resource type					AWC.PB457			Clr		-(SP)					; id 0										AWC.PB457			_Get1Resource					; fetch an application palette, if any		AWC.PB457			Move.L	(SP)+,A2			 	; get handle off the stack					AWC.PB457			Move.L	A2,D0					; CmpA.L #Nil,A2; did we get a resource?	AWC.PB457			Beq.S	Cleanup2			 	; if nil we go home							AWC.PB457			Move.L	A2,-(SP)				; push it for the DetachResource			AWC.PB457			_DetachResource 				; disconnect from resource manager			AWC.PB457			Move.L	(A2),A0					; dereference palette						AWC.PB457			Move	#AllUpdates,D1			; set D1 to the default						AWC.PB457			Move	plttUpdates(A0),D0		; get update bits							AWC.PB457			Bpl.S	NoResUpdate				; the user didn't specify any				AWC.PB457			Lsl		#1,D0					; put the bits in the correct place			AWC.PB457			Move	D0,D1					; put the result into D1					AWC.PB457NoResUpdate	Move	D1,pmPrivate(A0)		; put them in the correct place				AWC.PB457			Move.L	A2,-(SP)				; push palette for the RecordPalette		AWC.PB457			Jsr		RecordPalette			; allocates seeds handle, records palette	AWC.PB457			Bne.S	Cleanup2				; it disposed palette if failed				AWC.PB457			Move.L	A2,AppPalette			; copy it to AppPalette						AWC.PB457			Move.L	(A2),A0					; dereference AppPalette					AWC.PB457			BSet	#DisposeBit,pmPrivate(A0)	; set for automatic disposal			AWC.PB457			Clr.L	pmWindow(A0)			; clear the window field just for grins		AWC.PB457			Clr.L	pmDevices(A0)			; clear device bitmap						AWC.PB457Cleanup2	Cmp		CurApRefNum,D3			; did we change the current resfile?		AWC.PB457			Beq.S	GoHome					; no => don't put it back					AWC.PB457			Move	D3,-(SP)				; push the old current resfile				AWC.PB457			_UseResFile						; and restore the old one					AWC.PB457GoHome		MoveM.L (SP)+,D3-D4/A2-A4 			; restore registers			Unlk	A6							; clear stack frame			Rts									; go homeSysColors	DC.W	$0000,$0003,$0000,$000F	; seed [long], transIndex [word], ctSize [word]			DC.W	$0000,$FFFF,$FFFF,$FFFF	; white			DC.W	$0001,$0000,$0000,$0000	; black			DC.W	$0002,$C000,$C000,$C000	; light gray			DC.W	$0003,$8000,$8000,$8000	; medium gray			DC.W	$0004,$4000,$4000,$4000	; dark gray			DC.W	$0005,$DD6B,$08C2,$06A2	; Apple red			DC.W	$0006,$FFFF,$648A,$028C	; Apple orange			DC.W	$0007,$FC00,$F37D,$052F	; Apple yellow			DC.W	$0008,$1F21,$B793,$1431	; Apple green			DC.W	$0009,$0000,$0000,$D400	; Apple blue			DC.W	$000A,$46E3,$0000,$A53E	; Apple violet			DC.W	$000B,$F2D7,$0856,$84EC	;			DC.W	$000C,$90D7,$7160,$3A34	;			DC.W	$000D,$0241,$AB54,$EAFF	;			DC.W	$000E,$0000,$64AF,$11B0	;			DC.W	$000F,$5600,$2C9D,$0524	;SysColorEnd			;---------------------------------------------------;; PROCEDURE	RecordPalette(myPalette: PaletteHandle); LOCAL;;;	Copies myPalette into the PListHandle and records (in the pmPrivate field) where;	it lies in that list.  If there are no free spaces in the PListHandle then that;	handle is resized.  If it can't be resized, RecordPalette returns an error in D0.;	Otherwise a new handle is allocated for myPalette's pmSeeds field.  If one can't;	be allocated, RecordPalette returns an error.  It will also return an error if the;	PMgrHandle is nil.  If RecordPalette returns an error, it first disposes of;	myPalette so the caller doesn't have to worry about watching the error code.RecordPalette	PROC	EXPORTParamSize	equ		4						; total bytes of paramsmyPalette	equ		ParamSize+8-4			; source Palette handleVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L D3/A2-A4,-(SP) 			; save registers			Move.L	myPalette(A6),A4		; get my palette first in case we branch to Error			Move.L	PMgrHandle,A2			; get the PMgrHandle			CmpA.L	#PMgrNil,A2				; has it been initialized?			Beq		Error					; no => handle the error (.S won't reach)			Move.L	(A2),A0					; dereference the PMgrHandle			Move.L	PListHandle(A0),A3		; get the handle to the list of palettes			MoveQ	#0,D0					; clear high word			Move	SeedHSize(A0),D0		; get length of seeds handles			_NewHandle ,CLEAR				; allocate it; did we succeed?			Bne		Error					; no => handle the error (.S won't reach)			Move.L	(A4),A1					; dereference myPalette			Move.L	A0,pmSeeds(A1)			; store the seeds handle in it			Move.L	(A2),A1					; redereference the PMgrHandle			Move	FreeSpaces(A1),D0		; get number of free slots; are any left?			Bne.S	FindOne					; yes => don't resize it; search for a free one			MoveQ	#0,D3					; clear high word			Move	APalettes(A1),D3		; get current size			Move.L	D3,D0					; copy it			Add		#ListSpace,D0			; bump it to add more room			Bmi.S	Error					; return an error if it wraps			Lsl.L	#3,D0					; multiply by 8			Move.L	A3,A0					; copy PListHandle to A0			_SetHandleSize					; resize it			Bne.S	Error					; we couldn't do it; Now we have to clear all of the new entries we just created.			Move.L	A3,A0						; get PListHandle			Move.L	(A0),A0						; redereference this			Lea		(A0,D3.W*8),A0				; point us at the block to clear			Move.L	#ListSpace,D0				; get how many entries to clear			Bra.S	ClearEnd					; jump into loopClearLoop	Clr.L	(A0)+						; clear the Palette field			Clr.L	(A0)+						; clear the animation fieldClearEnd	DBra	D0,ClearLoop				; loop for ListSpace entries						AddQ	#1,D3						; D3 is palette's position in PListHandle			Move.L	(A3),A0						; dereference PListHandle			Lea		(A0,D3.W*8),A0				; point A0 at the current position			Move.L	(A2),A1						; redereference the PMgrHandle			Move	#ListSpace-1,FreeSpaces(A1)	; number of spaces we've added		AWC.PB378			Bra.S	Cleanup						; share common code; We have a free one somewhere in the list.  Search forwards until we find one we can use.; A1 is still pointing at the dereferenced PMgrHandle.FindOne		Move	APalettes(A1),D0		; get number of active handles			Add		FreeSpaces(A1),D0		; calculate total number of entries			MoveQ	#0,D3					; initialize our counter			Move.L	(A3),A0					; dereference PListHandle			Bra.S	FindEnd					; jump into loopFindLoop	Move.L	PaletteRef(A0),D1		; get first entry			Beq.S	FoundIt					; we've got one			AddQ	#PLstEntrySz,A0			; bump to the next entry			AddQ	#1,D3					; bump our counterFindEnd		DBra	D0,FindLoop				; repeat for all spaces			Bra.S	Error					; this should not happen			; when we reach this section of common code, A1 = PMgrHandle^, D3 is the position of; the palette, and A0 points to PListHandle^^[D3]FoundIt		SubQ	#1,FreeSpaces(A1)		; decrement the number freeCleanup		AddQ	#1,APalettes(A1)		; bump the number used			Move.L	A4,PaletteRef(A0)		; record the palette handle in PListHandle			Clr.L	Reserves(A0)			; clear the number of entries it reserves			Move.L	(A4),A0					; dereference the Palette			Move	pmPrivate(A0),D0		; grab the current update values			AWC.PB457			And		#UpdateMask,D0			; clear away all but the update bits		AWC.PB457			Or		D0,D3					; OR palette number with the update bits	AWC.PB457			Move	D3,pmPrivate(A0)		; this is the number of the palette			MoveQ	#0,D0					; no error			Bra.S	GoHome					; we're done-oh!			Error		Move.L	A4,A0					; get Palette handle			_DisposHandle					; get rid of it			MoveQ	#1,D0					; set an errorGoHome		Tst.L	D0						; set condition codes for return			MoveM.L (SP)+,D3/A2-A4 			; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; FUNCTION	NewPalette(entries: INTEGER; srcColors: CTabHandle; srcUsage,srcTolerance:;	INTEGER) : PaletteHandle; INLINE $AA91;;;	Allocate a new palette and fill it with information from myColors.  Set the usage;	field of each ciInfo to myUsage and set the tolerance to myTolerance.  If myColors;	is nil we initialize all the colors to black.NewPalette	FUNC  EXPORTParamSize		equ		10					; total bytes of paramsPalette			equ		ParamSize+12-4		; function resultentries			equ		Palette-2			; number of entries in PalettesrcColors		equ		entries-4			; Color table handlesrcUsage		equ		srcColors-2			; default usage for each color in PalettesrcTolerance	equ		srcUsage-2			; default tolerance for each color in PaletteVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L D3/A2,-(SP) 			; save registers			Clr.L	Palette(A6)				; set the result to nil			Move	entries(A6),D3			; fetch number of entries			MoveQ	#0,D0					; clear it out			Move	D3,D0					; copy it for a calculation			AddQ	#1,D0					; add one for the header			Lsl.L	#4,D0					; multiply by 16			_NewHandle ,CLEAR				; get the handle; did we get an error?			Bne.S	GoHome					; yes => we're done for			Move.L	A0,A2					; no => save the handle			Move.L	A2,-(SP)				; push handle			Jsr		RecordPalette			; allocates a seed's handle and records palette			Bne.S	GoHome					; it disposed the palette handle if it failed; A2 contains the handle to the new Palette.  Return the handle, then start by dereferencing it.; For now we'll just clear everything.  Note that we're making use of the fact that; the size of the header is the same as an entry itself, so we can fall straight; into the DBra and expect it to clear Entries+1 records!  Also, zero the window field; so we know that this palette is floating			Move.L	A2,Palette(A6)				; return the result			Move.L	(A2),A0						; dereference Palette handle			Move	D3,pmEntries(A0)			; copy pmEntries			Clr.L	pmWindow(A0)				; zero the window field			Move	D3,D0						; get entries into D0			Move	srcUsage(A6),D1				; copy usage to D1			Swap	D1							; put usage into high word			Move	srcTolerance(A6),D1			; put tolerance into low word			Lea		pmInfo+ciUsage(A0),A0		; point A0 at first ColorInfo			Bra.S	EntryEnd					; jump into the loop			EntryLoop	Move.L	D1,(A0)					; set ciUsage (high word) and ciTolerance (low word)			AddA	#ciSize,A0				; bump A0 to the next ciUsage fieldEntryEnd	Dbra	D0,EntryLoop			; loop for all entries			Move.L	srcColors(A6),A1		; get ctabhandle			CmpA.L	#Nil,A1					; is it nil?			Beq.S	NoCTab					; yes => skip the copy			Move.L	(A1),A1					; dereference the source color table			Move	ctSize(A1),D0			; get last color table entry			AddQ	#1,D0					; make it number of entries; is it >= 1?			Ble.S	NoCTab					; no => we're done						Move.L	(A2),A0					; redereference PaletteHandle			AddA.L	#pmInfo+ciRGB+red,A0	; bump A0 to pmInfo.ciRGB.red			AddA.L	#ctTable+rgb+red,A1		; bump A1 to ctTable.red; put min(ctSize+1,pmEntries) into D0			Cmp		D0,D3					; compare color table size to palette size			Bge.S	UseAsIs					; if D0 is less than D3, we'll use it as is			Move	D3,D0					; copy the lower value into D0UseAsIs		MoveQ	#0,D1					; D1 points at this entry			Bra.S	CopyEnd					; jump into loopCopyLoop	Move.L	red(A1),red(A0)			; copy red and green			Move	blue(A1),blue(A0)		; copy blue			AddQ.L	#ColorSpecSize,A1		; bump A1 to next ColorSpec			AddA.L	#ciSize,A0				; bump A0 to next ColorInfoCopyEnd		Dbra	D0,CopyLoop				; loop until the copy is completeNoCTab		MoveQ	#0,D0					; no errorGoHome		MoveM.L (SP)+,D3/A2 			; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; FUNCTION GetNewPalette(paletteID: INTEGER) : PaletteHandle; INLINE $AA92;;; GetNewPalette gets a resource of type 'pltt' with the specified ID and clears; all the private fields.  It then returns the data structure as a PaletteHandle.;GetNewPalette	FUNC	EXPORTParamSize	equ		2						; total bytes of paramsPalette		equ		ParamSize+12-4			; function resultpaletteID	equ		Palette-2				; number of entries in PaletteVarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	A2,-(SP)				; save registers			Clr.L	Palette(A6) 			; set result to Nil			; Load the data and detach it from resource manager								Clr.L	-(SP)					; make space for result			Move.L	#'pltt',-(SP)			; push resource type			Move	paletteID(A6),-(SP)		; push resource ID			_GetResource 					; get the resource			Move.L	(SP)+,D1			 	; get handle off the stack			Beq.S	GoHome				 	; if nil we go home			Move.L	D1,A2					; copy it to A2			Move.L	D1,-(SP)				; push it back on the stack			_DetachResource 				; disconnect from resource manager						Move.L	A2,A0					; copy it for the HNoPurge					AWC.PB480			_HNoPurge						; we can't handle purged palettes			AWC.PB480			Tst		D0						; did it return an error?					AWC.PB480			Bne.S	GoHome					; yes => go home							AWC.PB480			Move.L	(A2),A0					; dereference palette						AWC.PB457			Move	#AllUpdates,D1			; set D1 to the default						AWC.PB457			Move	plttUpdates(A0),D0		; get update bits							AWC.PB457			Bpl.S	NoResUpdate				; the user didn't specify any				AWC.PB457			Lsl		#1,D0					; put the bits in the correct place			AWC.PB457			Move	D0,D1					; put the result into D1					AWC.PB457NoResUpdate	Move	D1,pmPrivate(A0)		; put them in the correct place				AWC.PB457			Move.L	A2,-(SP)				; push the handle			Jsr		RecordPalette			; allocates a seeds handle and records palette			Bne.S	GoHome					; it disposed the palette handle if it failed			Move.L	A2,Palette(A6)			; save Palette in result space; clear the window field and also the private fields			Move.L	(A2),A2						; dereference it			Clr.L	pmWindow(A2)				; set window field; this palette floats			Clr.L	pmDevices(A2)				; clear device bitmapGoHome		Move.L	(SP)+,A2					; restore registers			Unlk	A6							; clear stack frame			Rtd		#ParamSize					; strip parameters and go home				;---------------------------------------------------;; PROCEDURE	ClearPalette(cPalette: PaletteHandle); LOCAL;;ClearPalette	PROC	EXPORTParamSize	equ		4						; total bytes of paramscPalette	equ		ParamSize+8-4			; source Palette handleVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L D2-D3/A2-A4,-(SP) 		; save registers			Move.L	PMgrHandle,A3			; get palette manager handle			CmpA.L	#PMgrNil,A3				; are we initialized?			Beq		GoHome					; no => quit				AWC.PB377			Move.L	(A3),A3					; dereference it			Move.L	cPalette(A6),A1			; get palette handle						AWC.PB457			Move.L	(A1),A2					; dereference it							AWC.PB457; Examine and remember the number of reserves this palette still has.  Clear the number.			Move	pmPrivate(A2),D0		; get the number of this palette			And		#PIdMask,D0				; clear away update bits			Move.L	PListHandle(A3),A0		; get the palette list handle			Move.L	(A0),A0					; dereference it			CmpA.L	PaletteRef(A0,D0.W*8),A1	; is this the correct handle?			AWC.PB462			Bne		BadPalette					; no => don't dispose anything			AWC.PB462			Move	Reserves(A0,D0.W*8),D3	; remember how many animating entries it has			Clr.L	Reserves(A0,D0.W*8)		; clear the count; Now clear each of the seeds this palette knows about, so that we'll update if we; become active again.			Clr.L	pmDevices(A2)			; clear devices field			Move.L	pmSeeds(A2),A0			; get seeds handle			Move.L	(A0),A0					; dereference it			Move	SeedHSize(A3),D0		; get size of handle			Lsr		#2,D0					; divide by 4			Bra.S	SeedEnd					; start clear loopSeedLoop	Clr.L	(A0)+					; clear the remembered seedSeedEnd		DBra	D0,SeedLoop				; do it again			MoveQ	#0,D0					; no error; Now check to see if we have any animating entries which we can dispose			Tst		D3						; were there any animating entries?			Beq.S	GoHome					; no => quit; run through every color to make sure it is not reserving any entries on any device; by examining what the PaletteManager has to say about this palette as well as what; each entry's ciPrivate field has to say about the subject.  Leave pmPrivate field; (which tells PMgr which palette we ought to be) alone.			Move	pmEntries(A2),D0		; get number of entries			AddA.L	#pmInfo,A2				; bump A2 to the first ColorInfo			Lea		DevHandles(A3),A4		; point A4 at PMgrDevices			AddA.L	#LinkTabs,A3			; point	A3 to LinkTabs			Bra.S	EntryEnd				; jump into loop			EntryLoop	Move	ciPrivate(A2),D3		; get the current link information			Bpl.S	NextEntry				; if positive it's not a linkNextLink	BfExtU	D3{19:5},D1					; grab device number (0..31)			BfExtU	D3{24:8},D2					; grab index number (0..255)			Move.L	DevHandle(A4,D1.W*8),A0		; get the device handle			Move.L	(A0),A0						; dereference it			Move.L	gdPMap(A0),A0				; get handle to pixmap			Move.L	(A0),A0						; dereference pixmap			Move.L	pmTable(A0),A0				; get handle to CTab			Move.L	A0,DevCTab(A6)				; save color table handle, too			Move.L	(A0),A0						; dereference CTab			Cmp		ctSize(A0),D2				; is index number <= entries - 1?			Bhi.S	IgnoreIt					; no => don't unreserve it			Clr		ctTable+value(A0,D2.W*8)	; unreserve itIgnoreIt	Lsl		#8,D1						; calculate offset to link table/4			Add		D2,D1						; offset to entry/4			Lea		(A3,D1.L*4),A0				; point A0 at next forward link			Move	ForeLink(A0),D3				; get next link			Clr.L	ForeLink(A0)				; clear it for the next guy			Tst		D3							; is there another link to examine?			Bmi.S	NextLink					; yes => go unlink itNextEntry	Clr		ciFlags(A2)				; shut down any crap			Clr.L	ciPrivate(A2)			; clear it			AddA.L	#ciSize,A2				; bump A0 to the next ColorInfoEntryEnd	DBra	D0,EntryLoop			; loop for all pmEntriesGoHome		MoveQ	#0,D0					; clear error conditionBadPalette	MoveM.L (SP)+,D2-D3/A2-A4		; restore registers							AWC.PB457			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE	ErasePalette(ePalette: PaletteHandle); LOCAL;;ErasePalette	PROC	EXPORTParamSize	equ		4						; total bytes of paramsePalette	equ		ParamSize+8-4			; PaletteHandle to disposeVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L A2-A3,-(SP) 			; save registers			Move.L	ePalette(A6),A3			; get the handle			Move.L	(A3),A2					; dereference it			Move.L	pmSeeds(A2),A0			; get the seeds handle while we have it			CmpA	#Nil,A0					; is it nil?			Beq.S	DontDispose				; yes => punt			_DisposHandle					; it's goneDontDispose	Move.L	WindowList,A0			; get the window list for this layer		AWC.PB506			Bra.S	ListLoop				; continue									AWC.PB439CheckWindow	Tst		PortBits+Rowbytes(A0)	; by chance is it an old window?			AWC.PB439			Bpl.S	IgnoreWind				; yes => ignore it							AWC.PB439			Move.L	GrafVars(A0),A1			; get GrafVars handle						AWC.PB439			Move.L	(A1),A1					; dereference it							AWC.PB439			Move.L	PmFgColor(A1),D0		; get the palette							AWC.PB439			Cmp.L	ePalette(A6),D0			; is it correct?							AWC.PB439			Bne.S	IgnoreWind				; no => don't clear it						AWC.PB439			Clr.L	PmFgColor(A1)			; mark the window as Paletteless			AWC.PB439IgnoreWind	Move.L	nextWindow(A0),A0		; grab the next window						AWC.PB439ListLoop	Move.L	A0,D0					; CmpA.L #Nil,A0; another window?			AWC.PB439			Bne.S	CheckWindow				; yes => keep looking						AWC.PB439			CmpA.L	AppPalette,A3			; are we disposing AppPalette?				AWC.PB508			Bne.S	NotAppPltt				; no => whew!								AWC.PB508			Clr.L	AppPalette				; okay, we won't try to find it anymore		AWC.PB508NotAppPltt	Move	pmPrivate(A2),D0		; grab the last field we need from A2		AWC.PB439			And		#PIdMask,D0				; clear away flag bits			Move.L	PMgrHandle,A2			; get the main handle			CmpA.L	#PMgrNil,A2				; is it nil?			Beq.S	GoHome					; yes => don't try to find it			Move.L	(A2),A2					; dereference it			Move	APalettes(A2),D1		; start with number of active palettes			Add		FreeSpaces(A2),D1		; add free spaces to get length of list			Cmp		D1,D0					; are we within the correct range?			Bpl.S	GoHome					; no => punt			Move.L	PListHandle(A2),A1		; get handle to list of palettes			Move.L	(A1),A1					; dereference it						CmpA.L	(A1,D0.W*8),A3			; get this handle; do they match?			Bne.S	GoHome					; no => in the future we may scan for it; for now, punt			Clr.L	(A1,D0.W*8)				; it's no longer referenced			AddQ	#1,FreeSpaces(A2)		; add 1 to free spaces			SubQ	#1,APalettes(A2)		; subtract 1 from total palettesGoHome		MoveM.L (SP)+,A2-A3 			; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE	DisposePalette(srcPalette: PaletteHandle); INLINE $AA93;;DisposePalette	PROC	EXPORTParamSize	equ		4						; total bytes of paramssrcPalette	equ		ParamSize+8-4			; PaletteHandle to disposeVarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	A2,-(SP)				; save register			Move.L	srcPalette(A6),A2		; get the handle			CmpA.L	#Nil,A2					; is it nil?			Beq.S	GoHome					; yes => go home			Move.L	A2,-(SP)				; push handle			Jsr		ClearPalette			; release any animating entries			Bne.S	GoHome					; if nonzero the palette was bad			AWC.PB457			Move.L	A2,-(SP)				; push it again			Jsr		ErasePalette			; erase palette from PMgrHandle and its window			Move.L	A2,A0					; fetch palette handle into A0			_DisposHandleGoHome		Move.L	(SP)+,A2				; restore register			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;;													;;	Here begins a number of routines called by		;;	ActivatePalette.  These routines share its		;;	stack frame built on A6, building their own		;;	stack frames on A4.								;;													;;---------------------------------------------------;;---------------------------------------------------;; FUNCTION FindLink(LinkInfo:integer):integer; LOCAL;;;	FindLink searches the device links until it encounters a device that matches Device or;	until it reaches the end of the list.  It returns the index if it finds one.  It;	returns 0 (which is an illegal index since it matches white) if it can't find one.FindLink	PROC	EXPORTParamSize	equ		2						; total bytes of paramstheIndex	equ		ParamSize+10-2			; index resultLinkInfo	equ		theIndex-2				; this palette's key to previously reserved entriesVarSize		equ		0			Link	A4,#VarSize				; build stack frame			Move.L 	D3,-(SP) 				; save a register			; We will use D3 as a watchdog counter.  We set it to the maximum number of devices that we; might have to search so that if things go very wrong we stand a chance of finding out about it.			Clr		theIndex(A4)			; set result to "illegal"			Move	LinkInfo(A4),D0			; get link data			BfExtU	D0{16:3},D1				; grab top 3 bits			Cmp		#4,D1					; are they set correctly			Bne.S	GoHome					; no => the LinkInfo is invalid			Move	Devices(A6),D3			; get number of devices			Move.L	PMgrPtr(A6),A0			; PMgrHandle^			AddA.L	#LinkTabs,A0			; calculate start of LinkTabs			Bra.S	IndexEnd				; start watchdog loop			IndexLoop	BfExtU	D0{19:5},D1				; grab device number (0..31)			BfExtU	D0{24:8},D2				; grab index number (0..255)			Cmp		CurDevice(A6),D1		; is it this device?			Beq.S	FoundIt					; yes => we've got it			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Move	(A0,D1.L*4),D0			; get next link; is the top bit set?			Bpl.S	GoHome					; no => stop because we ran out of triesIndexEnd	DBra	D3,IndexLoop			; examine another index until our watchdog runs out; Our watchdog counter ran out, so something is terribly wrong.  We'll be polite about it and; say we were just unable to find it.			Bra.S	GoHome; We found the index.  Set true and return the appropriate index to theIndex(A4)FoundIt		And		#$00FF,D2				; clear everything except the index			Move	D2,theIndex(A4)			; set the resultGoHome		Move.L (SP)+,D3		 			; restore registers			Unlk	A4						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE AnalyzeDev; LOCAL;;AnalyzeDev	PROC	EXPORT			MoveM.L D3-D6/A2-A3,-(SP) 		; save registers						Move	DevIndexes(A6),D0		; get number of device entries			MoveQ	#0,D1					; clear high word, put starting index in low word			Move.L	InfoPtr(A6),A3			; get pointer to scratch area			Bra.S	ClearEnd				; jump into loopClearLoop	Move.L	D1,(A3)+				; clear high word, put index in low word			AddQ	#1,D1					; bump D1 to the next indexClearEnd	DBra	D0,ClearLoop			; continue for the entire Histogram			Clr		Histogram(A6)			Move.L	PMgrPtr(A6),A2			; put PMgrHandle^ into A2			Move	APalettes(A2),D3		; get number of active palettes			Cmp		#1,D3					; is there just the one?			Ble.S	GoHome					; yes => we're done			Add		FreeSpaces(A2),D3		; make D3 the total space count			Move.L	InfoPtr(A6),A3			; point A3 at beginning of Histogram			Move.L	PListHandle(A2),A0		; get PListHandle (locked down)			Move.L	(A0),D5					; save pointer to next PaletteHandle in D5			Move	CurDevice(A6),D6		; put current device into D4			Bra.S	HistoEnd				; jump into loopHistoLoop	Move.L	D5,A0					; get next palette			AddQ.L	#PLstEntrySz,D5			; bump D5 to next palette			MoveA.L	(A0),A0					; get next palette into A0			CmpA.L	#Nil,A0					; is this a free space?			Beq.S	HistoEnd				; yes => go examine another one			CmpA.L	PaletteH(A6),A0			; is it the current palette?			Beq.S	HistoEnd				; yes => go examine another one			Move.L	(A0),A0					; dereference the palette			Move.L	pmDevices(A0),D0		; get devices			BTst	D6,D0					; is it using this device?			Beq.S	HistoEnd				; no => go examine another palette			Move	pmEntries(A0),D4		; get number of palette entries			Lea		pmInfo(A0),A2			; put first ColorInfo into A2 where we can keep it			Bra.S	PaletteEnd				; jump into loopPaletteLoop	Clr.L	-(SP)					; push space for result			Pea		ciRGB(A2)				; push address of current color			_Color2Index					; get best fit			Move.L	(SP)+,D0				; pull the index			AddQ	#1,HistCount(A3,D0.W*4)	; add to histogram reference count for this index			Bpl.S	NotNegative				; a safeguard			SubQ	#1,HistCount(A3,D0.W*4)	; put it back positiveNotNegative	AddA.L	#ciSize,A2				; bump A2 to the next ColorInfoPaletteEnd	DBra	D4,PaletteLoop			; continue for all pmEntriesHistoEnd	DBra	D3,HistoLoop			; continue for all palettes; well you may have wondered what's going on here.  We now have an array of reference; counts for all palettes that use this device.  Each index was allowed a longint of; space, though, and the index itself was placed in the low word of that longint during; initialization.  If we view this combination as a "point" we can use the Quickdraw; procedure "SortPoints" to do all the sorting work for us.  It uses a stack-based; non-recursive QuickSort algorithm.  The reference count in the high word is the main; key.  If two of them happen to match, we won't much worry about the fact that secondary; sorting occurs on the index itself.  However, the sort will move the indexes around, too,; so we'll end up with a sorted list of indexes with low reference counts at the beginning; of the list.  We've taken pains to make sure we have no negative reference counts, though; that probably wasn't necessary.			Move.L	A3,-(SP)				; push address of "points"			Move	DevIndexes(A6),-(SP)	; push number of points;			Jsr		([SortPoints])			; call Quickdraw sort routine <C864>			_SortPoints						; call Quickdraw sort routine <C864>GoHome		MoveM.L (SP)+,D3-D6/A2-A3		; restore registers			Rts								; go home;---------------------------------------------------;; Function Pillage:Integer; LOCAL;;Pillage		PROC	EXPORTParamSize	equ		0						; total bytes of paramsEntryResult	equ		ParamSize+10-2			; best index we can findVarSize		equ		0			Link	A4,#VarSize				; build stack frame			MoveM.L D3/D4,-(SP) 			; save registers			Clr		EntryResult(A4)			; clear the result to illegal			Move.L	DevCTab(A6),A1			; get pointer to device color table			Move.L	(A1),A1					; dereference it			AddA.L	#ctTable,A1				; bump A1 to the first ColorSpec			Move	DevIndexes(A6),D3		; get number of indexes			Bra.S	PillageEnd				; jump int the loopPillageLoop	BTst	#5,value(A1,D3.W*8)		; is this one available for pillaging?			Bne.S	PillageIt				; yes => go pillage itPillageEnd	DBra	D3,PillageLoop			; continue for DevIndexes entries						Bra		GoHome					; quit in utter failure!PillageIt	BfClr	value(A1,D3.W*8){0:3} 	; unprotected, unreserved, pillaged			SubQ	#1,Pillages(A6)			; one less worth pillaging			Move	D3,EntryResult(A4)		; return the pillaged index; Now, what fun!  We get to fix up all the device links!			Move	CurDevice(A6),D0		; get current device			Lsl		#8,D0					; multiply by table size/4			Add		D3,D0					; add in entry offset			Move.L	PMgrPtr(A6),A0			; get base pointer			AddA.L	#LinkTabs,A0			; bump base pointer to start of LinkTabs			Move	ForeLink(A0,D0.W*4),D3	; get forward links			Move	BackLink(A0,D0.W*4),D4	; get forward links			Clr.L	(A0,D0.W*4)				; clear the links away			Tst		D3						; examine forward link			Bmi.S	MultiLinks1				; if < 0 we have more than one assigned			Tst		D4						; examine backward link			Bmi.S	MultiLinks2				; if < 0 we have more than one assigned; This was a quickie.  D3 contains the palette number, D4 the entry number.  All we; need do is tell the palette it no longer has it.			And		#$1FFF,D3					; clear key bits			Move.L	PListPtr(A6),A0				; get the palette list			SubQ	#1,Reserves(A0,D3*8)		; it has one less entry reserved			Move.L	PaletteRef(A0,D3*8),A0		; get the palette			Move.L	(A0),A0						; dereference it			And.L	#$00001FFF,D4				; clear high word and key bits			Lsl.L	#4,D4						; make it an offset to the ColorInfo			Clr.L	pmInfo+ciPrivate(A0,D4.L)	; clear the link			Bra		GoHome						; we did it!; The forward link goes somewhere.  See if the backward one does too.  If so,; jump to BothLinks.MultiLinks1	Tst		D4						; examine backward link			Bmi.S	BothLinks				; both of them go somewhere; The forward link goes somewhere, but the backward one does not.  We must remember; the first forward link so we can copy it into the palette, then we advance; forward by one, copy the palette entry into that, and continue searching until we find; out what palette this is.			Move	D3,D0					; remember the forward link			BfExtU	D3{19:5},D1				; grab device number (0..31)			BfExtU	D3{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Lea		(A0,D1.L*4),A1			; point A1 at next forward link			Move	D4,BackLink(A1)			; copy the back link			Move	ForeLink(A1),D3			; get next link			Bpl.S	GotPalette1				; if > 0, we've found the paletteMultiFLoop	BfExtU	D3{19:5},D1				; grab device number (0..31)			BfExtU	D3{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Move	ForeLink(A0,D1.L*4),D3	; get next link; is it positive?			Bmi.S	MultiFLoop				; no => continueGotPalette1	And		#$1FFF,D3						; clear key bits			Move.L	PListPtr(A6),A0					; get the palette list			SubQ	#1,Reserves(A0,D3*8)			; it has one less entry reserved			Move.L	PaletteRef(A0,D3*8),A0			; get the palette			Move.L	(A0),A0							; dereference it			And.L	#$00001FFF,D4					; clear high word of entry			Lsl.L	#4,D4							; make it an offset to the ColorInfo			Move	D0,pmInfo+ciPrivate(A0,D4.L)	; set a new link			Bra.S	GoHome							; we did it!; The backward link goes somewhere, but the forward one does not.  We must advance; backward by one, copy the palette id into it, and continue searching until we find out; what palette this is.MultiLinks2	BfExtU	D4{19:5},D1				; grab device number (0..31)			BfExtU	D4{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Lea		(A0,D1.L*4),A1			; point A1 at next backward link			Move	D3,ForeLink(A1)			; copy the forward link			Move	BackLink(A1),D4			; get next link			Bpl.S	GotPalette2				; if > 0, we've found the paletteMultiBLoop	BfExtU	D4{19:5},D1				; grab device number (0..31)			BfExtU	D4{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Move	BackLink(A0,D1.L*4),D4	; get next link; is it positive?			Bmi.S	MultiBLoop				; no => continue			Bra.S	GotPalette2				; share common code; We're in the middle of the list somewhere.  We'll step one backward and copy; the forelink from the current entry, then we'll step one foreward and copy; the backlink from the current entry.  Then we'll keep going forward until we; find the palette.  All we need do is decrement its reference count, so we don't; need the entry number.BothLinks	BfExtU	D4{19:5},D1				; grab device number (0..31)			BfExtU	D4{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Lea		(A0,D1.L*4),A1			; point A1 at next backward link			Move	D3,ForeLink(A1)			; copy the forward link			BfExtU	D3{19:5},D1				; grab device number (0..31)			BfExtU	D3{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Lea		(A0,D1.L*4),A1			; point A1 at next foreward link			Move	D4,BackLink(A1)			; copy the backward link			Move	ForeLink(A1),D3			; get next foreward link			Bpl.S	GotPalette2				; if > 0, we've found the paletteBothLoop	BfExtU	D3{19:5},D1				; grab device number (0..31)			BfExtU	D3{24:8},D2				; grab index number (0..255)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Move	ForeLink(A0,D1.L*4),D3	; grab next forward link			Bmi.S	BothLoop				; if < 0, we keep lookingGotPalette2	Move.L	PListPtr(A6),A0			; get the palette list			And		#$1FFF,D3				; clear away key bits			SubQ	#1,Reserves(A0,D3*8)	; it has one less entry reservedGoHome		MoveM.L (SP)+,D3/D4	 			; restore registers			Unlk	A4						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE ReserveColor(myEntry:integer); LOCAL;;ReserveColor	PROC	EXPORTParamSize	equ		2						; total bytes of paramsmyEntry		equ		ParamSize+8-2			; number of ColorInfo to reserveVarSize		equ		0			Link	A4,#VarSize				; build stack frame			Move	Histogram(A6),D0		; get next entry to examine			Move	DevIndexes(A6),D1		; get number of indexes for this device			Sub		D0,D1					; calculate number of possibilites left			Ble.S	NoneLeft				; none => quit, leaving color unhandled			Move.L	InfoPtr(A6),A0			; get pointer to histogram			Move.L	DevCTab(A6),A1			; get device CTabHandle			Move.L	(A1),A1					; dereference it			AddQ.L	#ctTable,A1				; bump it to the first ColorSpec			Bra.S	CheckEnd				; jump into the loopCheckLoop	Move	HistIndex(A0,D0.W*4),D2		; get the next index			AddQ	#1,D0						; bump Histogram to next entry			Tst		D2							; is it "white"?			Beq.S	CheckEnd					; yes => ignore it			Cmp		BlackIndex(A6),D2			; is it "black"?			Beq.S	CheckEnd					; yes => ignore it			BTst	#reserveBit,value(A1,D2.W*8); is this entry reserved?				<1.5>			Beq.S	FoundOne					; no => we've got it!CheckEnd	DBra	D1,CheckLoop				; continue for all remaining indexes; We've used all available unreserved entries.  Now we look to see if we can pillage; anything from the device table.NoneLeft	Move	D0,Histogram(A6)		; mark Histogram as done			Tst		Pillages(A6)			; is there anything to pillage?			Beq		GoHome					; no => quit			Clr		-(SP)					; function result			Jsr		Pillage					; get an entry by pillaging			Move.L	DevCTab(A6),A1			; restore A1								AWC.PB480			Move.L	(A1),A1					; dereference it							AWC.PB480			AddQ.L	#ctTable,A1				; bump it to the first ColorSpec			AWC.PB480			Move	(SP)+,D2				; put it in D2; is it legal?			Bne.S	TakeEntry				; yes => roust it out			Bra		GoHome					; no => miserable failure			FoundOne	Move	D0,Histogram(A6)					; mark used portion of HistogramTakeEntry	Move.L	PalettePtr(A6),A0					; get palette pointer			MoveQ	#0,D0								; clear high word			Move	myEntry(A4),D0						; get entry number			Lsl.L	#4,D0								; calculate offset to ColorInfo			Lea		pmInfo(A0,D0.L),A0					; point A0 at ColorInfo			BSet	#HandledBit,ciFlags(A0)				; mark this entry as handled			Move.L	ciRGB+red(A0),RGB+red(A1,D2.W*8)	; update red and green			Move	ciRGB+blue(A0),RGB+blue(A1,D2.W*8)	; update blue			AddQ	#1,Updates(A6)						; we've changed something			BSet	#reserveBit,value(A1,D2.W*8)		; reserve it						<1.5>; For old or new links, the BackLink will still point at the entry number | $6000			Move.L	DevLinks(A6),A1			; point A1 at LinkTab			Move	myEntry(A4),D0			; grab entry number			And		#$7FFF,D0				; ensure that the top bit is off			Or		#$6000,D0				; set the top bits to 011			Move	D0,BackLink(A1,D2.W*4)	; set backward link to entry | $6000; Calculate a link to this new guy in D0.  This will go in ciPrivate and, if we already; had a link, into the BackLink of the old guy.			Move	CurDevice(A6),D0		; get current device again			Lsl		#8,D0					; shift device into upper byte			Or		D2,D0					; OR in the device number			BSet	#15,D0					; set the three highest bits to 100; Copy the old link then set the new one.  Then look to see if the old link was real.; If so, we have some work to do.  If not, initialize the link by setting the forelink; to the palette number.  The back link has already been set to the entry number.			Move	ciPrivate(A0),D1		; copy the old link			Move	D0,ciPrivate(A0)		; point ciPrivate at the new guy			Tst		D1						; did we have any old links?			Bne.S	OldLinks				; yes => relink it			Move.L	PalettePtr(A6),A0		; get pointer to palette			Move	pmPrivate(A0),D0		; grab number of this palette			And		#PIdMask,D0				; clear the flag bits			Or		#$6000,D0				; to make it non-zero, set the top bits to 011			Move	D0,ForeLink(A1,D2.W*4)	; set forward link to palette | $6000			Bra.S	FixRefCount				; fix up the paletteOldLinks	Move	D1,ForeLink(A1,D2.W*4)	; point Dev[FoundIndex] at old ciPrivate			BfExtU	D1{24:8},D2				; grab index number (0..255)			BfExtU	D1{19:5},D1				; grab device number (0..31)			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Move.L	PMgrPtr(A6),A1			; get base pointer			AddA.L	#LinkTabs,A1			; bump it to the LinkTabs			Move	D0,BackLink(A1,D1.L*4)	; set the backward linkFixRefCount	Move.L	PListPtr(A6),A0			; get PListPtr			Move.L	PalettePtr(A6),A1		; get palette			Move	pmPrivate(A1),D0		; get palette number			And		#PIdMask,D0				; clear the flag bits			AddQ	#1,Reserves(A0,D0.W*8)	; bump number of reservesGoHome		Unlk	A4						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE Allocate; LOCAL;;Allocate	PROC	EXPORT; We have one or more animating entries.  For each entry in myPalette, look to see if it is; animating.  If so, look to see if it exists on this device.  If not, look to see if we can; allocate it on this device.			MoveM.L D3/D4/A2,-(SP) 			; save registers			Jsr		AnalyzeDev				; analyze the entries used on the device			Move.L	PalettePtr(A6),A2		; get palette pointer			Move	pmEntries(A2),D3		; get number of entries			MoveQ	#0,D4					; D4 is the entry number			AddA.L	#pmInfo,A2				; bump A2 to the first ColorInfo			Bra.S	AnimateEnd				; jump into loopAnimateLoop	Move	ciFlags(A2),D0			; examine "handled"			Bmi.S	NextAnimate				; it was explicit or courteous; ignore it			BTst	#AnimatedBit,D0			; are we animating?			Beq.S	NextAnimate				; no => ignore it			Clr		-(SP)					; clear index result			Move	ciPrivate(A2),-(SP)		; push animation link info (first word only)			Jsr		FindLink				; FindLink(Device,myPalette^^.pmInfo[i].ciPrivate)			Move	(SP)+,D0				; pop the index result			Bne.S	GotEntry				; true => it's still there - mark it as "handled"; We will be allocating an entry for animation.  If this is the first allocation, call; AnalyzeDev to fill the scratch handle with the histogram for this device.			Move	D4,-(SP)				; push entry number			Jsr		ReserveColor			; try to reserve it			BTst	#HandledBit,ciFlags(A2)	; did it succeed?			Bne.S	NextAnimate				; yes => keep trying			Clr		Tolerators(A6)			; don't bother with tolerators			Bra.S	GoHome					; and go home			GotEntry	BSet	#HandledBit,ciFlags(A2)	; set "handled" bitNextAnimate	AddA.L	#ciSize,A2				; bump us to the next ColorInfo			AddQ	#1,D4					; bump entry numberAnimateEnd	DBra	D3,AnimateLoop			; loop for all pmEntriesGoHome		MoveM.L (SP)+,D3/D4/A2 			; restore registers			Rts								; strip parameters and go home;---------------------------------------------------;; FUNCTION DeltaRGB(ColorInfo,ColorSpec:Ptr):integer; LOCAL;;DeltaRGB	FUNC	EXPORTParamSize	equ		8						; total bytes of paramsDelta		equ		ParamSIze+10-2			; integer resultRGB1		equ		Delta-4					; palette entry pointerRGB2		equ		RGB1-4					; color table entry pointerVarSize		equ		0						; size of variables			Link	A6,#VarSize				; build stack frame						Move.L	RGB1(A6),A0				; get first RGBColor			Move.L	RGB2(A6),A1				; get second RGBColor						Move	(A1)+,D0				; grab index red			Sub		(A0)+,D0				; subtract entry red			Bhs.S	NotNeg1					; take abs(Index.Red-ColorInfo.Red)			Neg		D0						; negate itNotNeg1		Move	(A1)+,D1				; grab index green			Sub		(A0)+,D1				; subtract entry green			Bhs.S	NotNeg2					; take abs(Index.Green-ColorInfo.Green)			Neg		D1						; negate itNotNeg2		Cmp		D0,D1					; leave greater unsigned value in D0			Blo.S	DontSwitch1				; D1 < D0 => D0 is already greater			Move	D1,D0					; green value is greaterDontSwitch1	Move	(A1),D1					; grab index blue			Sub		(A0),D1					; subtract entry blue			Bhs.S	NotNeg3					; take abs(Index.Blue-ColorInfo.Blue)			Neg		D1						; negate itNotNeg3		Cmp		D0,D1					; leave greater unsigned value in D0			Blo.S	FixResult				; D1 < D0 => D0 is already greater			Move	D1,D0					; blue value is greaterFixResult	Move	D0,Delta(A6)			; set result			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home							ENDF;---------------------------------------------------;; PROCEDURE	Correlate; LOCAL;;;	This function uses the stack frame built upon A6 and builds its own stack frame on A4.Correlate	PROC	EXPORTParamSize	equ		0						; total bytes of params			MoveM.L D3-D7/A2-A4,-(SP) 		; save registers; The InfoHandle is actually twice as large as we need, so we can just clear half of it; without worrying about boundary conditions.  We do, however, assume that DevIndexes is; a multiple of 2.			Move.L	InfoPtr(A6),A0			; get pointer to scratch area			Move	DevIndexes(A6),D0		; maximum number of device indexes			Lsr		#1,D0					; divide by 2 because we clear longs			Bra.S	ZeroEnd					; jump into the DBraZeroLoop	Clr.L	(A0)+					; clear two palette reference fieldsZeroEnd		DBra	D0,ZeroLoop				; loop for half of all indexes; The ciPrivate longint is used as a record containing two distinct fields.  The first; is in the high word and is reserved for the best index we can find.  The low word is; used to hold the DeltaRGB value for that index.;;   A2 - points to pmInfo;	A3 - points to DevCTab^^.ctTable;	A4 - points to device scratch table;;	D3 - keeps track of number of entries left to examine;	D4 - keeps track of offset to current ColorInfo;	D5 - holds best index and offset to colliding ColorInfo;	D6 - holds number of available device entries;	D7 - hold index of current ColorInfo			Move	myEntries(A6),D3		; get number of palette entries			Move.L	PalettePtr(A6),A2		; get pointer to palette			Lea		pmInfo(A2),A2			; bump A2 to first ColorInfo			Move.L	DevCTab(A6),A0			; get device color table handle			_HLock							; lock it down			Move.L	(A0),A3					; dereference it and copy it to A4			AddQ.L	#ctTable,A3				; bump it to the first ColorSpec			Move.L	InfoPtr(A6),A4			; get pointer to our info table, freshly zeroed			MoveQ	#0,D4					; initialize D4 to first ColorInfo in palette			MoveQ	#0,D7					; initialize D7 to 0			Clr		Collisions(A6)			; clear number of collisions			Move	Regulators(A6),D6		; D6 holds number of available entries			Bra		AllocEnd				; jump into loop that initializes tree (no .S)AllocLoop	Move	ciFlags(A2,D4.L),D1		; grab flags; is the HandledBit set? ( < 0 )			Bmi		Chosen					; yes => we've done it already			BTst	#TolerantBit,D1			; no => are we tolerating?			Beq		Chosen					; no => continue			Tst		D6						; have we run out of entry space?			Bgt.S	NotYet					; no => keep going			Tst		Pillages(A6)			; is there an entry to pillage?			Beq.S	HandleIt				; no => we can punt			Clr		-(SP)					; function result			Jsr		Pillage					; we'll pillage so we'll have another color			Move	(SP)+,D5				; get the result			Bra.S	Pillaged				; share common codeNotYet		SubQ	#1,D6					; one more available entry consumed			Clr.L	-(SP)					; push longint result			Pea		ciRGB(A2,D4.L)			; push address of RGBColor field			_Color2Index					; find the best match for this color			Move.L	(SP)+,D5				; get best indexPillaged	Clr		-(SP)					; push DeltaRGB result			Pea		ciRGB(A2,D4.L)			; push the address of the ColorInfo.ciRGB			Pea		RGB(A3,D5.W*8)			; push address of index's RGBColor			Jsr		DeltaRGB				; calculate and set ciPrivate+2=color distance			Move	(SP)+,D0				; fetch distance			Tst		D5						; was the index white?			Beq.S	CheckWhite				; yes => see if white is okay			Cmp		BlackIndex(A6),D5		; was the index black?			Bne.S	NotBlack				; no => continue; we have matched white or black.  If we're within tolerance we'll mark this color as; handled and continue.  If not, we'll skip trying to pick the best entry stuff.  We add; 1 to D6 because we know we subtracted 1 at NotYet above and didn't mean to.  We should; never get here with a pillaged entry since black or white are never supposed to be; reserved and therefore should never be pillaged.  So, it should be safe to add one; back to D6.CheckWhite	Cmp		ciTolerance(A2,D4.L),D0	; are we within tolerance?			Bls.S	BlackWhite				; yes => mark these as handled			Clr.L	ciPrivate(A2,D4.L)		; clear ColorInfo.ciPrivate field			AddQ	#1,Collisions(A6)		; bump number of collisions			Bra.S	Chosen					; share common codeBlackWhite	AddQ	#1,D6							; don't count black or whiteHandleIt	BSet	#HandledBit,ciFlags(A2,D4.L)	; set the handled bit			Bra.S	Chosen							; share common codeNotBlack	Lea		(A4,D5.W*2),A1			; point A1 at the DevTab entry for this index			MoveQ	#0,D1					; clear high word			Move	(A1),D1					; is there an entry here already (<> 0)			Beq.S	PickCurrent				; no => mark the current entry as chosen; We have a collision.  The index to which we just matched is already used.  Look; to see which of the two entries has the lower DeltaRGB.			And		#$7FFF,D1				; clear away the "taken" bit		AWC.PB377			AddQ	#1,Collisions(A6)		; bump number of collisions			Lsl.L	#4,D1					; convert D1 to an offset to its ColorInfo			Move	ciPrivate+2(A2,D1.L),D2	; get tolerance of colliding entry			Cmp		D0,D2					; which unsigned value is lower?			Bhi.S	SwapEntries				; current value => swap them			PB262/C886			Clr.L	ciPrivate(A2,D4.L)		; clear current index			Bra.S	Chosen					; share common codeSwapEntries	Clr.L	ciPrivate(A2,D1.L)		; mark former entry index as unassignedPickCurrent	Move	D5,ciPrivate(A2,D4.L)	; set index of current ColorInfo			Move	D0,ciPrivate+2(A2,D4.L)	; set tolerance of current ColorInfo			Move	D7,(A1)					; put it in the device index table			BSet	#7,(A1)					; mark it as taken				AWC.PB377Chosen		Add.L	#ciSize,D4				; bump D4 to offset of next ColorInfo			AddQ	#1,D7					; bump D7 to next ColorInfoAllocEnd	DBra	D3,AllocLoop			; loop for all pmEntries			Tst		Collisions(A6)			; have we any more work to do			Beq.S	SetColors				; no => go examine tolerances; STAGE 2 - make sure jumping to SetColors is warranted - notice we still look for; unresolved colors the way it is currently written.; In this section we try to find a unique index for each entry in the color table. We start; by examining each index in the device for the reserved bit.  If it is reserved we enter; a value in our dev table so we won't try to match with it (we enter black's index).  We; run down the palette and find each entry which is a) not handled, b) tolerant, and; c) unassigned (ciPrivate field is 0, white).  Then we search the available colors one; by one, finding the best match among the ones left by using DeltaRGB.;	A3 - points to DevCTab^^.ctTable;	A4 - points to device scratch table;	D0 - keeps track of number of ColorSpecs left to examine;	D1 - holds value of BlackIndex, used to mark indexes as reserved			Move	DevIndexes(A6),D0			; number of entries to mark			Move	BlackIndex(A6),D1			; mark entries as taken using "black"			Bra.S	MarkEnd						; jump into loopMarkLoop	BTst	#reserveBit,value(A3,D0.W*8); is this entry reserved?					<1.5>			Beq.S	MarkEnd						; no => continue			Move	D1,(A4,D0.W*2)				; mark it as reserved in device info listMarkEnd		DBra	D0,MarkLoop					; continue			Move	D1,(A4)					; mark white as taken			Move	D1,(A4,D1.W*2)			; mark black as taken;   A2 - points to current ColorInfo;	A3 - still points to DevCTab^^.ctTable;	D0 - used as a temp;	D3 - keeps track of number of entries left to examineSetColors	Move	myEntries(A6),D3		; potential number of entries to resolve			MoveQ	#0,D4					; ColorInfo entry counter			Bra		ResolveEnd				; jump into loop; By the time we reach this point a ColorInfo is either Tolerant or Handled.ResolveLoop	Tst		ciFlags(A2)				; has this ColorInfo been handled?			Bmi		NextCInfo				; yes => continue (.S won't fit)			Tst		ciPrivate(A2)			; have we assigned an index yet?			Bne.S	Resolved				; yes => continue; Resolve this entry by searching for the best match from the available indexes			Move.L	InfoPtr(A6),A1			; get device info pointer			MoveQ	#0,D0					; clear entry counter			Move	DevIndexes(A6),D1		; get number of device entries			Move	#$FFFF,ciPrivate+2(A2)	; set fit to worst			Bra.S	FindEnd					; start loopFindLoop	Tst		(A1,D0.W*2)				; is this index available?			Bne.S	NextGuy					; no => try the next guy			MoveM.L	D0-D1/A1,-(SP)			; save the current registers			Clr		-(SP)					; push DeltaRGB result			Pea		ciRGB(A2)				; push the address of the ColorInfo.ciRGB			Pea		RGB(A3,D0.W*8)			; push address of index's RGBColor			Jsr		DeltaRGB				; calculate and set ciPrivate+2=color distance			Move	(SP)+,D0				; fetch the distance			Tst		ciPrivate(A2)			; have we anything yet?			Beq.S	StuffIt					; no => use it			Cmp		ciPrivate+2(A2),D0		; is it closer or equal to what we last had?			Bhs.S	NotBetter				; no => continueStuffIt		Move	D0,ciPrivate+2(A2)		; remember better fit			MoveM.L	(SP)+,D0-D1/A1			; restore registers			Move	D0,ciPrivate(A2)		; remember better index			Bra.S	NextGuy					; continueNotBetter	MoveM.L	(SP)+,D0-D1/A1			; restore registersNextGuy		AddQ	#1,D0FindEnd		DBra	D1,FindLoop			Move	ciPrivate(A2),D0		; get best index; if the result is 0 we've not found it, and we have a system error.  While it would be; good to find this, it's better to do something "robust" for a released version, so we'll; jump ahead to GoodEnough and avoid any updates.			Beq.S	GoodEnough				; internal palette manager error; leave quietly;			MoveQ	#1,D0					; clear the index					<AWC>FoundIt		Move	D0,ciPrivate(A2)		; shove the index into the field			Move	#1,(A1,D0.W*2)			; mark dev info list as being taken			Clr		-(SP)					; push DeltaRGB result			Pea		ciRGB(A2)				; push the address of the ColorInfo.ciRGB			Move	ciPrivate(A2),D0		; fetch the entry we just assigned			Pea		RGB(A3,D0.W*8)			; push address of index's RGBColor			Jsr		DeltaRGB				; calculate and set ciPrivate+2=color distance			Move	(SP)+,ciPrivate+2(A2)	; fetch distanceResolved	Move	ciTolerance(A2),D0		; get preferred tolerance			Cmp		ciPrivate+2(A2),D0		; is the unsigned current fit good enough?			Bhs.S	GoodEnough				; yes => leave it alone			Move	ciPrivate(A2),D0		; get the index			Move.L	ciRGB+red(A2),RGB+red(A3,D0.W*8)	; copy red and green to device CTab			Move	ciRGB+blue(A2),RGB+blue(A3,D0.W*8)	; copy blue to device CTab			AddQ	#1,Updates(A6)			; remember we've done oneGoodEnough	Clr.L	ciPrivate(A2)			; to keep everybody honestNextCInfo	Clr		ciFlags(A2)				; we're all done with ciFlags			AddA.L	#ciSize,A2				; bump to the next ColorInfoResolveEnd	DBra	D3,ResolveLoop			; loop for all pmEntriesNoTolerant	Move.L	DevCTab(A6),A0			; get handle to device color table			_HUnlock						; unlock it			MoveM.L (SP)+,D3-D7/A2-A4		; restore registers			Rts								; strip parameters and go home;---------------------------------------------------;; PROCEDURE	RedrawDesktop; LOCAL;;RedrawDesktop	PROC	EXPORT			Tst		GrayRgnPrep(A6)			; have we set up the GrayRgn stuff?			AWC.PB508			Bmi		NoColorDesk				; yes => but there's nothing to do			AWC.PB508			Bne.S	DrawDesktop				; yes => skip the setup						AWC.PB508			Move	#-1,GrayRgnPrep(A6)		; initialize it to "nothing to do"			AWC.PB508			Tst.B	pCDeskPat				; test bit 7 of pCDeskPat					AWC.PB508			Bpl.S	NoColorDesk				; don't update the desktop					AWC.PB508			Move.L	DeskCPat,D0				; is there a desktop pattern?				AWC.PB508			Beq.S	NoColorDesk				; no => don't update the desktop			AWC.PB508			Move.L	D0,A0					; put the desktop pattern into A0			AWC.PB508			Move.L	(A0),A0					; dereference it							AWC.PB508			Move.L	PatMap(A0),A0			; get the pixmaphandle						AWC.PB508			Move.L	(A0),A0					; dereference it							AWC.PB508			Move.L	pmTable(A0),A0			; get the CTabHandle						AWC.PB508			Move.L	(A0),A0					; dereference it							AWC.PB508			Move	ctSize(A0),D1			; get the size								AWC.PB508			AddQ	#1,D1					; adjust it so the DBra works correctly		AWC.PB508			AddA.L	#ctTable+rgb,A0			; bump A0 to first color spec				AWC.PB508			Bra.S	DeskEnd					; check for not black or white				AWC.PB508DeskLoop	Move.L	(A0)+,D2				; get first									AWC.PB508			Bne.S	NotBlack				; not black; check white					AWC.PB508			Move	(A0)+,D2				; get blue component						AWC.PB508			Bne.S	ColorDesk				; not black or white; do an update			AWC.PB508			Bra.S	DeskNext				; continue									AWC.PB508NotBlack	Cmp.L	#-1,D2					; is it white?								AWC.PB508			Bne.S	ColorDesk				; not white; do an update					AWC.PB508			Move	(A0)+,D2				; get blue component						AWC.PB508			Cmp		#-1,D2					; is it white?								AWC.PB508			Bne.S	ColorDesk				; not white; do an update					AWC.PB508DeskNext	AddQ.L	#2,A0					; bump A0 to next color						AWC.PB508DeskEnd		DBra	D1,DeskLoop				; continue									AWC.PB508			Bra.S	NoColorDesk				; nothing but black or white; skip it		AWC.PB508ColorDesk	Clr.L	-(SP)					; function result							AWC.PB508			_NewRgn							; get a new region							AWC.PB508			Move.L	(SP)+,DeskRgn(A6)		; save it for later use; was it nil?		AWC.PB508			Beq.S	NoColorDesk				; yes => can't redraw anything				AWC.PB508			Move	#1,GrayRgnPrep(A6)		; signal that we have work to do			AWC.PB508DrawDesktop	Move.L	A3,-(SP)				; save a register							AWC.PB508			Clr.L	-(SP)					; function result							AWC.PB508			_NewRgn							; get another new region					AWC.PB508			Move.L	(SP),A3					; save it where we can keep an eye on it	AWC.PB508			Move.L	A3,D0					; check for nil handle						AWC.PB508			Beq.S	NoRgn					; couldn't get one, so quit					AWC.PB508			Move.L	A2,-(SP)				; push pointer to device rect				AWC.PB508			_RectRgn						; make a rectangular region out of it		AWC.PB508			Move.L	DeskRgn(A6),-(SP)		; push DeskRgn								AWC.PB508			Move.L	A3,-(SP)				; push temp region							AWC.PB508			Move.L	DeskRgn(A6),-(SP)		; put result back in DeskRgn				AWC.PB508			_UnionRgn						; UnionRgn(DeskRgn,tempRgn,deskRgn)			AWC.PB508			Move.L	A3,-(SP)				; push temp region							AWC.PB508			_DisposRgn						; dump it									AWC.PB508NoRgn		Move.L	(SP)+,A3				; restore a register						AWC.PB508NoColorDesk	Rts								; and go home								AWC.PB508;---------------------------------------------------;; PROCEDURE	SetDev; LOCAL;;;	Renders or allocates myPalette as appropriate for the given device.  If myPalette;	is polite it accumulates reference counts.  If it is intolerant it assigns indexes;	according to closest match and makes these colors available in the color table.  If;	it is adamant (animated) it chooses indexes according to lowest reference counts;	and reserves the entries on the device (setting the reserve bit).;;	This function uses the stack frame built upon A6 and builds its own stack frame on A4.SetDev		PROC	EXPORTResultRect	equ		-8						; temp rectOldPort		equ		ResultRect-4			; a place to stuff the port while we InvalRectSysUpdates	equ		OldPort-2				; flag that tells whether the system wants updatesOldUpdates	equ		SysUpdates-2			; flag => 1 if Old Quickdraw colors got changed AWCVarSize		equ		OldUpdates				; number of bytes of variables			AWC PB223			Link	A4,#VarSize				; build stack frame			MoveM.L	D3-D5/A2-A3,-(SP)		; save registers						<AWC>; Grab the device handle and shove it into theGDevice			Move	CurDevice(A6),D3		; get device offset			Move.L	PDevPtr(A6),A0			; get pointer to internal list of devices			Move.L	(A0,D3.W*8),A0			; get the device handle			Move.L	A0,theGDevice			; set theGDevice; Removed code that calculated device info - see CalcDevs below						AWC PB223			Move.L	(A0),A0					; dereference it			Move.L	gdPMap(A0),A0			; get handle to pixmap			Move.L	(A0),A0					; dereference pixmap			Move.L	pmTable(A0),A0			; get handle to CTab			Move.L	A0,DevCTab(A6)			; save color table handle, too			Move.L	(A0),A0					; dereference CTab			Move	ctSize(A0),D0			; grab number of entries - 1			Move	D0,BlackIndex(A6)		; save it			AddQ	#1,D0					; bump it to number of entries			Move	D0,DevIndexes(A6)		; save the number of indexes, too; Compare the palette's seed for this device to the ctSeed belonging to the; device.  If they match, no environment or palette change has occurred.  The routines; which modify palettes make sure that the appropriate seed fields get changed.  If; the user modifies the palette herself, she must take responsibility for changing; the seeds accordingly.			Move.L	ctSeed(A0),D0			; read the current device seed			Move.L	PalettePtr(A6),A0		; get the Palette pointer			BTst	#DirtyBit,pmPrivate(A0)	; does it need an update anyway?			Bne.S	DirtyBird				; yes => activate it anyway			Move.L	pmSeeds(A0),A0			; get the handle to the seeds			Move.L	(A0),A0					; dereference it			Cmp.L	(A0,D3.W*4),D0			; does the Palette's seed match the device's?			Beq		GoHome					; yes => skip this whole mess; Set up some useful pointersDirtyBird	Move.L	PDevPtr(A6),A0			; get pointer to internal list of devices			Lea		(A0,D3.W*8),A0			; point A0 at the device entry			Move.L	A0,DevEntry(A6)			; save a pointer to the current device's entry			Move.L	PMgrPtr(A6),A0			; copy base pointer			AddA.L	#LinkTabs,A0			; add offset to first link table			Move	D3,D0					; get the device number (0..31)			Lsl		#8,D0					; multiply by link table size (max 31*1024)			Lea		(A0,D0.W*4),A0			; point A0 at link table			Move.L	A0,DevLinks(A6)			; save pointer to device links table; Set Updates to 0 so we'll know if a SetEntries is necessary.  Make a copy; of ciUsage flags in ciFlags.			Clr		Updates(A6)				; clear number of updates to CTab we've done			Move	myEntries(A6),D0		; get myPalette^^.pmEntries			Move.L	PalettePtr(A6),A0		; get the pointer to the palette			Lea		pmInfo(A0),A0			; bump it to the first ColorInfo			Bra.S	InitEnd					; jump into the frayInitLoop	Move	ciUsage(A0),ciFlags(A0)	; copy ciUsage to ciFlags			AddA.L	#ciSize,A0				; bump A0 to the next ColorInfoInitEnd		DBra	D0,InitLoop				; loop for pmEntries			Move.L	PalettePtr(A6),A0		; get the palette			Move	pmPrivate(A0),D3		; get the number of this palette			And		#PIdMask,D3				; clear the flag bits			Move.L	DevCTab(A6),A0			; get device CTabHandle			Move.L	(A0),A0					; dereference it			AddA.L	#ctTable,A0				; bump A0 to the start of the table			Move.L	DevLinks(A6),A1			; get device links table			Move	DevIndexes(A6),D0		; get number of entries on this device			MoveQ	#0,D4					; clear number that belong to us			MoveQ	#0,D5					; clear number available for pillaging			Move.L	PMgrPtr(A6),A2			; get the base pointer into A2			AddA.L	#LinkTabs,A2			; bump A2 to the start of the link tabs			Bra.S	CountEnd				; jump into loopCountLoop	Move	ForeLink(A1,D0.W*4),D1	; fetch the link info for this entry, theGDevice			Beq.S	ClearIt					; if 0, we didn't reserve it			AWC.PB377			Bpl.S	EndOfLink				; if >0 then we've found the endNextIndex	BfExtU	D1{24:8},D2				; get the index number (0..255)			BfExtU	D1{19:5},D1				; grab device number (0..31)			Lsl		#8,D1					; multiply by table size/4			Add		D2,D1					; add index to table offset			Move	ForeLink(A2,D1.W*4),D1	; get the next index; is it an endlink?			Bmi.S	NextIndex				; no => find the next linkEndOfLink	And		#PIdMask,D1				; clear all but the important bits			Cmp		D3,D1					; is this ours?			Bne.S	NotThisOne				; no => bump Pillages			AddQ	#1,D4					; bump number we still have			Move	#$4000,value(A0,D0.W*8)	; devctab => no protect, reserve, nopillage, our id			Bra.S	CountEnd				; share code to force the device tableNotThisOne	AddQ	#1,D5					; bump number we can pillageFixCTab		Move	#$6000,value(A0,D0.W*8)	; devctab => no protect, reserve, pillage, our id			Bra.S	CountEnd				; continueClearIt		Clr		value(A0,D0.W*8)		; device ctab => unusedCountEnd	DBra	D0,CountLoop			; continue for DevIndexes device entries			Move	D5,Pillages(A6)			; remember how many we can pillage			Cmp		Animators(A6),D4		; have we all we want already?			Bpl.S	QuickHandle				; yes => mark them handled					<AWC>			Jsr		Allocate				; yes => call allocation routine			Bra.S	CheckTolrnt				; do the tolerant entries					<AWC>QuickHandle	Move	myEntries(A6),D0		; get the number of entries					<AWC>			Move.L	PalettePtr(A6),A0		; get palette pointer						<AWC>			Lea		pmInfo(A0),A0			; bump A0 to the first ColorInfo			<AWC>			Bra.S	QuickEnd				; jump into loop							<AWC>QuickLoop	Tst		ciFlags(A0)					; is it handled?						<AWC>			Bmi.S	NextQuick					; yes => continue						<AWC>			BTst	#AnimatedBit,ciFlags+1(A0)	; is it animating?						<AWC>			Beq.S	NextQuick					; no => leave it alone					<AWC>			BSet	#HandledBit,ciFlags(A0)		; mark it handled						<AWC>NextQuick	AddA.L	#ciSize,A0					; bump A0 to the next ColorInfo			<AWC>QuickEnd	DBra	D0,QuickLoop				; continue for pmEntries				<AWC>CheckTolrnt	Tst		Tolerators(A6)			; are there any tolerant entries?			Beq.S	CheckUpdate				; no => tidy up			Move	DevIndexes(A6),D0		; get maximum number of entries			SubQ	#2,D0					; subtract black and white			Sub		Animators(A6),D0		; subtract our animators			Sub		Pillages(A6),D0			; subtract other reserved entries			Move	D0,Regulators(A6)		; this is the number of regular entries left			Jsr		Correlate				; yes => resolve collisions; Now we are ready to set some colors (for real, man!).  We have been changing colors; in the device's color table all along.  Now we just need to promulgate them through; to the device with a sequential SetEntries call, but only if Updates is greater than; zero.  In order to make the call we have to unprotect each color and set it's client; id to "none".  Then we do the SetEntries call, after which we restore the protection; and client id (255) of all colors.  Next we copy the seed from the device color table; to the palette so we'll know we've been here.  Finally we generate update events for; all windows of palettes which have been rendered on this device, including of course; the current palette.CheckUpdate	Tst		Updates(A6)				; have we changed anything?			Beq.S	NoUpdate				; no => ignore this stuff; Perform a sequential SetEntries call using the device's own color table.			Move.L	theGDevice,A0			; get the device			Move.L	(A0),A0					; dereference it			Clr		gdId(A0)				; no client id's, please			Clr		-(SP)					; push starting count of 0 for SetEntries			Move	BlackIndex(A6),-(SP)	; push number of entries-1			Move.L	DevCTab(A6),A0			; get color table			Move.L	(A0),A0					; dereference it			Pea		ctTable(A0)				; push address of the first ColorSpec			_SetEntries						; do itNoUpdate	Move.L	DevCTab(A6),A0			; get color table			Move.L	(A0),A0					; dereference it			Move.L	ctSeed(A0),D0			; read the current device seed			Move.L	PalettePtr(A6),A0		; get the Palette pointer			Move.L	pmSeeds(A0),A1			; get the handle to the seeds			Move.L	(A1),A1					; dereference it			Move	CurDevice(A6),D3		; get device number back			Move.L	D0,(A1,D3.W*4)			; update the Palette's seed; If we did not do the SetEntries, skip this part, too.			Tst		Updates(A6)				; did we do a SetEntries?			Beq		GoHome					; no => jump over the update code; Here is where we add the portion of the port that touches this device to; the palette's window's update region.			Pea		OldPort(A4)				; where to put current GrafPtr			_GetPort						; get it			Move.L	theGDevice,A0			; get theGDevice			Move.L	(A0),A0					; dereference it			Lea		gdRect(A0),A2			; get address of device rect into A2			Move	gdFlags(A0),D0			; get flags			BTst	#mainScreen,D0			; is it the main screen?			Beq.S	NoMenuFix				; no => don't update the menu			Move.L	MenuList,D0 			; get the MenuList handle; is it nil?		AWC.PB508			Beq.S	NoMenuFix				; yes => don't redraw the menu bar			AWC.PB508			Move.L	D0,A0					; get ready to dereference it				AWC.PB508			Tst.L	(A0)					; has it been purged?						AWC.PB508			Beq.S	NoMenuFix				; yes => don't redraw the menu bar			AWC.PB508			_DrawMenuBar					; redraw the menu bar						AWC.PB508NoMenuFix	MoveQ	#0,D0					; we want no updates if no SysPalette		AWC PB223			Move.L	AppPalette,A0			; fetch the application's palette, if any	AWC.PB457			Move.L	A0,D1					; CmpA.L #Nil,A0; is it nil?				AWC.PB457			Bne.S	UseAppPltt				; no => use the application's palette		AWC.PB457			Move.L	PMgrPtr(A6),A0			; fetch our data pointer			Move.L	SysPalette(A0),A0		; fetch the system palette			Move.L	A0,D1					; CmpA.L #Nil,A0; is it nil?				AWC.PB457			Beq.S	NoSysP					; yes => we updateUseAppPltt	Move.L	(A0),A0					; dereference AppPalette or SysPalette		AWC.PB457			Move	pmPrivate(A0),D0		; get update information					AWC PB224			And		#$C000,D0				; and it with the proper flags				AWC PB224NoSysP		Move	D0,SysUpdates(A4)		; set update information					AWC PB224			Move	#JugglerTrap,D0			; #$A88F									AWC PB224			_GetTrapAddress					; find out what the trap is					AWC PB224			Move.L	A0,-(SP)				; save it									AWC PB224			Move	#UnimplementedTrap,D0	; #$A89F									AWC PB224			_GetTrapAddress					; where do unimplemented traps go			AWC PB224			CmpA.L	(SP)+,A0				; are we Juggler™ing?						AWC PB224			Beq.S	NotJuggling				; no => handle updates the old way			AWC PB224			Move.L	A2,-(SP)				; push device rect on the stack				AWC PB224			Move	CurDevice(A6),-(SP)		; push PaletteMgr device number				AWC PB224			Move	SysUpdates(A4),-(SP)	; push default updates for old ports		AWC PB224			Move	#ColorInvalRect,-(SP)	; push the selector for _ColorInvalRect		AWC PB224			_Juggler						; call Erich's disgusting C code			AWC PB224			bra		EndJuggling				; skip over the regular update code			AWC PB224NotJuggling	Move.L	WindowList,A3			; get start of window list					AWC PB224WindowLoop	Move	SysUpdates(A4),D1		; reset the default update value			AWC.PB480			Move	#CBackBit,D0			; grab a constant							AWC PB224			CmpA.L	WindowCopy(A6),A3		; is it us?			Bne.S	NotCurrent				; no => check for background updates			Move	#CForeBit,D0			; grab a different constant					AWC PB223NotCurrent	Tst.B	wVisible(A3)			; is this window visible?			Beq.S	NextWind				; no => do the next window					<C864>			Tst		PortBits+RowBytes(A3)	; is it a color window?			Bpl.S	UseDefault				; no => handle an old style window			AWC.PB480			Move.L	GrafVars(A3),A0			; get the extended variables handle			Move.L	(A0),A0					; dereference it			Move.L	PmFgColor(A0),A0		; get the window's palette, if any			CmpA.L	#Nil,A0					; is it nil?			Beq.S	UseDefault				; yes => default to the system value		AWC.PB480			Move.L	(A0),A0					; dereference the palette			Move	pmPrivate(A0),D1		; fetch the palette's update values			AWC.PB480UseDefault	BTst	D0,D1					; does the caller want this update?			AWC.PB480			Beq.S	NextWind				; no => do the next window; We now must check to see if the window we're examining intersects the device; we're working upon.  We'll GlobalToLocal the device rect and simultaneously; intersect it with the window's portRect.  If we detect an intersection then; we'll have calculated the rectangle we'll need for the InvalRect.  First we; point A0 at the Bounds rect for the port so we can put DevRect in local space.			Lea		PortBits(A3),A0				; point A0 at potential bitmap				AWC.PB480			Tst		RowBytes(A0)				; bitmap or pixmap?							AWC.PB480			Bpl.S	GotBitmap					; no high bit in Rowbytes => bitmap			AWC.PB480			Move.L	BaseAddr(A0),A0				; get Port's Pixmap handle					AWC.PB480			Move.L	(A0),A0						; get Pixmap pointer						AWC.PB480GotBitmap	Lea		Bounds(A0),A0				; advance A0 to Bounds rect					AWC.PB480			Move	Top(A2),D0					; get device top							AWC.PB480			Add		Top(A0),D0					; subtract bounds top						AWC.PB480			Cmp		PortRect+Bottom(A3),D0		; is Dest.Top >= Port.Bottom?				AWC.PB480			Bge.S	NextWind					; yes => no intersection					AWC.PB480			Move	D0,ResultRect+Top(A4)		; save it									AWC.PB480			Move	Left(A2),D0					; get device left							AWC.PB480			Add		Left(A0),D0					; subtract bounds left						AWC.PB480			Cmp		PortRect+Right(A3),D0		; is Dest.Left >= Port.Right?				AWC.PB480			Bge.S	NextWind					; yes => no intersection					AWC.PB480			Move	D0,ResultRect+Left(A4)		; save left									AWC.PB480			Move	Bottom(A2),D0				; get bottom								AWC.PB480			Add		Top(A0),D0					; subtract bounds top						AWC.PB480			Cmp		PortRect+Top(A3),D0			; is Dest.Bottom <= Port.Top?				AWC.PB480			Ble.S	NextWind					; yes => no intersection					AWC.PB480			Move	D0,ResultRect+Bottom(A4)	; save bottom								AWC.PB480			Move	Right(A2),D0				; get right									AWC.PB480			Add		Left(A0),D0					; subtract bounds left						AWC.PB480			Cmp		PortRect+Left(A3),D0		; is Dest.Right <= Port.Left?				AWC.PB480			Ble.S	NextWind					; yes => no intersection					AWC.PB480			Move	D0,ResultRect+Right(A4)		; save right								AWC.PB480			Move.L	A3,-(SP)					; push this window's pointer				AWC.PB480			_SetPort							; make it the current port					AWC.PB480			Pea		ResultRect(A4)				; move device rect (local) onto the stack	AWC.PB480			_InvalRect							; invalidate it								AWC.PB480NextWind	Move.L	NextWindow(A3),A3		; grab the next window in the list			CmpA.L	#Nil,A3					; is it nil?			Bne		WindowLoop				; no => continue			Bsr		RedrawDesktop			; redraw the desktop						AWC.PB508EndJuggling	Move.L	OldPort(A4),-(SP)		; push old port			_SetPort						; restore old portGoHome		MoveQ	#0,D0					; clear error condition						AWC.PB377			MoveM.L	(SP)+,D3-D5/A2-A3		; restore registers							<AWC>			Unlk	A4						; clear stack frame			Rts								; strip parameters and go home;---------------------------------------------------;; PROCEDURE CalcDevs; LOCAL;;CalcDevs	PROC	EXPORTResultRect	equ		-8						; temp rect									AWC PB223SpotLight	equ		ResultRect-2			; boolean for WindowCopy = FrontWindow		AWC PB223VarSize		equ		SpotLight				; bytes of variables						AWC PB223			Link	A4,#VarSize				; build stack frame							AWC PB223			MoveM.L D3-D5/A2-A3,-(SP) 		; save registers							AWC PB223			MoveQ	#0,D3					; clear device set							AWC PB223			MoveQ	#0,D4					; clear front set							AWC PB223; Point A0 at the Bounds rect of WindowCopy			Move.L	WindowCopy(A6),A3		; get window pointer						AWC PB223			Lea		PortBits(A3),A0			; point A0 at potential bitmap				AWC PB223			Tst		RowBytes(A0)			; is it a color window?						AWC PB223			Bpl.S	OldPort					; no => it's an old port					AWC PB223			Move.L	BaseAddr(A0),A0			; get Port's Pixmap handle					AWC PB223			Move.L	(A0),A0					; get Pixmap pointer						AWC PB223OldPort		Move.L	ScrnBase,D0				; get main screen							AWC PB223			Cmp.L	BaseAddr(A0),D0			; do we point at the main screen?			AWC PB223			Bne		GoHome					; no => it doesn't count; go home			AWC PB223			Lea		Bounds(A0),A0			; advance A0 to Bounds rect					AWC PB223			Lea		PortRect(A3),A1			; advance A1 to Port rect					AWC PB223; Calculate PortRect in global coordinates			Move	Top(A1),D0					; get port top							AWC PB223			Sub		Top(A0),D0					; subtract bounds top					AWC PB223			Move	D0,WindowRect+Top(A6)		; save it								AWC PB223			Move	Left(A1),D0					; get port left							AWC PB223			Sub		Left(A0),D0					; subtract bounds left					AWC PB223			Move	D0,WindowRect+Left(A6)		; save left								AWC PB223			Move	Bottom(A1),D0				; get port bottom						AWC PB223			Sub		Top(A0),D0					; subtract bounds top					AWC PB223			Move	D0,WindowRect+Bottom(A6)	; save bottom							AWC PB223			Move	Right(A1),D0				; get port right						AWC PB223			Sub		Left(A0),D0					; subtract bounds left					AWC PB223			Move	D0,WindowRect+Right(A6)		; save right							AWC PB223; Determine whether or not this is the FrontWindow			Clr		SpotLight(A4)			; SpotLight := false						AWC.PB485			Clr.L	-(SP)					; function result							AWC.PB223			_FrontWindow					; get the current front window				AWC.PB223			CmpA.L	(SP)+,A3				; is this FrontWindow?						AWC.PB223			Bne.S	NotSpotted				; no => continue							AWC.PB485			Move.B	wHilited(A3),SpotLight(A4)	; FrontWindow if highlighted			AWC.PB485NotSpotted	Move.L	PMgrHandle,A2			; get PMgrHandle							AWC PB223			Move.L	(A2),A2					; dereference it							AWC PB223			MoveQ	#0,D3					; clear Devices in D3						AWC PB223			Move	nDevs(A2),D5			; keep device number in D5					AWC PB223			Lea		DevHandles(A2),A2		; point to the first PMgr device			AWC PB223			Bra.S	DeviceEnd				; jump into calc loop						AWC PB223DeviceLoop	Move.L	(A2,D5.W*8),A0			; copy device handle						AWC PB223			Move.L	(A0),A0					; dereference it							AWC PB223			Clr		-(SP)					; boolean result of SectRect				AWC PB223			Pea		WindowRect(A6)			; port rect in global coordinates			AWC PB223			Pea		gdRect(A0)				; device rect								AWC PB223			Pea		ResultRect(A4)			; where to shove result						AWC PB223			_SectRect						; calculate intersection					AWC PB223			Move	(SP)+,D0				; do they intersect?						AWC PB223			Beq.S	DeviceEnd				; no => don't set device bit				AWC PB223			BSet	D5,D3					; set device bit in D3						AWC PB223			Move.L	PDevPtr(A6),A0			; get pointer to CLUT device list			AWC PB223			Tst.B	SpotLight(A4)			; is this the FrontWindow?					AWC PB223			Beq.S	CheckPrior				; no => see if it is FrontMost instead		AWC PB223			Move.L	A3,DevFrontMost(A0,D5*8); save it as the new FrontMost				AWC PB223			Bra.S	SetFront				; and skip ahead							AWC PB223CheckPrior	CmpA.L	DevFrontMost(A0,D5*8),A3; is this window frontmost on this device?	AWC PB223			Bne.S	DeviceEnd				; no => don't set frontmost bit				AWC PB223SetFront	BSet	D5,D4					; set frontmost bit in D4					AWC PB223DeviceEnd	DBra	D5,DeviceLoop			; check next device							AWC PB223GoHome		Move.L	D3,DeviceSet(A6)		; save device set							AWC PB223			Move.L	D4,FrontSet(A6)			; save frontmost set						AWC PB223			MoveM.L (SP)+,D3-D5/A2-A3		; restore registers							AWC PB223			Unlk	A4						; clear stack frame							AWC PB223			Rts								; strip parameters and go home				AWC PB223;---------------------------------------------------;; PROCEDURE	ActivatePalette(dstWindow: WindowPtr); INLINE $AA94;;ActivatePalette	PROC	EXPORTParamSize	equ		4						; total bytes of paramsdstWindow	equ		ParamSize+8-4			; source Palette handle; The ActivatePalette stack frame is defined at the global level so it can be accessed; by each of the routines subsidiary to ActivatePalette and thereby avoid gross parameter; passing.  All such subsidiary routines will link with A4 and not A6 thus keeping; ActivatePalette's stack frame intact.  D3 is used to hold any error condition.; It is moved to D0 before we quit.			Link	A6,#spVarSize			; build stack frame			MoveM.L D3-D4/A2-A4,-(SP) 		; save registers						MoveQ	#1,D3					; set error flag in case we branch			Move.L	PMgrHandle,A2			; get global handle			CmpA.L	#PMgrNil,A2				; is it nil?			Beq		GoHome					; it has to be initialized						Move.L	(A2),A0					; dereference PMgrHandle				AWC.PB500			Move	nDevs(A0),D0			; are there any clut devices?			AWC.PB500			Beq		GoHome					; no => punt							AWC.PB500			Move.L	dstWindow(A6),A3		; get the window pointer			CmpA.L	#Nil,A3					; is it real?			Beq		GoHome					; no => go home 						<AWC/PB150>			Move.L	A3,WindowCopy(A6)		; save a copy for those who need it			Tst		PortBits+RowBytes(A3)	; is it a new port?			Bpl.S	TrySystem				; no => try for a system palette			Move.L	GrafVars(A3),A0			; get the GrafVars handle			Move.L	(A0),A0					; dereference it			Move.L	PmFgColor(A0),A3		; save the palette handle in GrafVars			CmpA.L	#Nil,A3					; is it nil?			Bne.S	FoundPltt				; no => we've found itTrySystem	Move.L	AppPalette,A3			; get the layer's palette, if any			AWC.PB457			Move.L	A3,D0					; CmpA.L #Nil,A0; is AppPalette nil?		AWC.PB457			Bne.S	FoundPltt				; no => use AppPalette						AWC.PB457			Move.L	(A2),A0					; dereference PMgrHandle			Move.L	SysPalette(A0),A3		; get the system palette, if any			Move.L	A3,D0					; CmpA.L #Nil,A3; is SysPalette nil?		AWC.PB457			Beq		GoHome					; yes => we can't do itFoundPltt	Move.L	A3,PaletteH(A6)			; save the palette for later; past this point we will have locked PMgrHandle and PaletteH.  We also save theGDevice; and clear the InfoHandle variable.			Move.L	A2,A0					; copy PMgrHandle			_HLock							; lock it down			Move.L	A3,A0					; copy PaletteH			_HLock							; lock it down as well			Move.L	(A2),A4					; dereference PMgrHandle			Move.L	A4,PMgrPtr(A6)			; save a copy of the pointer			Move.L	PListHandle(A4),A0		; get PListHandle			_HLock							; lock it down			Move.L	(A0),PListPtr(A6)		; save pointer to palette list			Move	nDevs(A4),Devices(A6)	; save number of devices in our list			Lea		DevHandles(A4),A0		; point A4 at first device handle			Move.L	A0,PDevPtr(A6)			; save pointer to start of device list			Move.L	theGDevice,SaveGDev(A6)	; save theGDevice handle			Clr.L	InfoHandle(A6)			; mark it as unallocated			Move.L	(A3),A4					; dereference PaletteH			Move.L	A4,PalettePtr(A6)		; save it for posterior			Move	pmEntries(A4),D4		; fetch number of entries			Move	D4,myEntries(A6)		; save it for posterity			Clr		MAnimators(A6)			; MAnimators := 0			Clr		MTolerators(A6)			; MTolerators := 0; Check to see on which devices the window is now rendered			Jsr		CalcDevs				; determine the new and frontmost device sets			Tst.L	FrontSet(A6)			; is this window frontmost on any device?			Beq		NoFunStuff				; no => skip our wonderful rendering code			; Count the number of animating and tolerant colors.  Mark explicit, dithered, and; courteous colors as "handled" so we won't bother with them in SetDev et al.			Lea		pmInfo(A4),A4			; point us at the first ColorInfo			Bra.S	ExamEnd					; jump into DBra loopExamLoop	Move	ciUsage(A4),D1			; copy ciUsage field of current entry			Cmp		#pmDithered,D1			; is it pmDithered or pmCourteous?			Ble.S	HandleColor				; pmCourteous => mark as handled			BTst	#ExplicitBit,D1			; pmExplicit?			Bne.S	HandleColor				; yes => mark it as handled, too			BTst	#AnimatedBit,D1			; pmAnimated?			Beq.S	CheckTolrnt				; no => check for other kinds of usage			AddQ	#1,MAnimators(A6)		; bump number of animating colors			Bra.S	NextColor				; continue; Any color which can match black or white within tolerance is removed from consideration.; We guarantee that black and white will be around, so as long as you don't have to change; their values you can match them normally.  When we correlate colors we won't allow you; to match black or white because we'll know you would have to change them.CheckTolrnt	AddQ	#1,MTolerators(A6)		; yes => bump number of tolerant colors			Bra.S	NextColor				; continueHandleColor	BSet	#HandledBit,ciUsage(A4)	; mark explicit and normal colors as handledNextColor	Add		#ciSize,A4				; bump address to next ColorInfoExamEnd		DBra	D4,ExamLoop				; loop for all pmEntries; See if we have any animating or tolerant entries.  If not, we can skip most of this			Move	MAnimators(A6),D0		; do we have any animating					AWC PB223			Or		MTolerators(A6),D0		; or tolerant entries?						AWC PB223			Beq		NoFunStuff				; no => just clean up the world				AWC.PB508; Allocate a scratch buffer			Move.L	#InfoHandSz,D0			; size of our scratch area					AWC			_NewHandle	,CLEAR				; allocate a scratch area			Bne		UnlockEm				; we couldn't get it - D3 still says "error" AWC.PB508			Move.L	A0,InfoHandle(A6)		; save it			_HLock							; lock it			Move.L	(A0),A0					; dereference it			Move.L	A0,InfoPtr(A6)			; save dereferenced ptr; Call SetDev to render or record the Palette on each device, as appropriate.;			Clr.L	DeviceSet(A6)					; zero bitmap of devices			MoveQ	#0,D4							; clear device counter			Clr		GrayRgnPrep(A6)					; GrayRgnPrep := false				AWC.PB508DeviceLoop	Move.L	FrontSet(A6),D0					; grab the front device set			AWC PB223			BTst	D4,D0							; frontmost on this clut device?	AWC PB223			Beq.S	NoDevError						; no => jump across SetDev			AWC PB223			Move	MAnimators(A6),Animators(A6)	; copy MAnimators			Move	MTolerators(A6),Tolerators(A6)	; copy MTolerators			Move	D4,CurDevice(A6)				; copy it for SetDev			Jsr		SetDev							; render palette; did we get an error?			Beq.S	NoDevError						; did we find an error?			AddQ	#1,D3							; bump our error countNoDevError	AddQ	#1,D4							; we've examined another device			Cmp		Devices(A6),D4					; have we done them all			Bmi.S	DeviceLoop						; no => do another			Move.L	SaveGDev(A6),theGDevice			; restore theGDevice handle			AWC.PB508			Move	GrayRgnPrep(A6),D0				; see how we faired on the desktop	AWC.PB508			Beq.S	NoFunStuff						; no => nothing to do				AWC.PB508			Cmp		#-1,D0							; did we detect no work to do?		AWC.PB508			Beq.S	NoFunStuff						; yes => nothing to do				AWC.PB508			SubQ.L	#4,SP							; open room for the old port		AWC.PB520			Pea		(SP)							; push a pointer to that location	AWC.PB520			_GetPort								; save the old port					AWC.PB520			Move.L	WMgrCPort,-(SP)					; gpush WMgrPort for SetPort		AWC.PB520			_SetPort								; do it								AWC.PB520			Move.L	DeskRgn(A6),-(SP)				; push DeskRgn						AWC.PB520			_SetClip								; clip to DeskRgn					AWC.PB520			Clr.L	-(SP)							; push nil							AWC.PB520			_ClipAbove								; set GrayRgn						AWC.PB520			Move.L	DeskHook,D0						; is there a DeskHook?				AWC.PB520			Bne.S	CallHook						; yes => call the deskhook			AWC.PB508			Clr.L	-(SP)							; push nil							AWC.PB508			Move.L	DeskRgn(A6),-(SP)				; push DeskRgn						AWC.PB508			_PaintOne								; update the desktop				AWC.PB508			Bra.S	RestorePort						; catch up with the latest news		AWC.PB520CallHook	Move.L	D0,A0							; put DeskHook address into A0		AWC.PB508			MoveQ	#0,D0							; pass a paint message in D0		AWC.PB508			Jsr		(A0)							; let the Hook do the painting		AWC.PB508RestorePort	_SetPort								; pop the old port					AWC.PB520			Move.L	DeskRgn(A6),-(SP)				; push DeskRgn						AWC.PB508			_DisposRgn								; get rid of it						AWC.PB508NoFunStuff	Move.L	PMgrPtr(A6),A0			; get the PMgrHandle pointer				AWC PB223			Move.L	PListHandle(A0),A0		; get the PListHandle			Move.L	(A0),A0					; dereference it			Move.L	PalettePtr(A6),A1		; get the Palette			Move	pmPrivate(A1),D0		; get the entry number			And		#PIdMask,D0				; clear the flag bits			Move	Reserves(A0,D0.W*8),D0	; does this palette have anything reserved?			Beq.S	NoneRsrvd				; no => forget about clearing				AWC PB223; Clear any unused devices and update device bitmap			Move.L	PalettePtr(A6),A0		; get palette pointer			Move.L	pmDevices(A0),D0		; get former device set			Move.L	DeviceSet(A6),D1		; get new device set			Not.L	D1						; complement the current set			And.L	D1,D0					; remove any current bits			Beq.S	NoneRsrvd				; if none needing unreserving, quit; STAGE 1 - implement;; Loop, clearing each device we once did but no longer touch.  This is a good thing to; add in the future.  For now, it won't have a lot of impact.  The entries it still has; reserved can always be pillaged by somebody else if they need them.  But, in the next; version we shall release entries as we move off a device.			NopNoneRsrvd	Move.L	DeviceSet(A6),pmDevices(A1)	; copy the new device set			SubQ	#1,D3					; if now 0 then we got through with no errorsUnlockEm	Move.L	PMgrPtr(A6),A0			; get the master pointer			Move.L	PListHandle(A0),A0		; get this handle			_HUnlock						; unlock it			Move.L	A2,A0					; copy PMgrHandle			_HUnLock; clear the dirty bit and restore the user's ciUsage fields			Move.L	PalettePtr(A6),A0		; get Palette pointer			BClr	#DirtyBit,pmPrivate(A0)	; clear the dirty bit			Move	pmEntries(A0),D0		; fetch number of entries			Lea		pmInfo(A0),A0			; point us at the first ColorInfo			Bra.S	UnsetEnd				; jump into DBra loopUnsetLoop	Move	ciUsage(A0),D1			; copy ciUsage field of current entry			And		#ClearBits,D1			; clear all but the user's flags			Move	D1,ciUsage(A0)			; restore it			AddA.L	#ciSize,A0				; bump A4 to the next color infoUnsetEnd	DBra	D0,UnsetLoop			; loop for all pmEntries ColorInfo's			Move.L	A3,A0					; copy PaletteHandle to A0			_HUnlock						; unlock it			Move.L	InfoHandle(A6),A0		; get scratch handle			CmpA.L	#Nil,A0					; was it allocated			Beq.S	NoError					; no => don't dispose it			_DisposHandle					; get rid of itNoError		MoveQ	#0,D3					; clear error flagGoHome		Move.L	D3,D0					; copy error flag			MoveM.L (SP)+,D3-D4/A2-A4		; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE DirtySeeds(dstPalette: PaletteHandle); LOCAL;;DirtySeeds	PROC	EXPORTParamSize	equ		4						; total bytes of paramsdstPalette	equ		ParamSize+8-4			; destination Palette handleVarSize		equ		0						; size of variables			Link	A6,#VarSize				; build stack frame							AWC.PB508			Move.L	PMgrHandle,A0			; get the PMgrHandle (we assume its safe)	AWC.PB508			Move.L	(A0),A0					; dereference it							AWC.PB508			Move	SeedHSize(A0),D0		; get the seed handle size					AWC.PB508			Lsr		#2,D0					; divide it by 4 to get number of longs		AWC.PB508			SubQ	#1,D0					; decrement it for the DBra loop			AWC.PB508			Move.L	DstPalette(A6),A0		; get the palette							AWC.PB508			Move.L	(A0),A0					; dereference it							AWC.PB508			BSet	#DirtyBit,pmPrivate(A0)	; set the dirty bit							AWC.PB508			Move.L	pmSeeds(A0),A0			; get the seeds handle						AWC.PB508			Move.L	(A0),A0					; dereference it							AWC.PB508ClearLoop	Clr.L	(A0)+					; clear a seed								AWC.PB508			DBra	D0,ClearLoop			; continue									AWC.PB508GoHome		Unlk	A6						; clear stack frame							AWC.PB508			Rtd		#ParamSize				; strip parameters and go home				AWC.PB508			;---------------------------------------------------;; PROCEDURE SetPalette(dstWindow: WindowPtr; srcPalette: PaletteHandle; CUpdates: BOOLEAN);;	INLINE $AA95;;SetPalette	PROC	EXPORTParamSize	equ		10						; total bytes of paramsdstWindow	equ		ParamSize+8-4			; source Palette handlesrcPalette	equ		dstWindow-4				; new window, if anyCUpdates	equ		srcPalette-2			; whether we want background color updatesVarSize		equ		0						; size of variables			Link	A6,#VarSize				; build stack frame			Move.L	PMgrHandle,A1			; we have to be initialized			CmpA.L	#PMgrNil,A1				; is it initialized?			Beq		GoHome					; no => punt			Move.L	dstWindow(A6),A0		; get the window pointer			CmpA.L	#-1,A0					; does the caller want to set AppPalette?			Bne.S	NotSystem				; no => go look for the window			Move.L	AppPalette,D0			; get the application palette; is it nil?	AWC.PB457			Beq.S	NoAppPltt				; yes => don't dispose it					AWC.PB457			Move.L	D0,A0					; put it in an address register				AWC.PB457			Move.L	(A0),A0					; dereference it							AWC.PB457			BTst	#DisposeBit,pmPrivate(A0)	; should we clobber it?					AWC.PB457			Beq.S	NoAppPltt					; no => the caller deals with it		AWC.PB457			Move.L	D0,-(SP)					; push the palette						AWC.PB457			_DisposePalette						; can you say "bye bye"?				AWC.PB457NoAppPltt	Move.L	SrcPalette(A6),A0		; get the palette parameter					AWC.PB457			Move.L	A0,AppPalette			; set the layer palette; is it nil?			AWC.PB457			Bne.S	AppNotNil				; no => activate the layer palette			AWC.PB457			Move.L	(A1),A0					; dereference PMgrHandle					AWC.PB457			Move.L	SysPalette(A0),A0		; get the system palette					AWC.PB457			Move.L	A0,D0					; CmpA.L #Nil,A0; is it nil?				AWC.PB457			Beq.S	GoHome					; yes => shouldn't happen, but quit anyway	AWC.PB457AppNotNil	Move.L	A0,-(SP)				; push the palette pointer					AWC.PB508			Bsr		DirtySeeds				; clear the device seeds so we'll update	AWC.PB508			Clr.L	-(SP)					; push function result						AWC.PB439			_FrontWindow					; push the front window						AWC.PB439			Bra.S	DontClear				; activate it								AWC PB223NotSystem	Tst		PortBits+RowBytes(A0)	; is it a new port?			Bpl.S	GoHome					; if not, we're out of here			Move.L	srcPalette(A6),D0		; get the palette handle			Move.L	GrafVars(A0),A1			; get handle to GrafVars			Move.L	(A1),A1					; dereference GrafVars			Move.L	PmFgColor(A1),D1		; save whatever's there currently			Move.L	D0,PmFgColor(A1)		; store the palette in GrafVars.PmFgColor; is it nil?			Beq.S	BitsOkay				; yes => that's okay, but we won't dereference it			Move.L	D0,A1					; put the Palette handle into A1			Move.L	(A1),A1					; dereference it;			Move.L	A0,pmWindow(A1)			; store the window in the palette			AWC.PB439						BClr	#CBackBit,PmPrivate(A1)	; clear background update bit				AWC PB223			BSet	#CForeBit,PmPrivate(A1)	; set foreground update bit					AWC PB223			Tst.B	CUpdates(A6)			; does she want background updates?			AWC PB223			Beq.S	BitsOkay				; 0 => default case, CUpdates = false		AWC PB223			Bpl.S	AllowBacks				; 1 => CUpdates = true						AWC PB223			BTst	#NForeBit,CUpdates(A6)	; does he want foreground updates?			AWC PB223			Bne.S	YesFores				; yes => leave it as is						AWC PB223			BClr	#CForeBit,PmPrivate(A1)	; turn foreground updates off				AWC PB223YesFores	BTst	#NBackBit,CUpdates(A6)	; does she want background updates?			AWC PB223			Beq.S	BitsOkay				; no => skip it								AWC PB223AllowBacks	BSet	#CBackBit,PmPrivate(A1)	; set the foreground update bit				AWC PB223BitsOkay	Cmp.L	D0,D1					; are they identical?						AWC PB223			Beq.S	GoHome					; don't bother activating anything			Move.L	A0,-(SP)				; push the window pointer for the activate palette			Tst.L	D1						; is this nil?			Beq.S	DontClear				; don't clear it			Move.L	D1,A0					; copy it to an address register			AWC.PB457			Move.L	(A0),A0					; dereference it							AWC.PB457			BTst	#DisposeBit,pmPrivate(A0)	; should we dispose it?					AWC.PB457			Beq.S	DontClear				; no => leave it alone						AWC.PB457			Move.L	D1,-(SP)				; push the old handle			_DisposePalette					; can you say "bye bye"?  I knew you could	AWC.PB457DontClear	_ActivatePalette				; set the palette if it happens to be FrontWIndowGoHome		Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; FUNCTION GetPalette(srcWindow: WindowPtr) : PaletteHandle; INLINE $AA96;;GetPalette	PROC	EXPORTParamSize	equ		4						; total bytes of paramsGetResult	equ		ParamSize+12-4			; result palette handlesrcWindow	equ		GetResult-4				; source window to help find the paletteVarSize		equ		0						; size of variables			Link	A6,#VarSize				; build stack frame			Clr.L	GetResult(A6)			; clear the result handle			Move.L	PMgrHandle,A1			; we have to be initialized			CmpA.L	#PMgrNil,A1				; is it initialized?			Beq.S	GoHome					; no => punt			Move.L	srcWindow(A6),A0			; get the window pointer			CmpA.L	#Nil,A0						; is it real?			Beq.S	GoHome						; no => punt			CmpA.L	#-1,A0						; do they want the system palette?			Bne.S	NotSystem					; no, not the system			Move.L	AppPalette,GetResult(A6)	; grab AppPalette; is it nil?			AWC.PB457			Bne.S	GoHome						; no => we're done						AWC.PB457			Move.L	(A1),A1					; dereference PMgrHandle					AWC.PB457			Move.L	SysPalette(A1),A0		; get SysPalette							AWC.PB457			Move.L	A0,D0					; CmpA.L #Nil,A0; is it nil?				AWC.PB457			Beq.S	GoHome					; yes => how did this happen? oh well, quit	AWC.PB457			_HandToHand						; make a copy of it							AWC.PB457			Tst		D0						; did the call succeed?						AWC.PB457			Bne.S	GoHome					; no => go home with result nil				AWC.PB457			Move.L	A0,AppPalette			; now we'll use the copy					AWC.PB457			Move.L	A0,GetResult(A6)		; give them the copy's handle				AWC.PB457			Move.L	A0,-(SP)				; push the handle for RecordPalette			AWC.PB457			Move.L	(A0),A0					; dereference it							AWC.PB457			Clr.L	pmSeeds(A0)				; kill the copy of the seeds handle			AWC.PB457			BClr	#DisposeBit,pmPrivate(A0)	; caller must now dispose it			AWC.PB457			Jsr		RecordPalette			; insert it into our list of known things	AWC.PB457			Beq.S	GoHome					; scurry out of here						AWC.PB457			Clr.L	AppPalette				; sorry, it failed							AWC.PB457			Clr.L	GetResult(A6)			; so clear the result, too					AWC.PB457			Bra.S	GoHome					; continue									AWC.PB457NotSystem	Tst		PortBits+RowBytes(A0)	; is it a new port?			Bpl.S	GoHome					; if not, we're out of here			Move.L	GrafVars(A0),A0			; get handle to GrafVars			Move.L	(A0),A0					; dereference GrafVars			Move.L	PmFgColor(A0),A0		; get the palette							AWC.PB457			Move.L	A0,GetResult(A6)		; give it to the caller; is it nil?			AWC.PB457			Beq.S	GoHome					; yes => don't bother with the dispose flag	AWC.PB457			Move.L	(A0),A0					; dereference it							AWC.PB457			BClr	#DisposeBit,PmPrivate(A0)	; turn off the auto dispose				AWC.PB457GoHome		Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home				;---------------------------------------------------;; PROCEDURE	FindIndex; IMMEDIATE;;;	On entry:;		A2 - Palette pointer;		A3 - ColorInfo;;	On exit:;		D0 - index of animating entry; 0 if not found (0 is illegal for animation)FindIndex	PROC	EXPORT			MoveM.L	D3/D4,-(SP)				; save registers			Move	ciPrivate(A3),D0		; get link info			BfExtU	D0{16:3},D1				; grab top 3 bits			Cmp		#4,D1					; are they set correctly			Bne.S	BadIndex				; no => the LinkInfo is invalid			Move.L	PMgrHandle,A0			; get main handle			CmpA.L	#PMgrNil,A0				; is it nil?			Beq.S	BadIndex				; yes => punt			Move.L	(A0),A0					; dereference the palette manager			Move	nDevs(A0),D3			; get number of devices to search in D3			Beq.S	BadIndex				; no devices => can't animate				AWC.PB500			Lea		DevHandles(A0),A1		; point A1 at the device info stuff			Bra.S	DevEnd					; jump into loopDevLoop		Move.L	DevHandle(A1,D3.W*8),D4	; get device handle			Cmp.L	theGDevice,D4			; is this it?			Beq.S	FoundDevice				; yes => continueDevEnd		DBra	D3,DevLoop				; no => look at another device			Bra.S	BadIndex				; we fell through - puntFoundDevice	Move	nDevs(A0),D4			; get number of devices, this time as a watchdog			AddA.L	#LinkTabs,A0			; bump A0 to the base of LinkTabs			Bra.S	IndexEnd				; start watchdog loop			IndexLoop	BfExtU	D0{19:5},D1				; grab device number (0..31)			BfExtU	D0{24:8},D2				; grab index number (0..255)			Cmp		D3,D1					; is it this device?			Beq.S	FoundIndex				; yes => we've got it			Lsl		#8,D1					; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Move	ForeLink(A0,D1.L*4),D0	; get next link; is the top bit set?			Bpl.S	BadIndex				; no => stop because we ran out of triesIndexEnd	DBra	D4,IndexLoop			; examine another index until our watchdog runs outBadIndex	Bra.S	SetBadIndex				; set index to "illegal"		AWC.PB377; We found the index.  Ensure that we don't exceed the bit depth, set "true" by returning; a value <> 0.FoundIndex	And		#$00FF,D2				; clear everything except the index			Move	D2,D0					; set the result				AWC.PB377			Move.L	theGDevice,A0			; get theGDevice				AWC.PB377 			Move.L	(A0),A0					; dereference it				AWC.PB377 			Move.L	gdPMap(A0),A0			; get handle to pixmap			AWC.PB377 			Move.L	(A0),A0					; dereference pixmap			AWC.PB377 			Move.L	pmTable(A0),A0			; get handle to CTab			AWC.PB377 			Move.L	(A0),A0					; dereference color table		AWC.PB377 			Cmp		ctSize(A0),D0			; compare link to maximum index	AWC.PB377			Blt.S	GoHome					; if D0-ctSize <= 0 then cool	AWC.PB480SetBadIndex	MoveQ	#0,D0					; set index to "illegal" white	AWC.PB377GoHome		MoveM.L (SP)+,D3/D4		 		; restore registers			Rts								; go home;---------------------------------------------------;; PROCEDURE	PmForeColor(dstEntry: INTEGER); INLINE $AA97;;PmForeColor		PROC	EXPORT				EXPORT	PmBackColor; In most cases we can rely upon RGBForeColor to do all the work for us.  If a simple color,; it's the perfect thing to call.  If a true color, SetPalette did the important work for us; and it's still correct.  If it's an animating entry, we might not be on a device which can; animate this color, so we want the foreground color preestablished so we can just quit if; our attempt to use an animating entry fails.;; STAGE 2 - dithering patterns are not yet providedParamSize	equ		2						; total bytes of paramsdstEntry	equ		ParamSize+8-2			; which entry to use Palette handleCallType	equ		-2						; foreground = 1, background = 0PWindow		equ		CallType-4				; window pointerGrafVarsPtr	equ		PWindow-4				; GrafVars^SrcPalette	equ		GrafVarsPtr-4			; whichever palette we decide to use		AWC.PB520VarSize		equ		SrcPalette				; size of local variables					AWC.PB520			MoveQ	#1,D0					; we're coming from PmForeColor			Bra.S	PmSetColor				; share codePmBackColor	MoveQ	#0,D0					; we're coming from PmBackColorPmSetColor	Link	A6,#VarSize				; build stack frame			MoveM.L A2-A3,-(SP) 			; save registers			Move	D0,CallType(A6)			; save the type of call			Move.L	PMgrHandle,A1			; get the main handle			CmpA.L	#PMgrNil,A1				; are we initialized?			Beq		GoHome					; no => punt								AWC.PB377			Move.L	GrafGlobals(A5),A0		; get the QuickDraw globals pointer			Move.L	ThePort(A0),A0			; point at the port			Tst		PortBits+Rowbytes(A0)	; is it a new port?			Bpl		GoHome					; no => punt								AWC.PB377			Move.L	A0,PWindow(A6)			; save it because we use it several times			Move.L	GrafVars(A0),A0			; get the data handle			Move.L	(A0),A0					; dereference it			Move.L	A0,GrafVarsPtr(A6)		; save GrafVars pointer for later			AWC.PB508			Move.L	PmFgColor(A0),A2		; get the palette handle (finally)			Move.L	A2,D0					; CmpA.L #Nil,A2; is there a palette?		AWC.PB508			Bne.S	FoundAPltt				; yes => we're cool so far					AWC.PB508			Move.L	AppPalette,A2			; grab the AppPalette for use				AWC.PB508			Move.L	A2,D0					; CmpA.L #Nil,A2; is there an AppPalette	AWC.PB508			Beq		GoHome					; no => punt								AWC.PB508FoundAPltt	Move.L	A2,SrcPalette(A6)		; save it so we can unlock it				AWC.PB520			Move.L	A2,A0					; put the handle into A0					AWC.PB520			_HLock							; lock it down								AWC.PB520			Move.L	(A2),A2					; dereference myPalette						AWC.PB508			MoveQ	#0,D0					; clear the high word			Move	dstEntry(A6),D0			; capture the index			Cmp		pmEntries(A2),D0		; D0 - pmEntries; is myEntry out of range?			Bhs		UnlockPltt				; yes, so we quit							AWC.PB520			Asl.L	#4,D0					; multiply by record size of 16			Lea		pmInfo(A2,D0.L),A3		; set A3 to entry's ColorInfo			Pea		ciRGB(A3)				; push address of ciRGB field			Tst		CallType(A6)			; was it a background call			Bne.S	DoForegrnd				; no => do the foreground call			_RGBBackColor					; yes => do the background call			Bra.S	DoContinue				; keep goingDoForegrnd	_RGBForeColor					; let this do almost all the workDoContinue	Move	ciUsage(A3),D1			; get flags			MoveQ	#0,D0					; clear high word			Move	dstEntry(A6),D0			; set D0 in case it is an explicit index			BTst	#ExplicitBit,D1			; is it explicit?			Bne.S	DoExplicit				; yes => blast index into port			MoveQ	#0,D0					; set no error in case we go home			BTst	#AnimatedBit,D1			; no => test animation bit			Beq.S	UnlockPltt				; yes => we're done							AWC.PB520			Jsr		FindIndex				; uses our registers - put reserved index in D0			Tst		D0						; was the result "white"?			Beq.S	FixPort					; yes => give up, but set up the port first			Bra.S	ShoveIndex				; share common codeDoExplicit	Move.L	theGDevice,A0			; get theGDevice			Move.L	(A0),A0					; dereference it			Cmp		#directType,gdType(A0)	; is it a direct device?					AWC.PB530			Beq.S	UnlockPltt				; yes => we're done							AWC.PB530			Move.L	gdPMap(A0),A0			; get handle to pixmap			Move.L	(A0),A0					; dereference pixmap			Move.L	pmTable(A0),A0			; get handle to CTab			Move.L	(A0),A0					; dereference color table			And		ctSize(A0),D0			; and D0 with maximum indexShoveIndex	Move.L	PWindow(A6),A0				; get the window pointer again			Tst		CallType(A6)				; foreground? 							AWC.PB377			Beq.S	SetBackgrnd					; no => set background 					AWC.PB377			Move.L	D0,FgColor(A0)				; jam the index			Bra.S	FixPort						; continue 								AWC.PB377SetBackgrnd	Move.L	D0,BkColor(A0)				; jam the index 						AWC.PB377FixPort		Move.L	GrafVarsPtr(A6),A0			; get the GrafVars pointer again			Tst		CallType(A6)				; was it background?			Beq.S	DoBackgrnd					; yes => set background information			Move	dstEntry(A6),PmFgIndex(A0)	; save the entry number			BSet	#PmFgBit,PmFlags+1(A0)		; tell the world that we set the FgColor			Bra.S	UnlockPltt					; clean up and go home					AWC.PB520DoBackgrnd	Move	dstEntry(A6),PmBkIndex(A0)	; save the entry number			BSet	#PmBkBit,PmFlags+1(A0)		; tell the world that we set the BkColorUnlockPltt	Move.L	SrcPalette(A6),A0			; get whichever palette we used			AWC.PB520			_HUnlock							; unlock it								AWC.PB520GoHome		MoveQ	#0,D0						; no error			MoveM.L (SP)+,A2-A3					; restore register			Unlk	A6							; clear stack frame			Rtd		#ParamSize					; strip parameters and go home;---------------------------------------------------;; PROCEDURE AnimateEntry(dstWindow: WindowPtr; dstEntry: INTEGER; srcRGB: RGBColor); INLINE $AA99;;AnimateEntry	PROC	EXPORTParamSize	equ		10						; total bytes of params				<AWC>dstWindow	equ		ParamSize+8-4			; target window						<AWC>dstEntry	equ		dstWindow-2				; palette entry to animate			<AWC>srcRGB		equ		dstEntry-4				; new color to useSaveGDev	equ		-4						; room for saving theGDeviceMc			equ		SaveGDev-6				; RGBColorOldSeed		equ		Mc-4					; old color table seedVarSize		equ		OldSeed					; size of the variables			Link	A6,#VarSize				; build stack frame			MoveM.L D3-D5/A2-A4,-(SP) 		; save registers			Move.L	PMgrHandle,A3			; get the main handle			CmpA.L	#PMgrNil,A3				; are we initialized?			Beq		GoHome					; no => punt								AWC.PB377			Move.L	dstWindow(A6),A0		; get the target window			CmpA.L	#Nil,A0					; is it nil?			Beq		GoHome					; yes => we're done							AWC.PB377			Tst		PortBits+Rowbytes(A0)	; is it a new port?			Bpl		GoHome					; no => punt								AWC.PB377			Move.L	GrafVars(A0),A0			; get the data handle			Move.L	(A0),A0					; dereference it			Move.L	PmFgColor(A0),A2		; get the palette handle (finally)			Move.L	A2,D0					; CmpA.L #Nil,A2; is there a palette?		AWC.PB508			Bne.S	FoundAPltt				; yes => use it								AWC.PB508			Move.L	AppPalette,A2			; look for an AppPalette					AWC.PB508			Move.L	A2,D0					; CmpA.L #Nil,A2; is there an AppPalette?	AWC.PB508			Beq		GoHome					; no => punt								AWC.PB377FoundAPltt	Move.L	(A2),A0					; dereference the palette					AWC.PB508			Move	pmEntries(A0),D0		; get the number of entries			MoveQ	#0,D1					; clear high word			Move	dstEntry(A6),D1			; get the index			Cmp		D0,D1					; is the index in range?			Bhs		GoHome					; no => we're done							AWC.PB377			Lsl		#4,D1						; multiply by ciSize			Lea		pmInfo(A0,D1.L),A2			; point A2 at the entry			BTst	#ExplicitBit,ciUsage+1(A2)	; is it explicit?			Bne		GoHome						; yes => by definition not animating			BTst	#AnimatedBit,ciUsage+1(A2)	; is it animating?			Beq		GoHome						; no => quit; Copy the colors to the palette before we check to see if we have links or not so that it; will get copied even if we have no 'clut' devices			Move.L	srcRGB(A6),A0				; get pointer to his RGB				AWC.PB500			Move.L	red(A0),D0					; copy red and green					AWC.PB500			Move.L	D0,ciRGB+red(A2)			; copy it to the palette				AWC.PB500			Move.L	D0,mc+red(A6)				; save red and green on the stack		AWC.PB500			Move	blue(A0),D0					; copy blue								AWC.PB500			Move	D0,ciRGB+blue(A2)			; copy it to the palette				AWC.PB500			Move	D0,mc+blue(A6)				; save blue on the stack				AWC.PB500			Move	ciPrivate(A2),D3		; get the ForeLink field			BfExtu	D3{16:3},D1				; get the key bits			Cmp		#4,D1					; were they 100?			Bne		GoHome					; no => not a valid ForeLink; go home; Now, finally, we have something to do.  Let's follow those links and see where they take us			Move.L	A3,A0						; copy PMgrHandle			_HLock								; lock it down			Move.L	theGDevice,SaveGDev(A6)		; save it;	Register usage:;;		D0 : holds ForeLink temporarily;		D3 : holds device number;		D4 : holds index number;		D5 : watchdog loop counter;;		A2 : base address of LinkTabs;		A3 : PMgrHandle (locked);		A4 : base address of DevHandles						Move.L	(A3),A2					; dereference PMgrHandle			Move	nDevs(A2),D5			; maximum number of devices (watchdog counter)			Lea		DevHandles(A2),A4		; point A4 at the device list			AddA.L	#LinkTabs,A2			; point A2 at start of LinkTabs			Move	D3,D0					; copy ForeLink into D0			Bra.S	DevEnd					; jump into the loopDevLoop		BfExtU	D0{19:5},D3				; grab device number (0..31)			BfExtU	D0{24:8},D4				; grab index number (0..255)			Move.L	DevHandle(A4,D3.W*8),A0	; get the device handle			Move.L	A0,theGDevice			; now we're on that device			Move.L	(A0),A0					; dereference it			Clr		gdId(A0)				; no client id's, please			Move.L	gdPMap(A0),A0			; get handle to pixmap			Move.L	(A0),A0					; dereference pixmap			Move.L	pmTable(A0),A0			; get handle to CTab			Move.L	(A0),A0					; dereference CTab			Move	ctSize(A0),D0			; grab number of entries - 1			Cmp		D4,D0					; compare our index to the max index			Ble.S	NextDevice				; out of range => look at next device		AWC.PB480			Move.L	ctSeed(A0),OldSeed(A6)	; save the seed so we can restore it			Move.L	mc+red(A6),ctTable+RGB+red(A0,D4.W*8)			Move	mc+blue(A6),ctTable+RGB+blue(A0,D4.W*8); Now perform a sequential _SetEntries using the device's color table as the source			Clr		-(SP)					; push starting count of 0 for SetEntries			Move	D0,-(SP)				; push number of entries-1			Pea		ctTable(A0)				; push address of the first ColorSpec			_SetEntries						; do it			Move.L	theGDevice,A0			; get the device again			Move.L	(A0),A0					; dereference it			Move.L	gdPMap(A0),A0			; get handle to pixmap			Move.L	(A0),A0					; dereference pixmap			Move.L	pmTable(A0),A0			; get handle to CTab			Move.L	(A0),A0					; dereference CTab			Move.L	OldSeed(A6),ctSeed(A0)	; we didn't really want it to changeNextDevice	Lsl		#8,D3					; calculate offset to link table/4			Add		D4,D3					; offset to entry/4			Move	ForeLink(A2,D3.L*4),D0	; get next link; is the top bit set?		AWC.PB500DevEnd		DBpl	D5,DevLoop				; keep going until D0 is positive or D5 runs out			Move.L	SaveGDev(A6),theGDevice	; restore theGDevice			Move.L	A3,A0					; copy PMgrHandle			_HUnlock						; unlock itGoHome		MoveQ	#0,D0					; no error							AWC.PB377			MoveM.L (SP)+,D3-D5/A2-A4		; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE AnimatePalette(dstWindow:WindowPtr; srcCTab: CTabHandle; srcIndex,;	dstEntry,dstLength: INTEGER; INLINE $AA9A;;AnimatePalette	PROC	EXPORTParamSize	equ		14						; total bytes of params					<AWC>dstWindow	equ		ParamSize+8-4			; window to animate						<AWC>srcCTab		equ		dstWindow-4				; new source colorssrcIndex	equ		srcCTab-2				; first source entry to usedstEntry	equ		srcIndex-2				; first destination entry to setdstLength	equ		dstEntry-2				; how many to setSaveGDev	equ		-4						; room for saving theGDeviceSaveSeed	equ		SaveGDev-4				; old color table seedNumDev		equ		SaveSeed-2				; copy of nDevsDevCTabH	equ		NumDev-DevLimit*4		; enough room for a CTabHandle per deviceVarSize		equ		DevCTabH				; size of the variables			Link	A6,#VarSize				; build stack frame			MoveM.L D3-D6/A2-A4,-(SP) 		; save registers			Move.L	PMgrHandle,A4			; get the main handle			CmpA.L	#PMgrNil,A4				; are we initialized?			Beq		GoHome					; no => punt							AWC.PB377			Move.L	dstWindow(A6),A0		; get the target window					<AWC>			CmpA.L	#Nil,A0					; is it nil?							<AWC>			Beq		GoHome					; yes => we're done						AWC.PB377			Tst		PortBits+Rowbytes(A0)	; is it a new port?			Bpl		GoHome					; no => punt							AWC.PB377			Move.L	GrafVars(A0),A0			; get the data handle			Move.L	(A0),A0					; dereference it			Move.L	PmFgColor(A0),A2		; get the palette handle (finally)			Move.L	A2,D0					; CmpA.L #Nil,A2; is there a palette?		AWC.PB508			Bne.S	FoundAPltt				; yes => use it								AWC.PB508			Move.L	AppPalette,A2			; look for an AppPalette					AWC.PB508			Move.L	A2,D0					; CmpA.L #Nil,A2; is there an AppPalette?	AWC.PB508			Beq		GoHome					; no => punt								AWC.PB508FoundAPltt	Move.L	srcCTab(A6),A3			; get source color table					AWC.PB508			Move.L	A3,D0					; CmpA.L #Nil,A3; is it nil?				AWC.PB508			Beq		GoHome					; yes => again punt							AWC.PB377			Move.L	(A2),A2					; dereference the palette			Move	pmEntries(A2),D0		; get the number of entries; are there any?			Beq		GoHome					; no => still punt							AWC.PB377			MoveQ	#0,D3					; clear high word (so we can Lsl.L later)			Move	dstEntry(A6),D3			; get the starting index			Cmp		D0,D3					; is the start after the end?			Bhs		GoHome					; yes => keep punting						Move.L	(A3),A3					; dereference the color table			Move	srcIndex(A6),D4			; get the starting index			Cmp		ctSize(A3),D4			; is the starting index within range?			Bhi		GoHome					; no => once more, punt; We have something worth copying!  Now we can determine the length of the copy and; place it in D5.			Sub		D3,D0					; calculate maximum length of a palette copy			Move	D0,D5					; save it in D5			Move	ctSize(A3),D0			; fetch the length of the color table			AddQ	#1,D0					; add 1 to make it 1-based			Sub		D4,D0					; calculate maximum length of a CTab copy			Cmp		D0,D5					; is D5 too big?			Bls.S	NotTooBig				; no => don't replace it			Move	D0,D5					; copy smaller value to D5NotTooBig	Cmp		dstLength(A6),D5		; is D5 bigger than the request?			Bls.S	StillOkay				; no => leave it alone			Move	dstLength(A6),D5		; copy smaller value to D5StillOkay	Move.L	(A4),A1					; dereference the palette manager handle			Move	nDevs(A1),D0			; put number of devices into D0			Move	D0,NumDev(A6)			; remember number of devices			Lea		DevHandles(A1),A4		; point A4 at the clut device list			AWC			Lea		DevCTabH(A6),A0			; point A0 at our temporary table			AWC			Bra.S	ClearEnd				; jump into loopClearLoop	Clr.L	(A0)+					; clear room for a handle					AWCClearEnd	DBra	D0,ClearLoop			; continue for nDevs devices				AWC			AddA.L	#LinkTabs,A1			; bump A1 to the link tables			Lsl.L	#4,D3					; multiply D3 by ciSize			Lea		pmInfo(A2,D3.L),A2		; bump A2 to first ColorInfo			Lea		ctTable(A3,D4.W*8),A3	; bump A3 to first ColorSpec			Bra		EntryEnd				; jump into loopEntryLoop	BTst	#ExplicitBit,ciUsage+1(A2)	; is it explicit?			Bne.S	NextEntry					; yes => by definition not animating	AWC.PB500			BTst	#AnimatedBit,ciUsage+1(A2)	; is it animating?			Beq.S	NextEntry					; no => continue			Move.L	RGB+red(A3),ciRGB+red(A2)	; copy red and green into palette			Move	RGB+blue(A3),ciRGB+blue(A2)	; copy blue into palette			Move	ciPrivate(A2),D0			; get the ForeLink field			BfExtu	D0{16:3},D1					; get the key bits			Cmp		#4,D1						; were they 100?			Bne.S	NextEntry					; no => not a valid ForeLink; go home			Move	NumDev(A6),D6				; get maximum number of devices to examine			SubQ	#1,D6						; decrement by 1 so we may fall through; We fall through because the usual trick of branching to the end won't work when the; end is a DBpl, not a DBf (DBra).DevLoop		BfExtU	D0{19:5},D3				; grab device number (0..31)			BfExtU	D0{24:8},D4				; grab index number (0..255)			Lea		DevCTabH(A6),A0			; point A0 at temporary table			Move.L	(A0,D3.W*4),A0			; get CTabHandle			CmpA.L	#Nil,A0					; have we seen this device yet?			Bne.S	SeenDevice				; yes => skip setup			Move.L	DevHandle(A4,D3.W*8),A0	; get the device handle			Move.L	(A0),A0					; dereference it			Clr		gdId(A0)				; no client id's, please			Move.L	gdPMap(A0),A0			; get handle to pixmap			Move.L	(A0),A0					; dereference pixmap			Move.L	pmTable(A0),D0			; get handle to CTab			Lea		DevCTabH(A6),A0			; point A0 at temporary table						Move.L	D0,(A0,D3.W*4)			; save it for later			Move.L	D0,A0					; copy CTabHandle back into A0		AWC PB223SeenDevice	Move.L	(A0),A0					; dereference CTab			Move	ctSize(A0),D0			; grab number of entries - 1			Cmp		D4,D0					; compare our index to the max index			Ble.S	NextDevice				; out of range => look at next device			AWC.PB480			Move.L	ciRGB+red(A2),ctTable+RGB+red(A0,D4.W*8)			Move	ciRGB+blue(A2),ctTable+RGB+blue(A0,D4.W*8)NextDevice	Lsl		#8,D3					; calculate offset to link table/4			Add		D4,D3					; offset to entry/4			Move	ForeLink(A1,D3.L*4),D0	; get next link; is the top bit set?DevEnd		DBpl	D6,DevLoop				; keep going until D0 is positive or D5 runs outNextEntry	AddA.L	#ciSize,A2				; bump A2 to next ColorInfo			AddA.L	#ColorSpecSize,A3		; bump A3 to next ColorSpecEntryEnd	DBra	D5,EntryLoop			; continue for all animating entries			Move.L	theGDevice,SaveGDev(A6)	; save the old GDevice			Move	NumDev(A6),D6			; get number of devices to examine			Lea		DevCTabH(A6),A2			; point A2 at our temporary table			Bra.S	SetEnd					; jump into loopSetLoop		Move.L	(A2)+,A3					; get next CTabHandle			CmpA.L	#Nil,A3						; did we initialize it?			Beq.S	NextSet						; no => continue			Move.L	DevHandle(A4),theGDevice	; put us on that device			Move.L	(A3),A0						; dereference it			Move.L	ctSeed(A0),SaveSeed(A6)		; save the current seed			Clr		-(SP)						; push starting count of 0 for SetEntries			Move	ctSize(A0),-(SP)			; push number of entries-1			Pea		ctTable(A0)					; push address of the first ColorSpec			_SetEntries							; do it			Move.L	(A3),A0						; dereference CTab again			Move.L	SaveSeed(A6),ctSeed(A0)		; put the old seed back into placeNextSet		AddQ.L	#DevInfoSz,A4				; bump A4 to the next deviceSetEnd		DBra	D6,SetLoop					; loop for all devices			Move.L	SaveGDev(A6),theGDevice	; restore the old GDeviceGoHome		MoveQ	#0,D0					; clear error condition				AWC.PB377			MoveM.L (SP)+,D3-D6/A2-A4		; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE GetEntryColor(srcPalette: PaletteHandle; srcEntry: INTEGER; VAR dstRGB: RGBColor);;	INLINE $AA9B;;GetEntryColor	PROC	EXPORTParamSize	equ		10						; total bytes of paramssrcPalette	equ		ParamSize+8-4			; source Palette handlesrcEntry	equ		srcPalette-2			; entry to getdstRGB		equ		srcEntry-4				; where to put colorVarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	srcPalette(A6),A0		; get palette			CmpA.L	#Nil,A0					; is it nil?			Beq.S	GoHome					; yes => punt						AWC.PB377			Move.L	(A0),A0					; dereference it			Move	pmEntries(A0),D0		; get the number of entries			MoveQ	#0,D1					; clear high word			Move	srcEntry(A6),D1			; get the index			Cmp		D0,D1					; is the index in range?			Bhs.S	GoHome					; no => we're done					AWC.PB377			Lsl.L	#4,D1					; multiply by number of records			Lea		pmInfo(A0,D1.L),A0		; point A0 at the correct ColorInfo			Move.L	dstRGB(A6),A1			; get the destination			Move.L	ciRGB+red(A0),red(A1)	; copy red and green			Move	ciRGB+blue(A0),blue(A1)	; copy blueGoHome		MoveQ	#0,D0					; clear error condition			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE SetEntryColor(dstPalette: PaletteHandle; dstEntry: INTEGER; srcRGB: RGBColor);;	INLINE $AA9C;;SetEntryColor	PROC	EXPORTParamSize	equ		10						; total bytes of paramsdstPalette	equ		ParamSize+8-4			; source Palette handledstEntry	equ		dstPalette-2			; entry to setsrcRGB		equ		dstEntry-4				; new colorVarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	dstPalette(A6),A0		; get palette			CmpA.L	#Nil,A0					; is it nil?			Beq.S	GoHome					; yes => punt						AWC.PB377			Move.L	(A0),A0					; dereference it			Move	pmEntries(A0),D0		; get the number of entries			MoveQ	#0,D1					; clear high word			Move	dstEntry(A6),D1			; get the index			Cmp		D0,D1					; is the index in range?			Bhs.S	GoHome					; no => we're done					AWC.PB377			Lsl.L	#4,D1					; multiply by number of records			Lea		pmInfo(A0,D1.L),A0		; point A0 at the correct ColorInfo			Move.L	srcRGB(A6),A1			; get the source			Move.L	red(A1),ciRGB+red(A0)	; copy red and green			Move	blue(A1),ciRGB+blue(A0)	; copy blue			Move.L	dstPalette(A6),-(SP)	; push the palette handle					AWC.PB508			Bsr		DirtySeeds				; clear the device seeds					AWC.PB508GoHome		MoveQ	#0,D0					; clear error condition				AWC.PB377			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE GetEntryUsage(srcPalette: PaletteHandle; srcEntry: INTEGER; VAR dstUsage,;	dstTolerance: INTEGER); INLINE $AA9D;;GetEntryUsage	PROC	EXPORTParamSize		equ		14					; total bytes of paramssrcPalette		equ		ParamSize+8-4		; source Palette handlesrcEntry		equ		srcPalette-2			; entry numberdstUsage		equ		srcEntry-4			; where to put usagedstTolerance	equ		dstUsage-4			; where to put toleranceVarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	srcPalette(A6),A0		; get palette			CmpA.L	#Nil,A0					; is it nil?			Beq.S	GoHome					; yes => punt						AWC.PB377			Move.L	(A0),A0					; dereference it			Move	pmEntries(A0),D0		; get the number of entries			MoveQ	#0,D1					; clear high word			Move	srcEntry(A6),D1			; get the index			Cmp		D0,D1					; is the index in range?			Bhs.S	GoHome					; no => we're done					AWC.PB377			Lsl.L	#4,D1					; multiply by number of records			Lea		pmInfo(A0,D1.L),A0		; point A0 at the correct ColorInfo			Move.L	dstUsage(A6),A1			; get the destination			Move	ciUsage(A0),(A1)		; copy usage			Move.L	dstTolerance(A6),A1		; get the second destination			Move	ciTolerance(A0),(A1)	; copy toleranceGoHome		MoveQ	#0,D0					; clear error condition				AWC.PB377			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE SetEntryUsage(dstPalette: PaletteHandle; dstEntry,srcUsage,srcTolerance: INTEGER);;	INLINE $AA9E;;SetEntryUsage	PROC	EXPORTParamSize		equ		10					; total bytes of paramsdstPalette		equ		ParamSize+8-4		; source Palette handledstEntry		equ		dstPalette-2		; entry numbersrcUsage		equ		dstEntry-2			; new usagesrcTolerance	equ		srcUsage-2			; new toleranceVarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	dstPalette(A6),A0		; get palette			CmpA.L	#Nil,A0					; is it nil?			Beq.S	GoHome					; yes => punt						AWC.PB377			Move.L	(A0),A0					; dereference it			Move	pmEntries(A0),D0		; get the number of entries			MoveQ	#0,D1					; clear high word			Move	dstEntry(A6),D1			; get the index			Cmp		D0,D1					; is the index in range?			Bhs.S	GoHome					; no => we're done					AWC.PB377			Lsl.L	#4,D1					; multiply by number of records			Lea		pmInfo(A0,D1.L),A0		; point A0 at the correct ColorInfo			Move	srcUsage(A6),ciUsage(A0)			; copy usage			Move	srcTolerance(A6),ciTolerance(A0)	; copy tolerance			Move.L	dstPalette(A6),-(SP)	; push the palette handle					AWC.PB508			Bsr		DirtySeeds				; clear the device seeds					AWC.PB508GoHome		MoveQ	#0,D0					; clear error condition				AWC.PB377			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE	CTab2Palette(srcCTab: CTabHandle; dstPalette: PaletteHandle; myUsage,;	myTolerance: INTEGER); INLINE $AA9F;;CTab2Palette	PROC	EXPORTParamSize		equ		12						; total bytes of paramssrcCTab			equ		ParamSize+8-4			; source ColorTable handledstPalette		equ		srcCTab-4				; destination Palette handlesrcUsage		equ		dstPalette-2			; default usage valuesrcTolerance	equ		srcUsage-2				; default usage toleranceVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L D3/A2-A3,-(SP) 			; save registers			Move.L	dstPalette(A6),A2		; get palette			CmpA.L	#Nil,A2					; is it nil?			Beq.S	GoHome					; can't deal with nil here either		AWC.PB377						Move.L	dstPalette(A6),-(SP)	; push Palette			Jsr		ClearPalette			; clear animating entries and seed handle			Bne.S	GoHome					; if not zero it was a bad palette		AWC.PB457			Move.L	srcCTab(A6),A3			; get color table			CmpA	#Nil,A3					; is it nil?			Beq.S	GoHome					; can't deal with a nil handle			AWC.PB377			Move.L	(A3),A1					; dereference it			MoveQ	#0,D3					; clear high word of D3			Move	ctSize(A1),D3			; get size-1 of CTab			AddQ	#1,D3					; D3 is number of entries in palette			Move.L	A2,A0					; copy myPalette handle						Move.L	D3,D0					; copy size			AddQ	#1,D0					; include palette header			Asl		#4,D0					; multiply by 16 bytes per entry | header			_SetHandleSize					; do it			Bne.S	GoHome					; and quit if we couldn't do it			AWC.PB377			Move.L	A2,-(SP)				; push the palette handle					AWC.PB508			Bsr		DirtySeeds				; clear the device seeds					AWC.PB508			Move.L	(A2),A0					; dereference our handle			Move	D3,pmEntries(A0)		; copy size			AddA.L	#pmInfo,A0				; bump us to the first ColorInfo			Move.L	(A3),A1					; dereference source handle again			AddQ.L	#ctTable,A1				; bump A1 to the first ColorSpec			Move	srcUsage(A6),D1			; grab myUsage from parameters			Swap	D1						; put it in high word			Move	srcTolerance(A6),D1		; grab myTolerance into low word			Bra.S	CopyEnd					; jump into DBra loop			CopyLoop	Move.L	RGB+red(A1),ciRGB+red(A0)	; copy red and green			Move	RGB+blue(A1),ciRGB+blue(A0)	; copy blue			Move.L	D1,ciUsage(A0)				; copy myUsage and myTolerance			Clr		ciFlags(A0)					; clear private flags			Clr.L	ciPrivate(A0)				; clear private links			AddA.L	#ciSize,A0					; bump A0 to next ColorInfo			AddQ.L	#ColorSpecSize,A1			; bump A1 to next ColorSpecCopyEnd		DBra	D3,CopyLoop					; decrement and branch until copy is doneGoHome		MoveQ	#0,D0					; clear error							AWC.PB377			MoveM.L (SP)+,D3/A2-A3			; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE Palette2CTab(srcPalette: PaletteHandle; dstCTab: CTabHandle); INLINE $AAA0;;Palette2CTab	PROC	EXPORTParamSize	equ		8						; total bytes of paramssrcPalette	equ		ParamSize+8-4			; source Palette handledstCTab		equ		srcPalette-4				; destination CTabHandleVarSize		equ		0			Link	A6,#VarSize				; build stack frame			MoveM.L D3/A2-A3,-(SP) 			; save registers; first grab MyPalette and myCTab and compare them to nil			Move.L	srcPalette(A6),A2		; get source into A2			CmpA	#Nil,A2					; is it nil?			Beq.S	GoHome					; punt if no palette					AWC.PB377			Move.L	dstCTab(A6),A3			; get destination into A3			CmpA	#Nil,A3					; is it nil?			Beq.S	GoHome					; punt if no ctab						AWC.PB377			; leave size in D0; dereference both handles and capture pmEntries			Move.L	(A2),A0					; dereference myPalette			MoveQ	#0,D3					; clear high word			Move	pmEntries(A0),D3		; get number of palette entries			Move.L	D3,D0					; copy length			AddQ.L	#1,D0					; add 1 for the header			Lsl.L	#3,D0					; multiply by size of ColorSpec			Move.L	A3,A0					; put handle in A0			_SetHandleSize					; resize it			Bne.S	GoHome					; <> 0 => couldn't handle it			AWC.PB377						Move.L	(A2),A0					; redereference myPalette			Move.L	(A3),A1					; dereference CTab			Move	D3,D0					; copy size to a temp			SubQ	#1,D0					; ctSize is really last entry; CHECK - what should we do with the seed?  Get name of call from Ernie, again.			Clr.L	ctSeed(A1)				; clear seed			Move	D0,ctSize(A1)			; set size			Clr		transIndex(A1)			; this is not a device ColorTable (clear hi bit)			AddQ	#ctTable,A1				; bump color table to start			AddA	#pmInfo,A0				; bump palette to start			MoveQ	#0,D1					; clear index for pixel value			Bra.S	CopyEnd					; jump to start of copyCopyLoop	Move	D1,value(A1)				; set pixel value			Move.L	ciRGB(A0),RGB(A1)			; copy red and green			Move	ciRGB+blue(A0),RGB+blue(A1)	; copy blue			AddA.L	#ciSize,A0					; bump A0 to next ColorInfo			AddQ.L	#ColorSpecSize,A1			; bump A1 to next ColorSpec			AddQ	#1,D1						; bump pixel valueCopyEnd		DBra	D3,CopyLoop					; loop for all entriesGoHome		MoveQ	#0,D0					; clear error condition			MoveM.L (SP)+,D3/A2-A3 			; restore registers						<AWC>			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home;---------------------------------------------------;; PROCEDURE	ClearOne(eInfo:CiInfo; BasePtr:Ptr); LOCAL;;ClearOne	PROC	EXPORTParamSize	equ		4						; total bytes of paramseInfo		equ		ParamSize+8-4			; entry to clearBasePtr		equ		eInfo-4					; pointer to PMgrHandle^^VarSize		equ		0			Link	A6,#VarSize				; build stack frame			Move.L	A2,-(SP)				; save a register			Move.L	eInfo(A6),A0			; get the ColorInfo address			Move.L	CiPrivate(A0),D0		; get the current link information			Clr		ciFlags(A0)				; shut down any crap			Clr.L	ciPrivate(A0)			; clear it			Move.L	BasePtr(A6),A1			; set up DevListPtr			Lea		DevHandles(A1),A2		; A2 points at DevHandles			AddA.L	#LinkTabs,A1			; A1 points at LinkTabsNextLink	BfExtU	D0{19:5},D1				; grab device number (0..31)			BfExtU	D0{24:8},D2				; grab index number (0..255)			Move.L	(A2,D1.W*8),A0			; get the device handle			Move.L	(A0),A0					; dereference it			Move.L	gdPMap(A0),A0			; get handle to pixmap			Move.L	(A0),A0					; dereference pixmap			Move.L	pmTable(A0),A0			; get handle to CTab			Move.L	(A0),A0					; dereference CTab			Cmp		ctSize(A0),D2			; is index number <= entries - 1?			Bhi.S	IgnoreIt					; no => don't unreserve it			Clr		ctTable+value(A0,D2.W*8)	; unreserve itIgnoreIt	Lsl		#8,D1						; calculate offset to link table/4			Add		D2,D1					; offset to entry/4			Lea		(A1,D1.L*4),A0			; point A0 at next forward link			Move	ForeLink(A0),D0			; get next link			Clr.L	ForeLink(A0)			; clear it for the next guy			Tst		D0						; is there another link to examine?			Bmi.S	NextLink				; yes => go unlink it			Move.L	(SP)+,A2				; restore A2			Unlk	A6						; clean up our mess			Rtd		#ParamSize				; go home;---------------------------------------------------;; PROCEDURE CopyPalette(srcPalette,dstPalette: PaletteHandle; srcEntry,dstEntry,dstLength:;	INTEGER); INLINE $AAA1;;CopyPalette	PROC	EXPORTParamSize	equ		14						; total bytes of paramssrcPalette	equ		ParamSize+8-4			; source Palette handledstPalette	equ		srcPalette-4			; destination palette handlesrcEntry	equ		dstPalette-2			; source starting entrydstEntry	equ		srcEntry-2				; destination starting entrydstLength	equ		dstEntry-2				; length of the copyTrimLen		equ 	-2VarSize		equ		TrimLen			Link	A6,#VarSize				; build stack frame			MoveM.L D3-D4/A2-A4,-(SP) 		; save registers			Move.L	PMgrHandle,A4			; get the main handle			CmpA.L	#PMgrNil,A4				; are we initialized?			Beq		GoHome					; no => punt						AWC.PB377			Move.L	dstPalette(A6),A2		; get destination palette			CmpA.L	#Nil,A2					; is it nil?			Beq		GoHome					; can't deal with nil here either	AWC.PB377						Move.L	srcPalette(A6),A3		; get source palette			CmpA.L	#Nil,A3					; is it nil?			Beq		GoHome					; can't deal with a nil handle		AWC.PB377			CmpA.L	A2,A3					; does source = destination?			Beq		GoHome					; we can't handle this yet			AWC.PB377			MoveQ	#0,D0					; clear D0			Move	dstLength(A6),D0		; get the length of the copy			Ble		GoHome					; we can quit if it's too small			Move.L	D0,D3					; copy the length			Add		SrcEntry(A6),D0			; D0 is the required length of the source			Move.L	(A3),A1					; dereference source palette			Move	pmEntries(A1),D1		; get size of source palette			Sub		D0,D1					; D1, if negative, is how much we must trim D3			Bpl.S	DontTrimSrc				; no => don't trim it			Add		D1,D3					; trim back the length of the copy			AWC.PB530DontTrimSrc	Move.L	(A2),A0					; dereference the destination			Move	pmEntries(A0),D4		; get the length			Move	DstEntry(A6),D0			; calculate the potential new pmEntries			Add		D3,D0					; by adding the trimmed length			Cmp		D4,D0					; need we add handle room?			Ble.S	BigEnough				; no => skip _SetHandleSize					AWC.PB530						Move	D0,D4					; save new length			Move.L	A2,A0					; copy DstPalette			AddQ	#1,D0					; include palette header			Asl		#4,D0					; multiply by 16 bytes per entry | header			_SetHandleSize					; do it			Bne		GoHome					; and quit if we couldn't do it			AWC.PB377			Move.L	(A2),A0					; dereference the destination handle			Move	D4,D2					; make a copy of the new length			MoveQ	#0,D1					; clear the high word			Move	PmEntries(A0),D1		; this is where to start clearing			Sub		D1,D2					; this is now many to clear			Move	D4,pmEntries(A0)		; save size			Lea		PmInfo(A0),A1			; point us at the start of the table			Asl		#4,D1					; this is the offset to the start of the clear			AddA.L	D1,A1					; bump A1 to the start of the clear			Bra.S	ClearEnd				; jump to the DBra			; The main reason for clearing is so we can correctly detect and clear entries that are; going to be clobbered.ClearLoop	Clr.L	(A1)+					; clear 16 bytes			Clr.L	(A1)+			Clr.L	(A1)+			Clr.L	(A1)+ClearEnd	DBra	D2,ClearLoop			BigEnough	CmpA.L	A2,A3					; does SrcPalette = DstPalette?			Beq.S	GoHome					; yes => can't handle this					AWC.PB377			Move.L	A3,-(SP)				; push the palette handle					AWC.PB508			Bsr		DirtySeeds				; clear the device seeds					AWC.PB508			Move.L	(A3),A1					; dereference source palette						MoveQ	#0,D0					; clear the high word			Move	DstEntry(A6),D0			; get the first destination			Asl.L	#4,D0					; multiply by 16			Move.L	(A2),A0					; dereference destination palette again		AWC.PB508			Lea		PmInfo(A0,D0),A0		; point A0 at the first destination			MoveQ	#0,D1					; clear the high word			Move	SrcEntry(A6),D0			; get the first source			Asl.L	#4,D0					; point A0 at the first destination			Lea		PmInfo(A1,D0),A1		; point A1 at the first source			Bra.S	CopyEnd					; jump into the loopCopyLoop	Move.L	ciPrivate(A0),D0		; get the link info			Beq.S	NoLinks					; no => it doesn't need clearing			MoveM.L	A0-A1,-(SP)				; save registers			Move.L	A0,-(SP)				; ciInfo to clear			Move.L	(A4),-(SP)				; dereference PMgrHandle and push it			Jsr		ClearOne				; clear the links			MoveM.L (SP)+,A0-A1				; restore interesting registersNoLinks		Move.L	ciRGB(A1),ciRGB(A0)				; copy first two words			Move.L	ciRGB+Blue(A1),ciRGB+blue(A0)	; copy blue and usage			Move	ciTolerance(A1),ciTolerance(A0)	; copy tolerance			Clr		ciFlags(A0)						; clear the flags field			Clr.L	ciPrivate(A0)					; clear the links field			AddA.L	#CiSize,A0				; bump both pointers			AddA.L	#CiSize,A1CopyEnd		DBra	D3,CopyLoop				; loop for (trimmed) length entriesGoHome		MoveQ	#0,D0					; clear error code					AWC.PB377			MoveM.L (SP)+,D3-D4/A2-A4		; restore registers			Unlk	A6						; clear stack frame			Rtd		#ParamSize				; strip parameters and go home; Thus ends the PaletteManager - ah, a sad thing it is, to be done.  But WAIT!  There's; MORE!  Let's patch RGBFORECOLOR and RGBBACKCOLOR just for grins!  Yeah!			IF not ROMPaletteMgr THEN		; no patches for the ROM version			RWH.C864;---------------------------------------------------;; procedure RGBForeColor (Color : RGBColor);;;	This routine takes an RGB triple and sets the current Graf- or CGrafPort;	fields so that drawing will take place with the best match of the;	requested color, using the current GDevice's color matching rules.  The;	appropriate fields are set depending on portType;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(RGBForeColor) 		(RGBForeColor)RGBForeColor	PROC	EXPORT				EXPORT	RGBBackColor,RGB2OLDStdDevCall		Equ		$1D2A0					; RGBForeColor; RGBBackColor is $4081D2B0 <PB302>StdDevMask		Equ		$FFFFFFEF				; the calls are different only at bit 4!			MOVEQ		#FGCOLOR,D0				; get offset to index field			MOVEQ		#RGBFgColor,D1			; get offset to RGB field		SHARE		MOVE.L		4(SP),A1				; point at the RGB color			MOVE.L		GRAFGLOBALS(A5),A0		; get the QuickDraw globals pointer			MOVE.L		THEPORT(A0),A0			; point at the port			PEA			0(A0,D0)				; save pointer to the index field						TST			PORTBITS+ROWBYTES(A0)	; is it a new port?			BMI.S		NEWPORT					; => yes, set RGB components			JSR			RGB2OLD					; else convert RGB to old color			BRA			DONE					; =>; To keep the stack correct we will momentarily preempt A1.  We can restore it in a bit.; Also, since we no longer need the offset to the index fieldNewPort		Move.L		GrafVars(A0),A1			; get the GrafVars handle			CmpA.L		#Nil,A1					; is it nil?			Beq.S		PuntPmCalls				; yes => punt and do the normal call			Move.L		(A1),A1					; dereference it into A1			Move.L		4(SP),D2				; get the return address			Sub.l		ROMBase, D2				;   Make it offset within ROM,			<PB302>			And.L		#StdDevMask,D2			; and it with the std mask			Cmp.L		#StdDevCall,D2			; is it from StdDevLoop?			Bne.S		NormalCall				; no => make the normal call			Tst.L		PmFgColor(A1)			; is there a palette?					EHB.PBnnn			Bne.S		FoundAPltt				; yes => we can do it					AWC.PB508			Tst.L		AppPalette				; is there an AppPalette?				AWC.PB508			Beq.S		NormalCall				; => no, do normal call					EHB.PBnnnFoundAPltt	Move		PmFlags(A1),D2			; get the Palette Manager flags			AWC.PB508			Cmp			#FgColor,D0				; was it forecolor?			Bne.S		GetBack					; no => get back color flag			BTst		#PmFgBit,D2				; did PmForeColor set up this port?			Beq.S		PuntPmCalls				; no => continue normally			AddQ		#4,SP					; we won't need the pointer to the index			Move		pmFgIndex(A1),-(SP)		; push the entry number			_PmForeColor						; set the port using PmForeColor			Bra.S		GoHome					; all finishedGetBack		BTst		#PmBkBit,D2				; did PmBackColor set up this port?			Beq.S		PuntPmCalls				; no => continue normally			AddQ		#4,SP					; we won't need the pointer to the index			Move		pmBkIndex(A1),-(SP)		; push the entry number			_PmBackColor						; set the port using PmBackColor			Bra.S		GoHome					; all through			NormalCall	Move		PmFlags(A1),D2			; get flags			Cmp			#FgColor,D0				; is this a foreground call?			Bne.S		NotFgCall				; no => clear PmBkBit			BClr		#PmFgBit,D2				; clear the foreground flag bit			Bra.S		CommonFlags				; reunite itNotFgCall	BClr		#PmBkBit,D2				; clear the background flag bitCommonFlags	Move		D2,PmFlags(A1)			; save the flags to GrafVarsPuntPmCalls	Move.L		8(SP),A1				; restore the pointer to the RGBColor; Here is the normal RGBForeColor code code			MOVE.L		red(A1),red(A0,D1)		; copy red and green components to the port			MOVE.W		blue(A1),blue(A0,D1)	; and blue too		; make an rgbColor on the stack								MOVE.L		green(A1),-(SP)			; copy green and blue			MOVE.W		red(A1),-(SP)			; copy red			SUBQ		#4,SP					; make room for function return			PEA			4(SP)					; push pointer to rgb			_Color2Index						; convert it to an index				MOVE.L		(SP)+,D0				; get the index result			ADDQ		#6,SP					; get rid of the rgbColorDone		MOVE.L		(SP)+,A0				; get pointer to index field			MOVE.L		D0,(A0)					; and set the index fieldGoHome		Rtd			#4						; all done		RGB2OLD	;-----------------------------------------------;; UTILITY TO CONVERT AN RGB (POINTED TO BY A1) VALUE; TO AN OLD STYLE COLOR VALUE.  RETURNS VALUE IN D0.  CLOBBERS A0,D1;; USES HIGH BIT OF EACH COMPONENT TO SELECT RGB OFF (0) OR ON (1)		MOVEQ		#0,D1						; clear out D1		MOVE		(A1)+,D1					; get red		LSL.L		#1,D1						; get high bit		MOVE		(A1)+,D1					; get green		LSL.L		#1,D1						; get high bit		MOVE		(A1)+,D1					; get blue		LSL.L		#1,D1						; get high bit		SWAP		D1							; get RGB index				noBlue	LEA			MapTbl,A0					; get translate table		MOVEQ		#0,D0						; clear out high word		MOVE		0(A0,D1*2),D0				; convert to planar value		RTS										; => all done		; TABLE TO MAP FROM 3 BIT RGB TO OLD-STYLE COLOR INDICESMapTBL	DC.W		blackColor					; RBG = 0,0,0 -> black		DC.W		blueColor					; RBG = 0,0,1 -> blue		DC.W		greenColor					; RBG = 0,1,0 -> green		DC.W		cyanColor					; RBG = 0,1,1 -> cyan		DC.W		redColor					; RBG = 1,0,0 -> red		DC.W		magentaColor				; RBG = 1,0,1 -> magenta		DC.W		yellowColor					; RBG = 1,1,0 -> yellow		DC.W		whiteColor					; RBG = 1,1,1 -> white				;---------------------------------------------------;; procedure RGBBackColor (Color : RGBColor);;;	This routine takes an RGB triple and sets the current Graf- or CGrafPort;	fields so that drawing will take place with the best match of the;	requested color, using the current GDevice's color matching rules.  The;	appropriate fields are set depending on portType.;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(RGBBackColor) 		(RGBBackColor)RGBBackColor		MOVEQ		#BKCOLOR,D0					; get offset to the index field		MOVEQ		#RGBBkColor,D1				; get offset to RGB field		BRA			SHARE						; => and use common code;---------------------------------------------------;; procedure myNewCWindow();;	Initialize the palette manager fields of the new window.;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(NewCWindow) 		(myNewCWindow)myNewCWindow	PROC	EXPORTROMNewCWindow EQU	$0F9F6						; normal NewCWindow routine				<PB302>; shuffle parameters so it will return to us			MOVE.L	SP,A0						; get src for params			MOVE.L	SP,A1						; get dst for params			MOVE.L	(A0)+,D1					; save RTS			MOVEQ	#7,D0						; move 8 longs@NxtLong	MOVE.L	(A0)+,(A1)+					; move a long			DBRA	D0,@NxtLong					; repeat for all longs			MOVE.L	D1,30(SP)					; stuff original RTS			JSRROM	ROMNewCWindow				; call NewCWindow						<PB302>			; always set the default palette to 0			MOVE.L	(SP),A1						; get the window			MOVE.L	GrafVars(A1),A0				; get handle to vars			MOVE.L	(A0),A0						; point to vars			CLR.L	PMFgColor(A0)				; and clear palette			MOVE.L	(SP)+,A1					; get window pointer			MOVE.L	(SP),A0						; get return address			MOVE.L	A1,(SP)						; stuff wPtr			JMP		(A0)						; and return			;---------------------------------------------------;; procedure myNewWindow();;;	When NewWindow is called, do an ActivatePalette in case there's a default palette.;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(NewWindow) 		(myNewWindow)myNewWindow	PROC	EXPORTROMNewWindow EQU	$0FA08						; normal NewWindow routine				<PB302>; shuffle parameters so it will return to us			MOVE.L	SP,A0						; get src for params			MOVE.L	SP,A1						; get dst for params			MOVE.L	(A0)+,D1					; save RTS			MOVEQ	#7,D0						; move 8 longs@NxtLong	MOVE.L	(A0)+,(A1)+					; move a long			DBRA	D0,@NxtLong					; repeat for all longs			MOVE.L	D1,30(SP)					; stuff original RTS			JSRROM	ROMNewWindow				; call NewWindow						<PB302>						MOVE.L	(SP),-(SP)					; push the window			_ActivatePalette					; and activate the system palette@DONE		MOVE.L	(SP)+,A1					; get window pointer			MOVE.L	(SP),A0						; get return address			MOVE.L	A1,(SP)						; stuff wPtr			JMP		(A0)						; and return			;---------------------------------------------------;; procedure HiliteWindow();;;	Patch HiliteWindow to call ActivatePalette if called from SelectWindow;	AND if it is not called from MoveWindow!;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(HiliteWindow) 		(myHiliteWindow)myHiliteWindow	PROC	EXPORTFromSelect	EQU		$1016A						; RTS if called from select				<PB302>FromMove	EQU		$10396						; RTS if selected from Move				<PB302>ROMHilite 	EQU		$0FFCE						; real HiliteWindow						<PB302>			CMPRA	FromSelect,(SP)				; from selectWindow?					<PB302>			BNE.S	@JustHilite					; => no, just hilite			CMPRA	FromMove,$38(SP)			; from Move?							<PB302>			BEQ.S	@JustHilite					; => yes, just hilite			TST.B	4(SP)						; hiliting?			BEQ.S	@JustHilite					; => no, just (un)hilite			LEA		6(SP),A0					; point to window			MOVE.L	(A0),-(SP)					; push window			MOVE	-(A0),-(SP)					; push boolean			JSRROM	ROMHilite					; call hilite in ROM 					<PB302>						MOVE.L	6(SP),-(SP)					; push window pointer			_ActivatePalette					; and activate its palette			RTD		#6							; strip 6 bytes params and return			@JustHilite	JMPROM	ROMHilite					; and complete the call					<PB302>;---------------------------------------------------;; procedure MyMoveWindow;;	Patch MoveWindow to call ActivatePalette;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(MoveWindow) 		(myMoveWindow)MyMoveWindow	PROC	EXPORTROMMove 	EQU		$0FD9C						; real MoveWindow						<PB302>			LEA		10(SP),A0					; point to window			MOVE.L	(A0),-(SP)					; push window			MOVE.L	-(A0),-(SP)					; push dst location			MOVE	-(A0),-(SP)					; push frontflag			JSRROM	ROMMove						; call movewindow						<PB302>			MOVE.L	10(SP),-(SP)				; push window			_ActivatePalette					; and activate its palette			RTD		#10							; strip 10 bytes and return			;---------------------------------------------------;; procedure MySizeWindow;;	Patch SizeWindow to call MySetPalette;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(SizeWindow) 		(mySizeWindow)MySizeWindow	PROC	EXPORTROMSize 	EQU		$1000E						; real SizeWindow						<PB302>			LEA		10(SP),A0					; point to window			MOVE.L	(A0),-(SP)					; push window			MOVE.L	-(A0),-(SP)					; push dst location			MOVE	-(A0),-(SP)					; push frontflag			JSRROM	ROMSize						; call SizeWindow						<PB302>			MOVE.L	10(SP),-(SP)				; push window			_ActivatePalette					; and activate its palette			RTD		#10							; strip 10 bytes and return			;---------------------------------------------------;; procedure MyClose;;	Patch CloseWindow to call DisposPalette.  In the initial system disk release, this;	patch mistakenly operated on DisposeWindow instead of CloseWindow.;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(CloseWindow) 		(myClose)MyClose	PROC	EXPORTROMClose 	EQU		$0FB6E						; real CloseWindow						<PB302>			MOVE.L	4(SP),A0					; get the window			TST		PORTBITS+ROWBYTES(A0)		; is it new?			BPL.S	@NotNew						; => no						MOVE.L	GrafVars(A0),A0				; get grafVar handle			MOVE.L	(A0),A0						; point at grafVars			MOVE.L	PmFgColor(A0),D0			; is there a palette			BEQ.S	@NotNew						; => no						Move.L	D0,A0						; let's use an address register			AWC.PB457			Move.L	(A0),A0						; dereference it						AWC.PB457			BTst	#DisposeBit,pmPrivate(A0)	; should we dispose of it?				AWC.PB457			Beq.S	@NotNew						; no => the user has to dispose of it	AWC.PB457						MOVE.L	D0,-(SP)					; else push palette			_DisposePalette						; and dump it@NotNew		JMPROM	ROMClose					; and dispose the window				<PB302>			;---------------------------------------------------;; procedure MyShowHide();;;	Patch MyShowHide to call ActivatePalette.  If it is being called to show a hidden window,;	then do the ActivatePalette.;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(ShowHide) 			(myShowHide)MyShowHide	PROC	EXPORTROMShow 	EQU		$0F742						; real MoveWindow						<PB302>			TST.B	4(SP)						; is it show?			BEQ.S	@NoShow						; =>no, no go show						MOVE.L	6(SP),A0					; get the window			TST.B	WVisible(A0)					; is it showtime			BNE.S	@NoShow						; =>no, not yet						LEA		6(SP),A0					; point to window			MOVE.L	(A0),-(SP)					; push window			MOVE	-(A0),-(SP)					; push marquis			JSRROM	ROMShow						; call showwindow						<PB302>			MOVE.L	A1,-(SP)					; save A1 for ShowHide!			MOVE.L	10(SP),-(SP)				; push window			_ActivatePalette					; and activate its palette			MOVE.L	(SP)+,A1					; restore A1 for ShawHide			RTD		#6							; strip 10 bytes and return			@NoShow		JMPROM	ROMShow						; the ROM must begin					<PB302>			;---------------------------------------------------;; procedure MyExit;;;	Patch MyExit to call DisposePalette for all palettes in the app heap.  In addition, jam;	theGDevice and srcDevice with MainDevice.  As if that weren't enough, make sure that;	cursor interrupts are enabled.;;	This patch is not installed by A/UX or under MultiFinder.;;	AppleSystemPatch 	PaletteMgr.a 	10Mar87		#PB103 	(MyExit) 			(myExit)MyExit		PROC	EXPORT			EXPORT	myExitExit				; address of JMP target to daisy chain	<PB158>			ROMIAZInit	EQU		$4080DEF8				; jump back into ROMROMAppZoneAddr	EQU $4080D434				; a useful routine			MOVEM.L	A0-A3/D0-D3,-(SP)		; save all registers			MOVE.L	PMgrHandle,A2			; get paletteMgr handle			CMP.L	MinusOne,A2				; is it there?			BEQ.S	GoHome					; => no, just return			MOVE.L	(A2),A1					; point to data structure			MOVE.L	PListHandle(A1),A0		; get handle to palette list			_HLock							; and lock it down			MOVE.L	(A0),A3					; point to palette list						Move	APalettes(A1),D3		; get number of active handles			Beq.s	NoPals					; no friends => go home			Add		FreeSpaces(A1),D3		; calculate total number of entries			Clr.L	WindowList				; clear the list of windows for FrontWindow		AWC.PB506			BRA.S	FindEnd					; => check for no entriesFindLoop	Move.L	PaletteRef(A3),D1		; get first entry			BEQ.S	FindNext				; => no palette in entry			MOVE.L	D1,D0					; and get for routine			JSR		ROMAppZoneAddr			; in application area (or zero)?				<C699>			BNE.S	FindNext				; => not in app heap			MOVE.L	D1,-(SP)				; push palette handle			_DisposePalette					; and dispose it in placeFindNext	AddQ	#PLstEntrySz,A3			; bump to the next entryFindEnd		DBra	D3,FindLoop				; repeat for all spaces			NoPals		MOVE.L	(A2),A1					; point to palette stuff			MOVE.L	PListHandle(A1),A0		; get handle to palette list			_HUnlock						; and unlock itGoHome		Clr.L	AppPalette				; set us up for the next guy				AWC.PB508			MOVE.L	MainDevice,A0			; get the main device			MOVE.L	A0,SrcDevice			; set the src device			MOVE.L	A0,theGDevice			; and the current device						MOVE	#$2000,SR				; make sure interrupts enabled			MOVEM.L	(SP)+,A0-A3/D0-D3		; restore all registers			JMP		$4080000A				; jump to next code in chain				<PB158>myExitExit	EQU		*-4						; address of JMP target						<PB158>			ENDIF							; end of patches commented out for ROM		RWH.C864; Okay, that's it.  We're out of here!