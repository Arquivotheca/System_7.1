;;	File:		Text.m.a;;	Contains:	Standard procs for text manipulation.;;	Copyright:	© 1988-1992 by Apple Computer, Inc., all rights reserved.;;	Change History (most recent first):;;		<35>	 4/24/92	DTY		Get rid of hasSplineFonts conditionals.  Also get rid of forROM;									conditionals, since this file is not used for ROM builds.;		<34>	10/23/91	ngk		Changed case of PUTPICWORD to PutPicWord so that ROMBinds are;									happy;		<33>	 9/25/91	jlf		Rolled in Pacific TrueType modifications (aka: doublebyte support).;									Removed DOUBLE_BYTE conditional code and inserted hasDoubleByte;									code. Removed enNumer/enDenom stuff to fix divide-by-zero bug in TrueType.;									Peter Edberg says that emNumer/emDenom is no longer supported.;		<32>	 8/30/91	DTY		Define onMac here now that it’s not an available feature in;									BBSStartup.  Defined to be 1 for the System build because onMac;									used to be a feature of the System build.;		<31>	 6/12/91	LN		added #include 'SysPrivateEqu.a';		<30>	 3/13/91	JT		Added the glyph state opcode support to text drawing under old;									QuickDraw. This opcode records the state of the Font Manager and;									TrueType so text will be drawn the same on picture playback as;									it was during picture recording. Also prevented font naming,;									line layout, and glyph state opcodes from being recorded in old;									pictures. Code checked by KON and BAL. BRC numbers 82651 and;									79185. Worksheet number KON-022.;		<29>	 2/21/91	KON		DFH: BRC #82863, GrayishTextOr mode should not be saved to;									pictures in System 7.;		<28>	 1/15/91	CL		(MR)Now safecount must be set to -2 if the pen loc needs to be;									added inside of stdtxmeas.;		<27>	 1/14/91	CL		(RB) Fixed more problems in long string phenomenom.  Style;									variations such as italic when measured did not add in slop when;									checking overflow calculation in stdtxmeas.;		<26>	 1/14/91	SMB		(jdt) Initializing overflow count to -1.;		<25>	 1/10/91	KON		If a font name does not exist for a given ID when doing font;									name/ID binding, don't write a $2C opcode to the picture. [SMC];		<24>	  1/9/91	RB		(CEL/PKE/GM/DA) Fixing long string overflow bug by truncating;									the count. Duplicated text.a changes.;		<23>	 8/24/90	PKE		(per JT) Use new Script Mgr line layout values in GrafGlobals;									instead of soon-to-be-obsolete values in Script Mgr globals. Use;									new names picQdChExtra and picQdRunSlop instead of picSMgrChar;									and picSMgrSlop. Fixed MeasureText for double-byte chars.;		<22>	 8/17/90	dvb		Add grayish mode slime.;		<21>	  8/1/90	MR		Fix some Case Sensitivity for the Gaudi INIT;		<20>	  8/1/90	KON		Add DoPict2 for rom build.;		<19>	 7/26/90	KON		Non-init (non-gaudi) versions of StdText should always call RAM;									version of         CheckPic so Pict2 creation with OpenCPicture;									works.;		<19>	 7/25/90	KON		Non-init (non-gaudi) versions of StdText should always call RAM;									versions of CheckPic and DoPict2 so PICT2 creation with;									OpenCPicture works.;		<18>	 7/20/90	DTY		Bass: The Linked Patch. Added conditional Black and White names;									for routines, since Bass is carrying around two versions of this;									file, and the names need to be unique. Conditionalised jumps;									into ROM (CheckPic, PutPicByte, etc.): ROM builds continue to;									use bsr.l, but Bass builds will use jsrROM macro.;		<17>	 6/22/90	CL		Using the shared GrafTypes.m.a and added new include file;									fontPrivate.a and other include files needed.;		<16>	 6/20/90	KON		OpenCPicture creates a PICT2, so we need to word align opcodes;									when we are creating PICT2's.;		<15>	  6/9/90	JT		Need to import the CalcCharExtra routine that we now share with;									Text.a (sorry about that).;		<14>	  6/9/90	JT		Now scale the character extra by the font size specified in the;									current GrafPort. This is the same treatment normally given to;									chExtra by ColorQuickDraw. Note that these two extra values are;									added together before they are scaled. Also, these routines now;									rely on the CalcCharExtra routine to perform the scaling.;		<13>	  6/7/90	PKE		Add scaling parameters to MeasureText stack frame, set them from;									new ExpandMem globals, use them to scale results.;		<12>	 5/29/90	CL		Placed vertical metrics into cache instead of the widthtable.;		<11>	 4/24/90	JT		Save the Script Manager line-layout information when spooling a;									picture in StdText. Changed some short branches to long branches;									since the destinations are farther away when all of the;									conditional code is included.;		<10>	 4/23/90	JT		Save the Script Manager line-layout information when spooling a;									picture in StdText.;		 <9>	 4/17/90	HJR		Fix Case OBJ problem.;		 <8>	 4/16/90	HJR		Change SPLINE_FONTS to hasSplineFonts.;		 <7>	 4/10/90	CL		Added support for double byte codes;		 <6>	 3/26/90	CL		Adding measuretext for system build for script manager addition;									of character extra.;		 <5>	 3/21/90	CL		Fixing conditionals for rom build. Script Manager char extra;									addition.;		 <4>	 3/20/90	CL		nothing change;		 <3>	 3/20/90	CL		Adding in Script Managers special charextra for 68000 class;									machines;		 <2>	 2/27/90	CL		The Bass init code working on 6.0.4 systems do not use the pict;									font name matching.  ifdefed them out.;	   <1.9>	 11/7/89	KON		Added support for font name/ID binding;	   <1.8>	 8/28/89	CEL		Only need to use word part of ascent, descent, widmax & leading;	   <1.7>	  7/6/89	GGD		Un-Func'd TextWidth so that alignment wouldn't screw up;									StringWidth falling into it.;	   <1.6>	 6/10/89	CEL		Moved Private.a QuickDraw Equates into proper QuickDraw private;									file (colorequ.a), got rid of QuickDraw nFiles dependencies and;									fixed up necessary files…;	  <•1.5>	  5/4/89	CEL		Cleaned up conditionals for ROM, HcMac works now! Blasting in;									fix…;	  <•1.4>	  5/3/89	CEL		Bass rolled into ROM. NOTE:Spline Fonts are conditionalized out.;									Blasting in correct file;	  <•1.2>	  5/1/89	cel		Rolled in Bass…;	   <1.1>	11/11/88	CCH		Fixed Header.;	   <1.0>	 11/9/88	CCH		Adding to EASE.;	   <1.2>	10/12/88	CCH		Changed “m.GrafType.a” to “GrafType.m.a”.;	   <1.1>	 5/18/88	MSH		Changed inclides to use m.GRAPHTYPES to work under EASE.;	   <1.0>	 2/11/88	BBM		Adding file for the first time into EASE…;;	To Do:;	BLANKS	ON	STRING	ASIS	if (&type('onMac') = 'UNDEFINED') then		onMac:		equ		1					; Define as true because this is the way it used to be in for System builds before Dean and Darin messed with BBSStartup	endif		IF (&TYPE('INITVERSION') = 'UNDEFINED') THENGaudi		EQU		0				; No init if not defined.	ELSEGaudi		EQU		1	ENDIF	IF (&TYPE('hasDoubleByte') = 'UNDEFINED') THENhasDoubleByte		EQU		1	ENDIF	IF (&TYPE('SCRIPT_CHAR_EXTRA') = 'UNDEFINED') THEN		; <5> CELSCRIPT_CHAR_EXTRA		EQU		1	ENDIF	IF (&TYPE('hasGlyphState') = 'UNDEFINED') THENhasGlyphState			EQU		1	ENDIF		CASE	OBJ			INCLUDE 	'Traps.a'		INCLUDE		'sysequ.a'		INCLUDE  	'GRAFTYPES.m.a'		INCLUDE 	'fontPrivate.a'		INCLUDE		'LinkedPatchMacros.a'		INCLUDE		'ToolEqu.a'		INCLUDE 	'SysPrivateEqu.a'		INCLUDE 	'SplineDefines.a';---------------------------------------------------------;;;	  *****  *****	*	*  *****;		*	 *		*	*	 *;		*	 *		 * *	 *;		*	 ***	  * 	 *;		*	 *		 * *	 *;		*	 *		*	*	 *;		*	 *****	*	*	 *;;;  Routines for measuring and drawing Text.;;-------------------------------------------;;  KERNED STRIKE FONT FORMAT OFFSETS:;FORMAT			EQU 	0			;WORDMINCHAR 		EQU 	2			;WORDMAXCHAR 		EQU 	4			;WORDMAXWD			EQU 	6			;WORDFBBOX			EQU 	8			;WORDFBBOY			EQU 	10			;WORDFBBDX			EQU 	12			;WORDFBBDY			EQU 	14			;WORDLENGTH			EQU 	16			;WORDASCENT			EQU 	18			;WORDDESCENT 		EQU 	20			;WORDXOFFSET 		EQU 	22			;WORDRASTER			EQU 	24			;WORDBWStdText	PROC	EXPORT		IMPORT	BWDrText		if not( Gaudi) then		IMPORT CHECKPIC,DPUTPICBYTE,PUTPICDATA,PUTPICWORD,PUTPICLONG,DOPICT2	endif	;----------------------------------------------------------;;  PROCEDURE StdText();;; This is a check at the head of StdText to support grayish text mode.; if txMode is 49, then call the old stdtext with text ormode, and; then stamp bic'ed gray patter over its bounds.; else, just go on to the real stdTextDGVars		RECORD		{A6Link},DECREMENTresult		DS.B		0					; nonecount		DS.B		2					; input: number of charactersstring		DS.B		4					; input: pointer to stringxNumer		DS.B		4					; input: numer scalerxDenom		DS.B		4					; input: denom scalerreturn		DS.B		4					; return address on stackA6Link		DS.B		4					; linkoldPen		DS.B		18					; PenState recordoldPicSave	DS.B		4					; We turn off picture recording			<KON 20FEB91>finfo		DS.B		8					; font info recordmyr			DS.B		8					; rectangle of text to stampnumerCopy	DS.B		4					; copies for stdTxMeas calldenomCopy	DS.B		4linkSize	DS.B		0					; size of record			ENDRgrayishTextOr	EQU			49				; this is in QuickEqu.a, its not icl'd			WITH		DGVars			MOVE.L		(A5),A0			MOVE.L		(A0),A0						; A0->the port			CMPI		#grayishTextOr,txMode(A0)	; is it the secret mode?			BEQ.S		@itsus			jmp			reglarStdText		; join the original ROM code.		@itsus										; do text and bic-stamp			LINK		A6,#linkSize			MOVE.L		picSave(A0),oldPicSave(A6)	; disable picture saving (a0 still valid)	<KON 20FEB91>			CLR.L		picSave(A0)			PEA			oldPen(A6)			; Save Penstate			_GetPenState			_PenNormal			SUBQ		#2,SP				; figure out the width of the text			MOVE		count(A6),-(SP)			MOVE.L		string(A6),-(SP)			MOVE.L		xNumer(A6),numerCopy(A6)			PEA			numerCopy(A6)			MOVE.L		xDenom(A6),denomCopy(A6)			PEA			denomCopy(A6)			PEA			finfo(A6)			_StdTxMeas								; leave pen advance on stack			PEA			finfo(A6)					; did stdTxMeas do that?			_GetFontInfo			MOVE.L		oldPen(A6),D1				; D1 = previous pen position			MOVE		D1,myr+left(A6)				; save pen.h			ADD			(SP)+,D1					; D1 = pen.h + pen advance			MOVE		D1,myr+right(A6)			; to get right			SWAP		D1							; D1 = pen.v			MOVE		D1,D2			SUB			finfo+0(A6),D2				; (0=ascent)figger highest point			ADD			finfo+2(A6),D1				; (2=descent)and lowest point			MOVE		D2,myr+top(A6)			MOVE		D1,myr+bottom(A6)			; myr is now the string's bounds			MOVE		#srcOr,-(SP)				; draw text in srcOr			_TextMode			MOVE		count(A6),-(SP)			MOVE.L		string(A6),-(SP)			MOVE.L		xNumer(A6),-(SP)			MOVE.L		xDenom(A6),-(SP)			JSR			ReglarStdText			MOVE		#grayishTextOr,-(SP)		; restore textmode			_TextMode			MOVE.L		(A5),A0				; get QuickDraw globals			PEA			Gray(A0)			; push gray			_PenPat							; set pen to it			MOVE		#PatBIC,-(SP)		; push patBIC penMode			_PenMode						; set penMode			PEA			myr(A6)			_PaintRect			PEA			oldPen(A6)			; Restore Penstate			_SetPenState			MOVE.L		(A5),A0				; restore picture saving	<KON 20FEB91>			MOVE.L		(A0),A0							;				<KON 20FEB91>			MOVE.L		oldPicSave(A6),picSave(A0)		;				<KON 20FEB91>			UNLK		A6			MOVE.L		(SP)+,A0			ADD			#result-return-4,SP			JMP			(A0)reglarstdtext;--------------------------------------------------------------------------;;  PROCEDURE StdText(count: INTEGER; textAddr: Ptr; numer,denom: Point);;;  A6 OFFSETS OF PARAMS AND LOCALS AFTER LINK:;PARAMSIZE		EQU 	14COUNT			EQU 	PARAMSIZE+8-2			;WORDTEXTADDR		EQU 	COUNT-4 			;LONGNUMER			EQU 	TEXTADDR-4			;POINTDENOM			EQU 	NUMER-4 			;POINTTXLOC			EQU 	-4					;POINTVARSIZE 		EQU 	TXLOC				;TOTAL LOCALS		LINK	A6,#VARSIZE 				;ALLOCATE STACK FRAME		MOVEM.L D5-D7/A3-A4,-(SP)			;SAVE REGSTXTLOOP MOVE	COUNT(A6),D6				;GET CHARACTER COUNT		BLE 	GOHOME						;QUIT IF COUNT <= 0		CMP 	#255,D6 					;is count > 255 ?		BLE.S	COUNTOK 					;no, continue		MOVE	#255,D6 					;yes, pin at 255COUNTOK 	if Gaudi then		jsrROM	CheckPic					; <18> DTY	else		JSR 	CHECKPIC					;SET UP A4,A3 AND CHECK PICSAVE	endif			BLE 	NOTPIC		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE;;  CHECK TXFONT;		MOVE	TXFONT(A3),D7				;GET THEPORT^.TXFONT		CMP 	PICTXFONT(A4),D7			;HAS IT CHANGED ?		BEQ		FONTOK						;NO, CONTINUE	IF (NOT Gaudi) THEN;---------- START OF <03Nov89 KON> ADDITION --------------		tst.w	picVersion(a4)				; is this a new picture?		beq		notNewName					; no, skip this opcode				move.l	picFontList(a4),a0			;get fontList handle		move.l	a0,d0						;check for nil		beq.s	notNewName					;drop down the id only		move.l	(a0),a0		addq.w	#4,a0						;skip handle size		move.w	(a0)+,d1					;get entry count		@2		cmp.w	(a0)+,d7					;have we seen this fond before?@1		dbeq	d1,@2						;no, keep looking		beq.s	notNewName					;yes, we found it		;; At this point we have found a non-zero fond ID which we have not seen previously; so we must add it to the fontList handle.  If the handle needs to be resized we do that; here as well.fontChunk	equ		50*2		exg.l	d0,a0						;get fontList handle in a0, end in d0		move.l	(a0),a1						;		sub.l	a1,d0						;get amnt of handle in use		cmp.l	(a1),d0						;same as size of handle?		blt.s	addFontName					;no need to grow list					add.w	#fontChunk,d0				;bump handleSize enough for 25 more fonts		move.l	d0,(a1)						;save the new size		_SetHandleSize						;grow list		move.l	picFontList(a4),a1			;get fontList handle		move.l	(a1),a1						;get fontList handle		tst.w	d0							;did we get it?		beq.s	addFontName					;yes, continue		sub.w	#fontChunk,(a1)				;couldn't grow it.		bra.s	notNewName					;skip name stuff		addFontName				sub.w	#256,sp						;alloc space for font name		move	d7,-(sp)					;push font id;		move.l	sp,-(sp);		addq.l	#2,(sp)						;push var font name		pea		2(sp)						;push var font name		_GetFName		move.b	(sp),d1						;check for empty string		beq.s	@badID						;don't record this name		move.l	picFontList(a4),a1			;get fontList handle		move.l	(a1),a1						;get fontList handle		addq.w	#4,a1						;point to number of entries in use - 1		addq.w	#1,(a1)						;bump the entry count		move.w	(a1)+,d0					;get new entry count and point to entry array		lsl.w	#1,d0						;changed for 68K 	<03Nov89 KON>		move.w	d7,(a1,d0)					;store new ID			if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#$2C,D0						;YES, GET Font Name PARAM OPCODE	if (Gaudi) then		jsrROM	DPutPicByte					; <18> DTY	else		jsr 	DPUTPICBYTE	 				;PUT OPCODE	endif		moveq	#3,d0						;prime data size (word length + byte length)		add.b	(sp),d0						;add in length of string		<16Jan90 KON>		move.w	d0,-(sp)					;dump out data length			if not( Gaudi) then		jsr 	PUTPICWORD					;	else		jsrROM	PutPicWord					; <18> DTY	endif			MOVE	D7,-(SP)	if not( Gaudi) then		jsr 	PUTPICWORD					;dump font id	else		jsrROM	PutPicWord					; <18>	DTY	endif				moveq	#1,d0						;prime string size		add.b	(sp),d0						;add in length of string		MOVE.L	sp,-(SP)					;PUSH ADDR OF TEXT		MOVE	D0,-(SP)					;PUSH COUNT	if not( Gaudi) then		jsr 	PUTPICDATA					;PUT TEXT DATA	else		jsrROM	PutPicData	endif	@badID	add.w	#256,sp						;de-alloc space for font name		ENDIF								;Leaving out pict font name matching for init											;Matching does not exist in 6.0.4notNewName;---------- END OF <03Nov89 KON> ADDITION --------------	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#3,D0						;YES, PUSH TXFONT PARAM OPCODE	if not( Gaudi) then		jsr 	DPUTPICBYTE	 				;PUT OPCODE	else		jsrROM	DPutPicByte					; <18> DTY	endif		MOVE	D7,-(SP)	if not( Gaudi) then		JSR 	PUTPICWORD					;PUT TXFONT PARAM	else		jsrROM	PutPicWord					; <18> DTY	endif			MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE		MOVE	D7,PICTXFONT(A4)			;UPDATE CURRENT STATE;;  CHECK TXFACE;FONTOK	MOVE.B	TXFACE(A3),D7				;GET THEPORT^.TXFACE		CMP.B	PICTXFACE(A4),D7			;HAS IT CHANGED ?		BEQ.S	FACEOK						;NO, CONTINUE	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#4,D0						;YES, PUSH TXFACE PARAM OPCODE	if not( Gaudi) then		JSR 	DPUTPICBYTE 				;PUT OPCODE	else		jsrROM	DPutPicByte					; <18> DTY	endif			MOVE.B	D7,D0	if not( Gaudi) then		JSR 	DPUTPICBYTE 				;PUT TXFACE PARAM	else		jsrROM	DPutPicByte					; <18>	DTY	endif		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE		MOVE.B	D7,PICTXFACE(A4)			;UPDATE CURRENT STATE;;  CHECK TXMODE;FACEOK	MOVE	TXMODE(A3),D7				;GET THEPORT^.TXMODE		CMP 	PICTXMODE(A4),D7			;HAS IT CHANGED ?		BEQ.S	MODEOK						;NO, CONTINUE	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#5,D0						;YES, PUSH TXMODE PARAM OPCODE	if not( Gaudi) then		JSR 	DPUTPICBYTE 				;PUT OPCODE	else		jsrROM	DPutPicByte	endif		MOVE	D7,-(SP)	if not( Gaudi) then		JSR 	PUTPICWORD					;PUT TXMODE PARAM	else		jsrROM	PutPicWord	endif			MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE		MOVE	D7,PICTXMODE(A4)			;UPDATE CURRENT STATE;;  CHECK TXSIZE;MODEOK	MOVE	TXSIZE(A3),D7				;GET THEPORT^.TXSIZE		CMP 	PICTXSIZE(A4),D7			;HAS IT CHANGED ?		BEQ.S	SIZEOK;NO, CONTINUE	if not( Gaudi) then		jsr		DOPICT2		endif		MOVEQ	#$0D,D0 					;YES, PUSH TXSIZE PARAM OPCODE		BSR		JDPUTPICBYTE				;PUT OPCODE		MOVE	D7,-(SP)	if not( Gaudi) then		JSR 	PUTPICWORD					;PUT TXSIZE PARAM	else		jsrROM	PutPicWord	endif		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE		MOVE	D7,PICTXSIZE(A4)			;UPDATE CURRENT STATE;;  CHECK SPEXTRA;SIZEOK	MOVE.L	SPEXTRA(A3),D7				;GET THEPORT^.SPEXTRA		CMP.L	PICSPEXTRA(A4),D7			;HAS IT CHANGED ?		BEQ.S	SPOK						;NO, CONTINUE	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#6,D0						;YES, PUSH SPEXTRA PARAM OPCODE		BSR		JDPUTPICBYTE				;PUT OPCODE		MOVE.L	D7,-(SP)		BSR		JPUTPICLONG 				;PUT SPEXTRA PARAM		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE		MOVE.L	D7,PICSPEXTRA(A4)			;UPDATE CURRENT STATESPOK;;  CHECK SMGRCHAREXTRA AND SMGRSLOP;	IF SCRIPT_CHAR_EXTRA THEN		tst.w	picVersion(a4)				; is this a new picture?		beq.s	@layoutOK					; no, skip this opcode.		move.l	grafGlobals(a5),a0			; load quickDraw globals.				<23>		move.l	qdChExtra(a0),d5			; load character extra amount.			<23>		move.l	qdRunSlop(a0),d7			; load run slop amount.					<23>		cmp.l	picQdChExtra(a4),d5			; has extra changed since last time?	<23>		bne.s	@layoutChanged				; yes -> update the layout state.		cmp.l	picQdRunSlop(a4),d7			; has slop changed since last time?		<23>		beq.s	@layoutOK					; no -> skip this.@layoutChanged	IF Gaudi THEN		moveq	#$2D,d0						; load line layout opcode.		bsr		JDPUTPICBYTE				; put line layout opcode.		move.w	#8,-(sp)					; push the data length.		jsrROM	PutPicWord					; put the data length into the picture.		move.l	d5,-(sp)					; push the character extra amount.		jsrROM	PutPicLong					; put the character extra into the picture.		move.l	d7,-(sp)					; push the run slop amount.		jsrROM	PutPicLong					; put the run slop into the picture.	ELSE		jsr		DOPICT2						; pad picture data with zero if necessary.		moveq	#$2D,d0						; load line layout opcode.		bsr		JDPUTPICBYTE				; put line layout opcode.		move.w	#8,-(sp)					; push the data length.		jsr 	PUTPICWORD					; put the data length into the picture.		move.l	d5,-(sp)					; push the character extra amount.		jsr 	PUTPICLONG					; put the character extra into the picture.		move.l	d7,-(sp)					; push the run slop amount.		jsr 	PUTPICLONG					; put the run slop into the picture.	ENDIF		move.l	picSave(a3),a4				; load the picSave handle.		move.l	(a4),a4						; load the picSave pointer.		move.l	d5,picQdChExtra(a4)			; update current character extra.		<23>		move.l	d7,picQdRunSlop(a4)			; update current run slop.				<23>@layoutOK	ENDIF;; CHECK GLYPH STATE;	IF hasGlyphState THEN		tst.w	picVersion(a4)				; is this a new picture?		beq.s	@glyphStateOK				; no, skip this opcode		btst.b	#splinePreferred,HiliteMode	; bit flag set in HiliteMode?		sne.b	d5							; yes, set outline preferred flag		lsl.l	#8,d5						; make room for preserve glyph flag		btst.b	#preserveGlyph,HiliteMode	; bit flag set in HiliteMode?		sne.b	d5							; yes, set preserve glyph flag		lsl.l	#8,d5						; make room for fractional widths flag		move.b	FractEnable,d5				; save fractional widths flag		lsl.l	#8,d5						; make room for scale disable flag		move.b	FScaleDisable,d5			; save scale disable flag		cmp.l	picGlyphState(a4),d5		; glyph state has changed?		beq.s	@glyphStateOK				; no, skip all this	IF Gaudi THEN		moveq	#$2E,d0						; load glyph state opcode		bsr.s	JDPUTPICBYTE				; put the opcode into the picture		move.w	#4,-(sp)					; push the data length		jsrROM 	PutPicWord	 				; put the data length into the picture  <34> fix case		move.l	d5,-(sp)					; push the glyph state		jsrROM	PUTPICLONG					; put the glyph state into the picture	ELSE		jsr		DOPICT2						; pad picture data with zero if necessary		moveq	#$2E,d0						; load glyph state opcode		bsr.s	JDPUTPICBYTE				; put the opcode into the picture		move.w	#4,-(sp)					; push the data length		jsr 	PUTPICWORD	 				; put the data length into the picture		move.l	d5,-(sp)					; push the glyph state		jsr		PUTPICLONG					; put the glyph state into the picture	ENDIF		move.l	picSave(a3),a4				; get picSave handle.		move.l	(a4),a4						; dereference picSave.		move.l	d5,picGlyphState(a4)		; update current glyph state@glyphStateOK	ENDIF;;  CHECK NUMER, DENOM;		MOVE.L	NUMER(A6),D7				;GET NUMER		MOVE.L	DENOM(A6),D5				;GET DENOM		CMP.L	PICTXNUMER(A4),D7			;HAS IT CHANGED ?		BNE.S	NOTSAME 					;YES, RECORD CHANGE		CMP.L	PICTXDENOM(A4),D5			;HAS IT CHANGED ?		BEQ.S	NUMEROK 					;NO, CONTINUENOTSAME	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#$10,D0 					;YES, PUSH TXRATIO OPCODE		BSR.S	JDPUTPICBYTE				;PUT OPCODE		MOVE.L	D7,-(SP)		BSR.S	JPUTPICLONG 				;PUT NUMER		MOVE.L	D5,-(SP)		BSR.S	JPUTPICLONG 				;PUT DENOM		MOVE.L	PICSAVE(A3),A4				;GET PICSAVE HANDLE		MOVE.L	(A4),A4 					;DE-REFERENCE PICSAVE		MOVE.L	D7,PICTXNUMER(A4)			;UPDATE CURRENT STATE		MOVE.L	D5,PICTXDENOM(A4)			;UPDATE CURRENT STATENUMEROK;-------------------------------------------------------------;;  USE DH AND DV TO CHOOSE ONE OF FOUR TEXT OPCODES.;		MOVE.L	PNLOC(A3),D5					;GET CURRENT PNLOC		SUB.L	PICTXLOC(A4),D5 				;CALC DV.DH		MOVE.L	D5,D0							;COPY DV.DH		AND.L	#$FF00FF00,D0					;ARE DH AND DV BOTH 0..255 ?		BEQ.S	SHORT							;YES, USE SHORT FORM	if not( Gaudi) then		jsr		DOPICT2		endif		MOVEQ	#$28,D0		BSR.S	JDPUTPICBYTE					;NO, PUT LONGTEXT OPCODE		MOVE.L	PNLOC(A3),-(SP)		BSR.S	JPUTPICLONG 					;PUT PNLOC 4 BYTES		BRA.S	TEXT2							;AND CONTINUEJDPUTPICBYTE	if not( Gaudi ) then		JMP 	DPUTPICBYTE	else		jmpROM	DPutPicByte	endifJPUTPICLONG	if not( Gaudi ) then		JMP 	PUTPICLONG	else		jmpROM	PutPicLong	endifSHORT	MOVE.L	D5,D0							;YES, COPY DV.DH		AND.L	#$00FF0000,D0					;IS DV = 0 ?		BNE.S	DV								;NO, CONTINUE	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#$29,D0		BSR.S	JDPUTPICBYTE					;YES, PUT DHTEXT OPCODE		BRA.S	SHARE2							;SHARE COMMON CODEDV		TST.B	D5								;IS DH = 0 ?		BNE.S	DHDV							;NO, CONTINUE	if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#$2A,D0		BSR.S	JDPUTPICBYTE					;YES, PUT DHTEXT OPCODE		BRA.S	SHARE1							;SHARE COMMON CODEDHDV			if not( Gaudi) then		jsr		DOPICT2	endif				MOVEQ	#$2B,D0		BSR.S	JDPUTPICBYTE					;PUT DHDVTEXT OPCODE		MOVE.B	D5,D0		BSR.S	JDPUTPICBYTE					;PUT DH 0..255 TO PICSHARE1	SWAP	D5								;PUT DV IN LO WORDSHARE2	MOVE.B	D5,D0		BSR.S	JDPUTPICBYTE					;PUT DH OR DV 0..255 TO PICTEXT2	MOVE.B	D6,D0		BSR.S	JDPUTPICBYTE					;PUT COUNT BYTE TO PIC		MOVE.L	TEXTADDR(A6),-(SP)				;PUSH ADDR OF TEXT		MOVE	D6,-(SP)						;PUSH COUNT	if not( Gaudi ) then		JSR 	PUTPICDATA						;PUT TEXT DATA	else		jsrROM	PutPicData						; <18> DTY	endif		MOVE.L	PICSAVE(A3),A4					;GET PICSAVE HANDLE		MOVE.L	(A4),A4 						;DE-REFERENCE PICSAVE		MOVE.L	PNLOC(A3),PICTXLOC(A4)			;UPDATE PICTXLOC STATE;;  DrText(count,textAddr,numer,denom);;NOTPIC	MOVE	D6,-(SP)					;PUSH COUNT		MOVE.L	TEXTADDR(A6),-(SP)			;PUSH TEXTADDR		MOVE.L	NUMER(A6),-(SP) 			;PUSH NUMER		MOVE.L	DENOM(A6),-(SP) 			;PUSH DENOM		jsr		BWDrText					; <18>	DTY		SUB 	D6,COUNT(A6)				;was count > 255 ?		BLE.S	GOHOME						;no, quit		MOVE.L	TEXTADDR(A6),A0 			;yes, get old textaddr		ADD 	D6,A0						;offset for characters done		MOVE.L	A0,TEXTADDR(A6) 			;update textAddr		BRA 	TXTLOOP 					;and loop for moreGOHOME	MOVEM.L (SP)+,D5-D7/A3-A4			;RESTORE REGS		UNLINK	PARAMSIZE,'STDTEXT 'BWStdTxMeas	FUNC	EXPORT		IF SCRIPT_CHAR_EXTRA THEN		IMPORT	CalcCharExtra	ENDIF;------------------------------------------;;  FUNCTION  StdTxMeas(count: INTEGER; textAddr: Ptr;;			   VAR numer,denom: Point;;			   VAR info: FontInfo): INTEGER;;;  Measure some text, returning unscaled values plus updated scale factor.;  Fills info record with unscaled ascent, descent, widMax, and leading,;  and returns unscaled integer width as the function value.;;  Also leaves unscaled fixed point width in QD global 'fixTxWid';  and stashes FMOutPtr in QD global 'fontPtr' for DrawText.;PARAMSIZE		EQU 	18RESULT			EQU 	PARAMSIZE+8 		;FCN RESULT IS A WORDCOUNT			EQU 	RESULT-2			;WORDTEXTADDR		EQU 	COUNT-4 			;LONGNUMER			EQU 	TEXTADDR-4			;LONG, VAR ADDRDENOM			EQU 	NUMER-4 			;LONG, VAR ADDRINFO			EQU 	DENOM-4 			;LONG, ADDR OF FONTINFOINREC			EQU 	-16 				;FMInput recordcharacterExtra	EQU		INREC-4				;LONGwidthExtra		EQU		characterExtra-4	;LONG 								<27-CEL>encodingTable	EQU		widthExtra-4		;LONGVARSIZE 		EQU 	encodingTable		LINK	A6,#VARSIZE 				;ALLOCATE LOCALS	if	(hasDoubleByte) then		movem.l	d4/a2-a3,-(sp)				; save double-byte registers		clr.l	encodingTable(a6)			; assume no encoding table	endif			MOVEM.L	D3/A4,-(SP)					;SAVE REG						<24-CEL/RWB>		MOVE.L	GRAFGLOBALS(A5),A4			;POINT TO QUICKDRAW GLOBALS		MOVE.L	THEPORT(A4),A0				;GET CURRENT GRAFPORT		LEA 	INREC(A6),A1				;POINT TO FMINPUT RECORD		MOVE	TXFONT(A0),(A1)+			;GET TXFONT FROM THEPORT		MOVE	TXSIZE(A0),(A1)+			;GET TXSIZE FROM THEPORT		MOVE.B	TXFACE(A0),(A1)+			;GET TXFACE FROM THEPORT		ST		(A1)+						;ALWAYS SET NEEDBITS TRUE		MOVE	DEVICE(A0),(A1)+			;GET DEVICE FROM THEPORT		MOVE.L	NUMER(A6),A0				;POINT TO NUMER		MOVE.L	(A0),(A1)+					;INSTALL INPUT NUMER		MOVE.L	DENOM(A6),A0				;POINT TO DENOM		MOVE.L	(A0),(A1)+					;INSTALL INPUT DENOM		CLR.L	-(SP)						;ROOM FOR FCN RESULT		PEA 	INREC(A6)					;PUSH INPUT RECORD		_SwapFont							;CALL FMSWAPFONT		MOVE.L	(SP)+,A1					;POP FMOUTPUT POINTER		MOVE.L	A1,FONTPTR(A4)				;STASH FMOUTPTR FOR LATER; determine scaled character extra, if applicable		clr.l	characterExtra(a6)				; clear the character extra.	IF SCRIPT_CHAR_EXTRA THEN		move.l	grafGlobals(a5),a0				; load quickDraw globals.				<23>		move.l	qdChExtra(a0),d0				; load the character extra.				<23>		beq.s	@zeroCharExtra					; yes -> skip call to scale.		bsr		CalcCharExtra					; scale by point size, etc.		move.l	d0,characterExtra(a6)			; store scaled character extra.@zeroCharExtra	ENDIF		MOVE.L	INFO(A6),A0 					;POINT TO VAR INFO RECORD		CLR.L	(A0)							;INIT TO (0,0,0,0)		CLR.L	4(A0)							;ALL 4 WORDS		CLR.L	D1								;INIT WIDTH TO 0.0				<27-CEL>		MOVE.L	A1, -(SP)						;Save off A1 to use for WidthTabHandle		MOVE.L	WidthTabHandle, A1				;Get the Width Table		MOVE.L	(A1), A1						;get the pointer		TST.B	WidthIsSpline(A1)				;Is it a spline font		BEQ.S	@doNormal						;No then branch normal		MOVE.L	expandMem, A1							; get low mem expand		MOVE.L	ExpandMemRec.emSplineKey(A1), A1		; Handle to splineKey		MOVE.L	(A1), A1								; pointer to splinekey		MOVE.L	splineKeyRec.cacheHand(A1), D0			; is there a cache		BEQ.S	@bailForZeros		MOVE.L	D0, A1									; get Handle in addr reg		TST.L	(A1)									; Is it purged		BEQ.S	@bailForZeros							; bail since we have no cache		MOVE.L	(A1), A1					;get the pointer	WITH	cache							;<13>		MOVE.W	ascent(A1), (A0)+			;Assign the Ascent value		MOVE.W	descent(A1), (A0)+			;Assign sfnt Descent		MOVE.W	widMax(A1), (A0)+			;Assign WidMax		MOVE.W	leading(A1), (A0)			;Assign Leading		MOVE.W	rOverHMax(A1), D1			;get rExtraHang value			<27-CEL>		ADD.W	rightItalic(A1), D1			;Add in possible italic slop	<27-CEL>		ADD.W	#3, D1						;Add 3 for grid fitting slop	<27-CEL>	if (hasDoubleByte) then		move.l	fEncodingTablePointer(a1),encodingTable(a6)	; load encoding table pointer	endif	ENDWITH									;<13>		MOVE.L	(SP)+, A1					;Restore A1		BRA.S	@cont						;Skip past byte assignments@bailForZeros		CLR.L	(A0)+						;Zero out ascent and descent		CLR.L	(A0)+						;Zero out widMax and leading		MOVE.L	(SP)+, A1					;Restore A1		BRA.S	@cont						;Skip past byte assignments@doNormal									;<1.6-4april89-CEL>		MOVE.L	(SP)+, A1					;Restore A1		MOVE.B	13(A1),1(A0)				;FILL IN UNSIGNED ASCENT		MOVE.B	14(A1),3(A0)				;FILL IN UNSIGNED DESCENT		MOVE.B	15(A1),5(A0)				;FILL IN UNSIGNED WIDMAX		MOVE.B	16(A1),D0				;GET SIGNED LEADING		EXT.W	D0					;SIGN EXTEND TO WORD		MOVE.W	D0,6(A0)				;FILL IN LEADING@cont										;Label to skip byte assignment;;  UPDATE NUMER AND DENOM;		MOVE.L	NUMER(A6),A0				;GET VAR ADDR		MOVE.L	18(A1),(A0) 			;UPDATE NUMER		MOVE.L	DENOM(A6),A0				;GET VAR ADDR		MOVE.L	22(A1),(A0) 			;UPDATE DENOM		MOVE.L	expandMem,A0					; get low memory expand pointer.	<26>		MOVE.L	ExpandMemRec.emSplineKey(A0),A0	; get handle to splineKey globals.	<26>		MOVE.L	(A0), A0						; get pointer to splineKey globals.	<26>		CMP.W	#-2, splineKeyRec.safeCount(A0)	;-2 means add penloc			<28-CEL>		BNE.S	@noPen						;skip penloc add					<28-CEL>		MOVE.L	thePort(A4),A1				;GET CURRENT GRAFPORT				<24-CEL/RWB>		MOVE.W	PNLOC+H(A1),D0				;add penlocation					<28-CEL>		BLE.S	@noPen						;skip if negative					<28-CEL>		ADD.W	D0,D1						;add penlocation					<28-CEL>@noPen	ADD.W	#5, D1						;ADD one for slop					<27-CEL/RWB>		SWAP	D1							;									<24-CEL/RWB>		MOVE.L	D1, widthExtra(A6)			;save off width extra value			<27-CEL>		MOVE.L	D1, D3						;Init to penloc + 1.0				<24-CEL/RWB>		MOVE.W	#-1, splineKeyRec.safeCount(A0)	; init to -1 for flagging			<26>		MOVE.L	TEXTADDR(A6),A0 			;POINT TO CHARACTERS		MOVE.L	WidthTabHandle,A1		;Get the Handle		MOVE.L	(A1),A1					;WidthPtr	if (hasDoubleByte) then		move.l	encodingTable(a6),a2		; load encoding table pointer		move.l	a2,a3						; copy pointer		adda	#256,a3						; offset pointer to low byte mapping table	endif				MOVE	COUNT(A6),D2				;GET CHARACTER COUNT		BRA.S	MORE					;GO TO LOOP STARTNEXTCH	CLR 	D0					;GET READY FOR BYTE		MOVE.B	(A0)+,D0				;GET A CHARACTER			if (hasDoubleByte) then		tst.l	encodingTable(a6)			; have encoding table?		beq		@singleByteFont				; no -> skip this		tst.b	0(a2,d0.w)					; high byte of double byte character?		beq		@singleByteCharacter		; no -> skip this		tst.w	d2							; more bytes left in text?		ble		@remapHighByte				; no -> remap the high byte		sub.w	#1,d2						; decrement the text count		clr.w	d4							; clear high byte of low word		move.b	(a0)+,d4					; grab the low byte and increment the text pointer		tst.b	0(a3,d4.w)					; is the low byte valid?		bne		@measureHighByte			; yes -> use the high byte for the width		@remapHighByte		move.b	#1,d0						; remap the high byte to the missing character		@singleByteFont@singleByteCharacter@measureHighByte	endif				LSL 	#2,D0					;QUAD FOR TABLE OFFSET		ADD.L	0(A1,D0),D1 			;ADD FIXED POINT WIDTH		BVS		OverFlow					;CHECK FOR POSSIBLE OVERFLOW  		<24-CEL/RWB>		MOVE.L	D1, D3						;save of safe length				<24-CEL/RWB>		CMP		#$80,D0						;space character?					<jdt 14Mar90>		BEQ.S	MORE						;skip character extra				<jdt 14Mar90>		ADD.L	characterExtra(A6),D1		;add in character extra				<jdt 14Mar90>		BVS		OverFlow					;if overflow, set to big positive 	<24-CEL/RWB>		MOVE.L	D1, D3						;save of safe length				<24-CEL/RWB>MORE	DBRA	D2,NEXTCH				;LOOP FOR ALL CHARS		BRA.S	noOverFlow					;Branch around overflow corrections <24-CEL/RWB>OverFlow		ADDQ	#1, D2						;Add back 1 to the remaining count	<24-CEL/RWB>		NEG		D2							;Negate for addition				<24-CEL/RWB>		ADD.W	Count(A6), D2				;newCount = OrigCount - remainder	<24-CEL/RWB>		MOVE.L	expandMem,A0							; get low memory expand pointer.	<24-CEL/RWB>		MOVE.L	ExpandMemRec.emSplineKey(A0),A0			; get handle to splineKey globals.	<24-CEL/RWB>		MOVE.L	(A0), A0								; get pointer to splineKey globals.	<24-CEL/RWB>		MOVE.W	D2, splineKeyRec.safeCount(A0)			; new count				<24-CEL/RWB>		MOVE.L	D3, D1						;restore safe length				<24-CEL/RWB>noOverFlow									;									<24-CEL/RWB>		SUB.L	widthExtra(A6), D1			;sub widthExtra calc from width		<27-CEL>		MOVE.L	D1,fixTxWid(A4) 		;STASH FIXED POINT WIDTH		SWAP	D1					;GET HI WORD = INTEGER PORTION		MOVE	D1,RESULT(A6)				;UPDATE FUNCTION RESULT		MOVEM.L	(SP)+,D3/A4 				;RESTORE REG						<24-CEL/RWB>		if	(hasDoubleByte) then		movem.l	(sp)+,d4/a2-a3				; restore double-byte registers	endif			UNLINK	PARAMSIZE,'STDTXMEA'	IF	(SCRIPT_CHAR_EXTRA OR hasDoubleByte) THEN	;<1.4-4april89-CEL> <6> CEL		PROC				EXPORT	BWMeasureText			IMPORT	JStdTxMeas	IF SCRIPT_CHAR_EXTRA THEN		IMPORT	CalcCharExtra	ENDIF;--------------------------------------------------------------------;;  PROCEDURE MeasureText(count: INTEGER; textAddr,charLocs: Ptr);;;  Measure some text, returning (scaled) screen widths in charlocs.;;  Charlocs points to an array of count+1 integers.;;	Modification History; 29Oct86	CRC	Call textMeasProc via TextWidth for the benefit of;				Think’s Macintosh Pascal.  (Margie TextEdit used to use;				TextWidth but changed to MeasureText for efficiency;;				Think added styles to TextEdit inside the bottleneck;				procs that no longer got called.  This calls the bottleneck;				proc only if it is different from StdTxMeas, since the;				speed hit is appreciable.); 05Nov86	CRC	fixed register bug (grafport clobbered)				PARAMSIZE		EQU 	10COUNT			EQU 	PARAMSIZE+8-2		;WORDTEXTADDR		EQU 	COUNT-4 			;LONG, Ptr to ASCIICHARLOCS		EQU 	TEXTADDR-4			;LONG, Ptr to output arrayINREC			EQU 	-16 				;FMInput recordcharacterExtra	EQU		INREC-4				;LongencodingTable	EQU		characterExtra-4	;LONG	IF SCRIPT_CHAR_EXTRA THEN				;									<13> pkenumer			EQU		encodingTable-4		;									<13> pkedenom			EQU		numer-4				;									<13> pkeVARSIZE 		EQU 	denom				;									<13> pke	ELSE									;									<13> pkeVARSIZE 		EQU 	encodingTable	ENDIF									;									<13> pkeStdTxMeasTrap	EQU		$EDBWMeasureText			LINK	A6,#VARSIZE 				;ALLOCATE LOCALS		move.l	#$00010001,numer(a6)		; set numerator to one/one		move.l	#$00010001,denom(a6)		; set denominator to one/one	if (hasDoubleByte) then		move.l	d7,-(sp)					; save low byte scratch register	endif		MOVEM.L D3-D6/A2-A4,-(SP)			;SAVE REGS		MOVE.L	TextAddr(A6),A2		MOVE.L	CharLocs(A6),A3		MOVE	Count(A6),D3		MOVEQ	#0,D4						;INIT WIDTH TO 0.0		MOVE.L	GRAFGLOBALS(A5),A4			;POINT TO QUICKDRAW GLOBALS		MOVE.L	THEPORT(A4),A0				;GET CURRENT GRAFPORT		;  if there is a txMeasProc not equal to StdTxMeas, call CharWidth instead		MOVE.L	grafProcs(A0),D0			;are there overridden graf procs?		BEQ.S	useSwapFont		MOVE.L	D0,A1		MOVE.L	txMeasProc(A1),D0		lea		JStdTxMeas,a1				; <18> DTY		MOVE.L	(a1),A1		CMP.L	(A1),D0		BEQ.S	useSwapFont		MOVEQ	#0,D6						;furthest character right so far		MOVEQ	#0,D5						;sum to add in to fix text width		SUBQ	#2,SP						;make room for the returned widthnextChar		MOVE.L	A2,-(SP)		CLR		-(SP)		MOVE	D4,-(SP)		_TextWidth							;Call through the trap if system		MOVE	(SP),D0						;get the width		CMP		D6,D0						;is it smaller than the last measurement?		BGE.S	@notSmaller					;if this is equal to or larger than last, no prob.		ADD		D6,D5						;if smaller, add last measurement to sum@notSmaller		ADD		D5,D0						;add sum to character position		MOVE	D0,(A3)+ 					MOVE	(SP),D6						;make this measure into last measure (for next time)		ADDQ	#1,D4		CMP		D3,D4		BLE.S	nextChar					;LOOP FOR COUNT+1 CHARLOCS		ADDQ	#2,SP						;toss character width	IF SCRIPT_CHAR_EXTRA THEN				;									<13> pke		move.w	numer+h(a6),d3				; set up for scaling				<13> pke		move.w	denom+h(a6),d4				; set up for scaling				<13> pke		bra		DoMeasureTextScaling		; go do scaling						<13> pke	ELSE									;									<13> pke		BRA		NoScale	ENDIF									;									<13> pke		useSwapFont;;  Call swapfont to set up width table and return numer,denom:;		LEA 	INREC(A6),A1				;POINT TO FMINPUT RECORD		MOVE	TXFONT(A0),(A1)+			;GET TXFONT FROM THEPORT		MOVE	TXSIZE(A0),(A1)+			;GET TXSIZE FROM THEPORT		MOVE.B	TXFACE(A0),(A1)+			;GET TXFACE FROM THEPORT		ST		(A1)+						;ALWAYS SET NEEDBITS TRUE		MOVE	DEVICE(A0),(A1)+			;GET DEVICE FROM THEPORT	IF SCRIPT_CHAR_EXTRA THEN				;									<13> pke		MOVE.L	numer(a6),(A1)+				;supply local numer					<13> pke		MOVE.L	denom(a6),(A1)+				;supply local denom					<13> pke	ELSE									;									<13> pke		MOVE.L	#$00010001,(A1)+			;INSTALL INPUT NUMER = 1,1		MOVE.L	#$00010001,(A1)+			;INSTALL INPUT DENOM = 1,1	ENDIF									;									<13> pke		CLR.L	-(SP)						;ROOM FOR FCN RESULT		PEA 	INREC(A6)					;PUSH INPUT RECORD		_SwapFont							;CALL FMSWAPFONT;;	Determine scaled character extra, if applicable:;		clr.l	characterExtra(a6)				; clear the character extra.	IF SCRIPT_CHAR_EXTRA THEN		move.l	grafGlobals(a5),a0				; load quickDraw globals.		<23>		move.l	qdChExtra(a0),d0				; load the character extra.		<23>		beq.s	@zeroCharExtra					; yes -> skip call to scale.		bsr		CalcCharExtra					; scale by point size, etc.		move.l	d0,characterExtra(a6)			; store scaled character extra.@zeroCharExtra	ENDIF;;  Step thru characters, adding up unscaled widths and storing in charLocs:;		MOVE.L	WidthTabHandle,A1			;Get the Handle		MOVE.L	(A1),A1						;WidthPtr		if (hasDoubleByte) then		clr.l	encodingTable(a6)					; assume no encoding table		tst.b	WidthIsSpline(a1)					; have TrueType cache?		beq.s	@notTrueType						; no, skip this		move.l	expandMem,a0						; load expanded memory pointer		move.l	ExpandMemRec.emSplineKey(a0),a0		; load TrueType globals handle		move.l	(a0),a0								; load TrueType globals pointer		move.l	splineKeyRec.cacheHand(a0),d0		; do we have a cache?		beq.s	@cacheMissing						; no, skip this		move.l	d0,a0								; load current cache handle		move.l	(a0),d0								; cache purged from memory?		beq.s	@cachePurged						; yes, skip this		move.l	d0,a0								; load current cache pointer		move.l	cache.fEncodingTablePointer(a0),a4	; load encoding table pointer		move.l	a4,encodingTable(a6)				; keep a copy for testing@notTrueType@cacheMissing@cachePurged	endifNEXTCH	SWAP	D4							;GET HI WORD OF WIDTH		MOVE.W	D4,(A3)+					;STORE IN CHARLOCS		SWAP	D4							;RETURN WIDTH TO FIXED POINT		CLR 	D0							;GET READY FOR BYTE		MOVE.B	(A2)+,D0					;GET A CHARACTER		if (hasDoubleByte) then		tst.l	encodingTable(a6)			; have encoding table?		beq		@singleByteFont				; no -> skip this		tst.b	0(a4,d0.w)					; high byte of double byte character?		beq		@singleByteCharacter		; no -> skip this		tst.w	d3							; more bytes left in text?		ble		@remapHighByte				; no -> remap the high byte		sub.w	#1,d3						; decrement the text count		clr.w	d7							; clear high byte of low word		move.b	(a2)+,d7					; grab the low byte and increment the text pointer		move.l	a4,a0						; load the high byte mapping table pointer		adda	#256,a0						; offset to the low byte mapping table		tst.b	0(a0,d7.w)					; is the low byte valid?		beq		@remapHighByte				; no -> remap the high byte				lsl		#2,d0						; convert to fixed width table offset		add.l	0(a1,d0),d4					; add fixed point width		add.l	characterExtra(a6),d4		; always add in character extra		swap	d4							; get integer portion of accumulated width		move.w	d4,(a3)+					; ouch, store integer width into charLocs array		swap	d4							; restore d1 to fixed point		bra		MORE						; restart the loop@remapHighByte		move.b	#1,d0						; remap the high byte to the missing character		@singleByteFont@singleByteCharacter	endif		LSL 	#2,D0						;QUAD FOR TABLE OFFSET		ADD.L	0(A1,D0),D4 				;ADD FIXED POINT WIDTH		CMP		#$80,D0						;is it a space?						<jdt 14Mar90>		BEQ.S	MORE						;skip character extra if so			<jdt 14Mar90>		ADD.L	characterExtra(A6),D4		;add in character extra				<jdt 14Mar90>MORE	DBRA	D3,NEXTCH					;LOOP FOR COUNT+1 CHARLOCS			<jdt 14Mar90>;;  if font is horizontally stretched, scale all widths accordingly;		MOVE.L	(SP)+,A0					;POP FMOUTPUT POINTER		MOVE.W	18+H(A0),D3 				;GET NUMER.H		MOVE.W	22+H(A0),D4 				;GET DENOM.HDoMeasureTextScaling						;									<13> pke		CMP 	D3,D4						;IS NUMER.H = DENOM.H ?		BEQ.S	NOSCALE 					;YES, SKIP SCALING		MOVE.L	CHARLOCS(A6),A2 			;NO, POINT TO CHARLOCS		MOVE	COUNT(A6),D2				;GET CHARACTER COUNTNEXTCH2 MOVE	(A2),D0 					;GET CHARLOC		MULU	D3,D0						;MUL BY NUMER		DIVU	D4,D0						;DIV BY DENOM		MOVE	D0,(A2)+					;UPDATE CHARLOC		DBRA	D2,NEXTCH2					;LOOP FOR COUNT+1 CHARLOCSNOSCALE		MOVEM.L (SP)+,D3-D6/A2-A4			;RESTORE REGS	if	(hasDoubleByte) then		move.l	(sp)+,d7					; restore low byte scratch register	endif		UNLK	A6		MOVE.L	(SP)+,A0		ADD		#PARAMSIZE,SP		JMP		(A0)	ENDIF		CASE OFF		END                                                                                                                                                                                                                                                                                                                          