;;	File:		Arith8Blt.a;;	Contains:	xxx put contents here (or delete the whole line) xxx;;	Written by:	xxx put name of writer here (or delete the whole line) xxx;;	Copyright:	© 1987-1990 by Apple Computer, Inc., all rights reserved.;;	Change History (most recent first):;;		 <5>	 10/8/90	SMC		Removed patchciRom tests in bTransparent8 and rTransparent8.;									They are now handled in QDciPatchROM.a.;		 <4>	 8/16/90	SMC		Fixed horizontal pattern alignment of complex patterns in;									transparent and arithmetic slab transfer modes.;		 <3>	 1/29/90	BAL		Fixed conditionals for JP build.;		 <2>	 1/28/90	KON		Conditionalized an equate table for ci Rom patch.  This file is;									included by QDciPatchROM.a.;	   <1.1>	11/18/89	BAL		Made a real part of 32-Bit QuickDraw 1.2;	   <1.0>	 11/9/89	BAL		Added to Ease;	   <1.2>	 1/16/89	CCH		Merged 6.0.3 final sources into 7.0.;	  <•1.1>	11/16/88	CCH		Updated to newest version.;	   <AJH>	 2/23/88	fixed		arithmetic mode cache initialization (add and sub modes) (1.1);	   <AJH>	 2/22/88	fixed		bug in 8-1 copybits (can't assume map is 0 or 1 only);	   <AJH>	 2/21/88	fixed		wrong reg (A4 -> A2) bump bug in oval handler (MacDraw crash);									(1.0);	   <AJH>	 2/21/88	fixed		bug in arithmetic mode cache initialization;	   <AJH>	 2/18/88	fixed		bug in transparent mode fill (LSR instead of ASR);	   <AJH>	 2/18/88	fixed		bug in unclipped, less than 5 wide arithmetic modes;	   <AJH>	  2/7/88	added		configuration code at startup time (.99);	   <AJH>	  2/4/88	fixed		arithmetic mode bug with type 0 patterns (-$68, not -68!) (.987);									AJH 05-Feb-88 converted to cdev;	   <AJH>	  2/4/88	added		transparent modes;	   <AJH>	  2/2/88	added		blend mode; fixed arithmetic copyBits bug AJH 03-Feb-88 removed;									hilite by invert hack (.985) AJH 03-Feb-88 further optimized;									hilite, 1 to 8 copybits;	   <AJH>	  2/1/88	added		arithmetic transfer mode fills for clipped rects (.98);	   <AJH>	 1/31/88	added		arithmetic transfer mode fills for unclipped rects;	   <AJH>	 1/30/88	added		arithmetic transfer mode fills for rrects/ovals;	   <AJH>	 1/29/88	added		oval/rrects with complex patterns;	   <AJH>	 1/28/88	check		if already installed; if so, display logo AJH 29-Jan-88 removed;									OR mode complex fills; fixed OR mode simple fills AJH 29-Jan-88;									reject patterns > 8 pixels wide;	   <AJH>	 1/28/88	INIT		wasn't locked bug (.97);	   <AJH>	 1/27/88	OR		mode fills (simple and complex patterns) (.96);	   <AJH>	 1/26/88	added		oval/rrects in OR mode;	   <AJH>	 1/24/88	broke		LogoPict into separate resource; separate 1-bit logo (.95) AJH;									25-Jan-88 region counting for InvertClip AJH 26-Jan-88;									significantly improved oval/rrects when unclipped;	   <AJH>	 1/23/88	fixed		bug when region is a mask (CB1to8 from CopyMask);	   <AJH>	 1/22/88	fixed		OR mode fill, added $335 for MacDraw Plus;	   <AJH>	 1/17/88	fixed		scaling rejection bug in mapped copyBits AJH 18-Jan-88;									implemented fast 8 to 1 copyBits; fixed 1-8 seekRgn bug (.94);									AJH 20-Jan-88 region counting for clipped blit;	   <AJH>	 1/16/88	fixed		seek region bug in mapped copyBits (.93);	   <AJH>	 1/14/88	fixed		bug in unclipped pattern fill (.92);	   <AJH>	 1/13/88	made		fills work in modes other than 8-bit (.91);	   <AJH>	 1/11/88	st		Beta release, version .9;;	To Do:;;EASE$$$ READ ONLY COPY of file “arith8blt.a”; 1.1	BAL 11/18/1989 Made a real part of 32-Bit QuickDraw 1.2; 1.0	BAL 11/09/1989 Added to Ease; END EASE MODIFICATION HISTORY ; 1.2	CCH 01/16/1989 Merged 6.0.3 final sources into 7.0.;•1.1	CCH 11/16/1988 Updated to newest version.			PRINT		ON; File QuickLoops.a;-----------------------------------------------------------------------------;  ;   High performance Mac II Color QuickDraw Inner Loops (for 8-bit mode);;	  written by Andy Hertzfeld  December 22, 1987;;   This INIT patches out some of the Color QuickDraw inner loop traps ;   to improve 8-bit performance by a factor of 2 to 3 (or even more!);;   Modification History:;;        AJH  11-Jan-88   1st Beta release, version .9;        AJH  13-Jan-88   made fills work in modes other than 8-bit (.91);        AJH  14-Jan-88   fixed bug in unclipped pattern fill (.92);        AJH  16-Jan-88   fixed seek region bug in mapped copyBits (.93);        AJH  17-Jan-88   fixed scaling rejection bug in mapped copyBits;        AJH  18-Jan-88   implemented fast 8 to 1 copyBits; fixed 1-8 seekRgn bug (.94);        AJH  20-Jan-88   region counting for clipped blit;        AJH  22-Jan-88   fixed OR mode fill, added $335 for MacDraw Plus;        AJH  23-Jan-88   fixed bug when region is a mask (CB1to8 from CopyMask);        AJH  24-Jan-88   broke LogoPict into separate resource; separate 1-bit logo (.95);        AJH  25-Jan-88   region counting for InvertClip;        AJH  26-Jan-88   significantly improved oval/rrects when unclipped ;        AJH  26-Jan-88   added oval/rrects in OR mode  ;        AJH  27-Jan-88   OR mode fills (simple and complex patterns) (.96);        AJH  28-Jan-88   INIT wasn't locked bug  (.97);        AJH  28-Jan-88   check if already installed; if so, display logo;        AJH  29-Jan-88   removed OR mode complex fills; fixed OR mode simple fills;        AJH  29-Jan-88   reject patterns > 8 pixels wide;        AJH  29-Jan-88   added oval/rrects with complex patterns   ;        AJH  30-Jan-88   added arithmetic transfer mode fills for rrects/ovals;        AJH  31-Jan-88   added arithmetic transfer mode fills for unclipped rects;        AJH  01-Feb-88   added arithmetic transfer mode fills for clipped rects (.98);        AJH  02-Feb-88   added blend mode; fixed arithmetic copyBits bug;        AJH  03-Feb-88   removed hilite by invert hack (.985);        AJH  03-Feb-88   further optimized hilite, 1 to 8 copybits;        AJH  04-Feb-88   added transparent modes;        AJH  04-Feb-88   fixed arithmetic mode bug with type 0 patterns (-$68, not -68!) (.987);	 	 AJH  05-Feb-88   converted to cdev;        AJH  07-Feb-88   added configuration code at startup time (.99);        AJH  18-Feb-88   fixed bug in transparent mode fill (LSR instead of ASR);        AJH  18-Feb-88   fixed bug in unclipped, less than 5 wide arithmetic modes;        AJH  21-Feb-88   fixed bug in arithmetic mode cache initialization;        AJH  21-Feb-88   fixed wrong reg (A4 -> A2) bump bug in oval handler (MacDraw crash) (1.0);        AJH  22-Feb-88   fixed bug in 8-1 copybits (can't assume map is 0 or 1 only);        AJH  23-Feb-88   fixed arithmetic mode cache initialization (add and sub modes) (1.1);;---- A New Life at Apple --------------------;	; PB415	 DAF/BAL	01Mar88		QuickerDraw integrated into system patch files; PB427	 BAL		17Mar88		Corrected some edge masking bugs in arithmetic modes.;								Return to ROM if arithmetic mode copybits from left to right.; PB428	 DAF		18Mar88		Fixed QuickerDraw to be A/UX friendly.; PB433	 DAF		22Mar88		Improved dispatches to ROM (saved a couple of bytes and cycles); 		 BAL		25Mar88		Converted to use symbolic stack frame references; PB446	 DBG		29Mar88		Fixed up missed JMPs into ROM in QuickerDraw.a, which cause certain;								CopyBits cases to crash.; PB448  DBG		30Mar88		Fixed erroneous references to HBUMP to be to SRCBUMP; PB452	 BAL		01Apr88		Fixed bug in DrawSlab OR mode handler ($381) to preserve fgColor; PB471	 BAL		18Apr88		Fixed 1 to 8 bit expansion to first insure CLUT is B/W.; PB473	 DAF		19Apr88		Modified PB471 to allow more cases to be accelerated.; PB471	 BAL/DVB	13Jun88		Fixed 1 to 8 bit expansion to first insure src = scalebuf;								(i.e. dest not before pixmap's baseAddr).; PBnnn  d√b		12Jul88		Fixed error in 8 to 1 when white doesn't map to white.;;--------------------------------------------------------------------------------------------------fooo	proc			; make following defines global		endproc	IF (&TYPE('patchciRom') = 'UNDEFINED') THENpatchciRom	EQU		0	ENDIF					MACHINE	MC68020		; for reference, here are the patched traps	IF 0 THEN			InstToolTp	AddOverFillO,$38A		InstToolTp	SubOverFillO,$38E		InstToolTp	AddPinFillO,$389		InstToolTp	SubPinFillO,$38B		InstToolTp	AddMaxFillO,$38D		InstToolTp	AddMinFillO,$38F		InstToolTp	BlendFillO,$388		InstToolTp	TransFillO,$38C			InstToolTp	AddOverFillR,$368		InstToolTp	SubOverFillR,$36C		InstToolTp	AddPinFillR,$367		InstToolTp	SubPinFillR,$369		InstToolTp	AddMaxFillR,$36B		InstToolTp	AddMinFillR,$36D		InstToolTp	BlendFillR,$366		InstToolTp	TransFillR,$36A			InstToolTp	AddOverUnClip,$352		InstToolTp	SubOverUnClip,$356		InstToolTp	AddPinUnClip,$351		InstToolTp	SubPinUnClip,$353		InstToolTp	AddMaxUnClip,$355		InstToolTp	AddMinUnClip,$357		InstToolTp	BlendUnClip,$350		InstToolTp	TransUnClip,$354	ENDIF		;******************************************************************************************;; to make scoping for upcoming equates happier, we force the end of the previous procedure here;QuickerDraw		PROC		EXPORT				EXPORT		slAddOver8				EXPORT		slSubOver8				EXPORT		slAddPin8				EXPORT		slSubPin8				EXPORT		slMax8				EXPORT		slMin8				EXPORT		slAvg8								EXPORT		rAddOver8				EXPORT		rSubOver8				EXPORT		rAddPin8				EXPORT		rSubPin8				EXPORT		rMax8				EXPORT		rMin8				EXPORT		rAvg8								EXPORT		bAddOver8				EXPORT		bSubOver8				EXPORT		bAddPin8				EXPORT		bSubPin8				EXPORT		bMax8				EXPORT		bMin8				EXPORT		bAvg8								EXPORT		slTransparent8				EXPORT		rTransparent8				EXPORT		bTransparent8	if patchciRom	THEN		; now patch the inner loop traps; so far we handle:Old350		EQU		$2DAD0	; bAvg-- blend fill, unclipped rectsOld351		EQU		$2D450	; bAddPin-- addPin fill, unclipped rectsOld352		EQU		$2D340	; bAddOver-- addOver fill, unclipped rects (and bitmaps)Old353		EQU		$2D6E0	; bSubPin-- subPin fill, unclipped rectsOld354		EQU		$2DE80	; bTransparent-- transparent fill, unclipped rectsOld355		EQU		$2D870	; bMax-- addMax fill, unclipped rectsOld356		EQU		$2D5D0	; bSubOver-- subOver fill, unclipped rectsOld357		EQU		$2D9A0	; bMin-- addMin fill, unclipped rectsOld366		EQU		$2BBB0	; rAvg-- blend fill, clipped rectsOld367		EQU		$2B4C0	; rAddPin-- addPin fill, clipped rectsOld368		EQU		$2B3A0	; rAddOver-- addOver fill, clipped rects  (and bitmaps)Old369		EQU		$2B790	; rSubPin-- subPin fill, clipped rectsOld36A		EQU		$2C060	; rTransparent-- transparent fill, clipped rectsOld36B		EQU		$2B930	; rMax-- addMax fill, clipped rectsOld36C		EQU		$2B660	; rSubOver-- subOver fill, clipped rectsOld36D		EQU		$2BA70	; rMin-- addMin fill, clipped rectsOld388		EQU		$2F670	; slAvg-- blend fill, ovalsOld389		EQU		$2F3E0	; slAddPin-- addPin fill, ovalsOld38A		EQU		$2F330	; slAddOver-- addOver fill, ovalsOld38B		EQU		$2F4E0	; slSubPin-- subPin fill, ovalsOld38C		EQU		$2F790	; slTransparent-- transparent fill, ovalsOld38D		EQU		$2F570	; slMax-- AddMax fill, ovalsOld38E		EQU		$2F470	; slSubOver-- subOver fill, ovalsOld38F		EQU		$2F5F0	; slMin-- AddMin fill, ovalsOld380		EQU		$2F1C4	; slMASK8-- oval/rrect copy mode scan line handlerOld381		EQU		$2F1E6	; slMASK9-- oval/rrect OR mode scan line handlerOld384		EQU		$2F230	; slXMask8-- oval/rrect complex fill, copy mode	ELSEIF 0 THEN	;these are the equates for MacIIOld350		EQU		$1BF24	; bAvg-- blend fill, unclipped rectsOld351		EQU		$1BC6A	; bAddPin-- addPin fill, unclipped rectsOld352		EQU		$1BBF4	; bAddOver-- addOver fill, unclipped rects (and bitmaps)Old353		EQU		$1BD7C	; bSubPin-- subPin fill, unclipped rectsOld354		EQU		$1C0B0	; bTransparent-- transparent fill, unclipped rectsOld355		EQU		$1BE18	; bMax-- addMax fill, unclipped rectsOld356		EQU		$1BD06	; bSubOver-- subOver fill, unclipped rectsOld357		EQU		$1BE9E	; bMin-- addMin fill, unclipped rectsOld366		EQU		$1CF94	; rAvg-- blend fill, clipped rectsOld367		EQU		$1CDE8	; rAddPin-- addPin fill, clipped rectsOld368		EQU		$1CD9C	; rAddOver-- addOver fill, clipped rects  (and bitmaps)Old369		EQU		$1CE88	; rSubPin-- subPin fill, clipped rectsOld36A		EQU		$1D094	; rTransparent-- transparent fill, clipped rectsOld36B		EQU		$1CEDC	; rMax-- addMax fill, clipped rectsOld36C		EQU		$1CE3C	; rSubOver-- subOver fill, clipped rectsOld36D		EQU		$1CF38	; rMin-- addMin fill, clipped rectsOld388		EQU		$1E1BE	; slAvg-- blend fill, ovalsOld389		EQU		$1DF50	; slAddPin-- addPin fill, ovalsOld38A		EQU		$1DEBA	; slAddOver-- addOver fill, ovalsOld38B		EQU		$1E042	; slSubPin-- subPin fill, ovalsOld38C		EQU		$1E2CE	; slTransparent-- transparent fill, ovalsOld38D		EQU		$1E0CE	; slMax-- AddMax fill, ovalsOld38E		EQU		$1DFDA	; slSubOver-- subOver fill, ovalsOld38F		EQU		$1E146	; slMin-- AddMin fill, ovalsOld380		EQU		$1DD7E	; slMASK8-- oval/rrect copy mode scan line handlerOld381		EQU		$1DD9A	; slMASK9-- oval/rrect OR mode scan line handlerOld384		EQU		$1DDCE	; slXMask8-- oval/rrect complex fill, copy mode	ENDIF;----------------------------------------------------;;  A6 OFFSETS OF LOCAL VARIABLES AFTER LINK:;;  STACKFRAME LINKED AND LOCALS INITIALIZED BY STRETCHBITS.;&CurFile	SETC	'STRETCH'						INCLUDE	'DrawingVars.a';******************************************************************************************		;   Arithmetic transfer modes start here...		;******************************************************************************************		; Here's where we implement the arithmetic transfer mode fills for ovals/rrects; Use a common loop for all the transfer modes, with specialized handlers to do the ; pixel arithmetic.; the first receiver is for AddOver mode for ovals and roundRects;>>>>>>>>>>>AddOverFillO	slAddOver8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip		JMPRom	Old38A			; continue in ROM 					<S433>	endif	; OK, first do the pattern setup@0		MOVE.L	A0,A3			;set up pattern base		LEA	AddOverHandler,A0	;use addOverDoArithMode		MOVEM.L	D7/A4-A5,-(SP)		;save work regs				BSR.S	ArithModeHandler	;invoke the handler				MOVEM.L	(SP)+,D7/A4-A5		;restore regs		RTS; here is the general handler for a scan line of arithmetic fillsArithModeHandler		MOVEQ	#0,D6			;init pattern index				MOVE.W	PATROW(A6),D4		;get pattern size in bytes		SUBQ	#4,D4			;is it a simple one?		BLE	ArithSimplePat		;if so, handle faster; sometimes simple patterns come in as 8 byte ones, so check for that		MOVE.W	PATHPOS(A6),D6		;							<SMC 16Aug90>		ASR.W	#3,D6				;turn bits back into bytes	<SMC 16Aug90>		ADD.W	D0,D6				;							<SMC 16Aug90>				SUBQ	#4,D4			;is it 8 long?		BNE.S	ArithComplexPat		;if not, skip; fetch both halves of the pattern and see if they match		MOVE.W	PATHMASK(A6),D4		;get pattern mask		ASR	#3,D4					;turn bit index to byte  index		AND.W	D4,D6				;mask it		MOVE.L	EXPAT(A6),A4		ADD.l	PATVPOS(A6),A4		;compute pattern address				MOVE.L	0(A4,D6),D4		;get source longword		EOR	#4,D6		CMP.L	0(A4,D6),D4		;is it really simple?		BEQ	ArithSimplePat		;if so, go handle		EOR	#4,D6			;restore D6		; set up the pattern variables, since it's a complex patternArithComplexPat		MOVE.L	EXPAT(A6),A3		ADD.l	PATVPOS(A6),A3		;compute pattern addressArithComplex1				MOVE.L	D1,-(SP)		;remember right edge mask				MOVEQ	#0,D1		MOVEQ	#0,D7			;clear for pixCache; set up A0 to point to the proper handler, depending on the width of the inverse table		MOVE.L	A0,A4			;remember handler base				MOVE.W	INVSIZE(A6),D4		;get shift count (3,4,5)		SUBQ	#3,D4		ADD.W	0(A0,D4.W*2),A0		;point to proper handler; init the single pixel cache, where D1 is last source, D7 is last dest, and D0 is last result		MOVEQ	#0,D5		MOVE.L	COLORTABLE(A6),A5		;get color table ptr					MOVE.B	D1,D5		LEA	0(A5,D5.W*8),A4		;point to source color				MOVE.B	D7,D5		LEA	0(A5,D5.W*8),A5		;point to dest color				JSR	(A0)			;map it		MOVE.B	([INVCOLOR,A6],D0.W,6),D0	;look up in inverse table		; test for the single long case		TST.W	D2		BRA 	ArithBot0; here's the main loop for complex patterns, where we process a longword at a time; use a single pixel cache for speed using D0, D1 and D7ArithRight0		AND.L	(SP)+,D3ArithLoop0				MOVE.W	PATHMASK(A6),D4		;get pattern mask		ASR	#3,D4			;turn bit index to byte  index		AND.W	D4,D6			;mask it		MOVE.L	0(A3,D6),D4		;get source longword		ADDQ	#4,D6					MOVE.L	A2,D5			;no clipping?		BEQ.S	@0			;if none, skip				AND.L	(A2)+,D3		;get region/edge mask in D3		BEQ 	ArithMask0@0				MOVE.L	(A1),D5			;get dest longword; map 1st byte		TST.B	D3		BEQ.S	@8			;if mask zero, we can skip; if same as previous, we can short-circuit the mapping		CMP.B	D4,D1			;source the same?		BNE.S	@9			;if not, skip				CMP.B	D5,D7			;dest the same?		BNE.S	@9			;if not, skip		; it's the same, so use it		MOVE.B	D0,D5			;use last result		BRA.S	@8			;skip the mapping; it's different than the last one, so map it@9		MOVE.B	D4,D1				MOVE.L	COLORTABLE(A6),A5			LEA	0(A5,D1.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A5,D7.W*8),A5		;point to dest color				JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table		MOVE.B	D5,D0@8		LSR.L	#8,D3		LSR.L	#8,D4		ROR.L	#8,D5; map 2nd byte		TST.B	D3		BEQ.S	@2			;if mask zero, we can skip; if same as previous, we can short-circuit the mapping		CMP.B	D4,D1			;source the same?		BNE.S	@1			;if not, skip				CMP.B	D5,D7			;dest the same?		BNE.S	@1			;if not, skip		; it's the same, so use it		MOVE.B	D0,D5			;use last result		BRA.S	@2			;skip the mapping; it's different than the last one, so map it@1		MOVE.B	D4,D1		MOVE.L	COLORTABLE(A6),A5			LEA	0(A5,D1.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A5,D7.W*8),A5		;point to dest color				JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table		MOVE.B	D5,D0@2		LSR.L	#8,D3		LSR.L	#8,D4		ROR.L	#8,D5		; map 3rd byte		TST.B	D3		BEQ.S	@4			;if mask zero, we can skip; if same as previous, we can short-circuit the mapping		CMP.B	D4,D1			;source the same?		BNE.S	@3			;if not, skip				CMP.B	D5,D7			;dest the same?		BNE.S	@3			;if not, skip		; it's the same, so use it		MOVE.B	D0,D5			;use last result		BRA.S	@4			;skip the mapping; it's different than the last one, so map it@3		MOVE.B	D4,D1		MOVE.L	COLORTABLE(A6),A5					LEA	0(A5,D1.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A5,D7.W*8),A5		;point to dest color				JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table		MOVE.B	D5,D0@4		LSR.L	#8,D3		LSR.L	#8,D4		ROR.L	#8,D5		; map final byte		TST.B	D3		BEQ.S	@6			;if mask zero, we can skip; if same as previous, we can short-circuit the mapping		CMP.B	D4,D1			;source the same?		BNE.S	@5			;if not, skip				CMP.B	D5,D7			;dest the same?		BNE.S	@5			;if not, skip		; it's the same, so use it		MOVE.B	D0,D5			;use last result		BRA.S	@6			;skip the mapping; it's different than the last one, so map it@5		MOVE.B	D4,D1				MOVE.L	COLORTABLE(A6),A5			LEA	0(A5,D1.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A5,D7.W*8),A5		;point to dest color				JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table		MOVE.B	D5,D0@6		ROR.L	#8,D5		; it's all mapped, so store the result				MOVE.L	D5,(A1)+		;store the destinationArithBotCommon				MOVEQ	#-1,D3			;set up the mask for the middle		SUBQ	#1,D2ArithBot0				BGT 	ArithLoop0		BEQ 	ArithRight0; all done with this scan line		RTS		; handle a region of all zerosArithMask0		ADDQ	#4,A1			;skip over destination		BRA.S	ArithBotCommon		; the pattern is simpler (it fits in a register), so use a separate loop to make things ;faster.  Use a longword cache instead of the single pixel caches.ArithSimplePat		MOVE.L	D1,-(SP)		;save right edge mask				MOVEQ	#0,D7			;clear for pixIndexing							MOVE.L	(A3),D4			;keep pattern in D4		MOVE.L	COLORTABLE(A6),A3		;use A3 for color table ptr; set up A0 to point to the proper handler, depending on the width of the inverse table		MOVE.L	A0,A4			;remember handler base				MOVE.W	INVSIZE(A6),D0		;get shift count (3,4,5)		SUBQ	#3,D0		ADD.W	0(A0,D0.W*2),A0		;point to proper handler; init the longword pattern cache by mapping the four pixels in D4		MOVEQ	#3,D5		MOVE.L	D4,D6			;init lastDest		BRA.S	CacheILoop0		;skip cache check 1st time		; if the next pixel in D4 is the same as the previous (in D7), take a shortcutCacheInitLoop		CMP.B	D4,D7			;does it match?		BNE.S	CacheILoop0		;if not, must do the hard way				MOVE.B	D0,D1			;use last result				ROL.L	#8,D1		ROL.L	#8,D4				DBRA	D5,CacheInitLoop		BRA.S	CacheIDone		; it's not the same, so do it the hard wayCacheILoop0		MOVE.B	D4,D7		LEA	0(A3,D7.W*8),A4		;point to source color		MOVE.L	A4,A5			;source and dest are same				JSR	(A0)			;map next pixel		MOVE.B	([INVCOLOR,A6],D0.W,6),D1	;look up in inverse table		MOVE.L	D1,D0			;remember last result		ROL.L	#8,D1			ROL.L	#8,D4		DBRA	D5,CacheInitLoop; OK, here's the start of the main loop; first, see if there's only one long to doCacheIDone		TST.W	D2		BNE.S 	ArithLoop1		; here's the main loop for simple patterns, where we process a longword at a time; We use a longword cache in D6ArithRight1		AND.L	(SP)+,D3ArithLoop1		MOVE.L	A2,D5			;no clipping?		BEQ.S	@0			;if none, skip				AND.L	(A2)+,D3		;get mask in D4		BEQ 	ArithMask1@0				MOVE.L	(A1),D5			;get dest longword		CMP.L	#-1,D3			;mask all ones?		BNE.S	ArithMapIt1A		;if not, can't use cache				CMP.L	D5,D6			;same as last time?		BNE.S	ArithMapIt1		;if not, skip; the long was the same as last time, so we can skip the mapping.  Better make sure; the mask was the same, too		MOVE.L	D1,D5			;use last result		BRA	ArithStoreIt		;skip the mapping; it was different, so we have to map it the hard wayArithMapIt1		MOVE.L	D5,D6			;remember for next timeArithMapIt1A				TST.B	D3		BEQ.S	@0			;if mask zero, we can skip				MOVE.B	D4,D7		LEA	0(A3,D7.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A3,D7.W*8),A5		;point to dest color				JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table@0		ROR.L	#8,D3		ROR.L	#8,D4		ROR.L	#8,D5; map 2nd byte		TST.B	D3		BEQ.S	@2			;if mask zero, we can skip		MOVE.B	D4,D7		LEA	0(A3,D7.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A3,D7.W*8),A5		;point to dest color					JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table@2		ROR.L	#8,D3		ROR.L	#8,D4		ROR.L	#8,D5		; map 3rd byte		TST.B	D3		BEQ.S	@4			;if mask zero, we can skip; map it		MOVE.B	D4,D7		LEA	0(A3,D7.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A3,D7.W*8),A5		;point to dest color						JSR	(A0)			;map according to Xfer mode			MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table@4		ROR.L	#8,D3		ROR.L	#8,D4		ROR.L	#8,D5		; map final byte		TST.B	D3		BEQ.S	@6			;if mask zero, we can skip; it's different than the last one, so map it		MOVE.B	D4,D7		LEA	0(A3,D7.W*8),A4		;point to source color				MOVE.B	D5,D7		LEA	0(A3,D7.W*8),A5		;point to dest color				JSR	(A0)			;map according to Xfer mode		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table@6		ROR.L	#8,D4		ROR.L	#8,D5		; it's all mapped, so store the resultArithStoreIt			MOVE.L	D5,(A1)+		;store the destination		ADDQ.L	#1,D3			;was mask all ones?		BNE.S	ArithCom1		;if not, skip				MOVE.L	D5,D1			;remember last resultArithCom1				MOVEQ	#-1,D3			;set up the mask for the middle		SUBQ	#1,D2ArithBot1				BGT 	ArithLoop1		BEQ		ArithRight1; all done with this scan line		RTS; handle a region of all zerosArithMask1		ADDQ	#4,A1			;skip over destination		BRA.S	ArithCom1; Here is the handler for the AddOver mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countAddOverHandler		DC.W	AddOver3-AddOverHandler		DC.W	AddOver4-AddOverHandler		DC.W	AddOver5-AddOverHandler	AddOver3				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		;red		ADD.W	(A5)+,D0		LSL.L	#3,D0						MOVE.W	(A4)+,D0		;green		ADD.W	(A5)+,D0		LSL.L	#3,D0						MOVE.W	(A4),D0			;blue		ADD.W	(A5),D0		LSL.L	#3,D0						SWAP	D0			;return inverse table index		RTSAddOver4				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		;red		ADD.W	(A5)+,D0		LSL.L	#4,D0						MOVE.W	(A4)+,D0		;green		ADD.W	(A5)+,D0		LSL.L	#4,D0						MOVE.W	(A4),D0			;blue		ADD.W	(A5),D0		LSL.L	#4,D0						SWAP	D0			;return inverse table index		RTSAddOver5				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		;red		ADD.W	(A5)+,D0		LSL.L	#5,D0						MOVE.W	(A4)+,D0		;green		ADD.W	(A5)+,D0		LSL.L	#5,D0						MOVE.W	(A4),D0			;blue		ADD.W	(A5),D0		LSL.L	#5,D0						SWAP	D0			;return inverse table index		RTS		;*************************************************************************************; Here is the receiver for the SubOver arithmetic fill mode, for ovals and roundRects.; It uses mainly common code with the other oval handlers;>>>>>>>>>>>SubOverFillO	slSubOver8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip			<S433>				JMPRom	Old38E			;						<S433>			endif; OK, first do the pattern setup@0		MOVE.L	A0,A3			;set up pattern base		LEA	SubOverHandler,A0	;use subOver		BRA	DoArithMode		; Here is the handler for the SubOver mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countSubOverHandler		DC.W	SubOver3-SubOverHandler		DC.W	SubOver4-SubOverHandler		DC.W	SubOver5-SubOverHandler	SubOver3				MOVEQ	#0,D0				MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#3,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#3,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#3,D0						SWAP	D0			;return inverse table index		RTSSubOver4				MOVEQ	#0,D0				MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#4,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#4,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#4,D0						SWAP	D0			;return inverse table index		RTSSubOver5				MOVEQ	#0,D0				MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#5,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#5,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		LSL.L	#5,D0						SWAP	D0			;return inverse table index		RTS;*************************************************************************************; Here is the receiver for the AddPin arithmetic fill mode, for ovals and roundRects.; It uses mainly common code with the other oval handlers;>>>>>>>>>>>AddPinFillO	slAddPin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip			<S433>				JMPRom	Old389			;						<S433>	endif; set up handlers and use common code@0		MOVE.L	A0,A3			;set up pattern base		LEA	AddPinHandler,A0	;use addPin		BRA	DoArithMode; Here is the handler for the AddPin mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countAddPinHandler		DC.W	AddPin3-AddPinHandler		DC.W	AddPin4-AddPinHandler		DC.W	AddPin5-AddPinHandler	AddPin3				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		;red		ADD.W	(A5)+,D0		BCS.S	@0				CMP.W	WEIGHT+BLUE(A6),D0		BLS.S	@1@0		MOVE.W	WEIGHT+BLUE(A6),D0@1		LSL.L	#3,D0						MOVE.W	(A4)+,D0		;green		ADD.W	(A5)+,D0		BCS.S	@2				CMP.W	WEIGHT+GREEN(A6),D0		BLS.S	@3@2		MOVE.W	WEIGHT+GREEN(A6),D0@3			LSL.L	#3,D0						MOVE.W	(A4),D0			;blue		ADD.W	(A5),D0		BCS.S	@4				CMP.W	WEIGHT+RED(A6),D0		BLS.S	@5@4		MOVE.W	WEIGHT+RED(A6),D0@5			LSL.L	#3,D0						SWAP	D0			;return inverse table index		RTSAddPin4				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		;red		ADD.W	(A5)+,D0		BCS.S	@0				CMP.W	WEIGHT+BLUE(A6),D0		BLS.S	@1@0		MOVE.W	WEIGHT+BLUE(A6),D0@1		LSL.L	#4,D0						MOVE.W	(A4)+,D0		;green		ADD.W	(A5)+,D0		BCS.S	@2				CMP.W	WEIGHT+GREEN(A6),D0		BLS.S	@3@2		MOVE.W	WEIGHT+GREEN(A6),D0@3			LSL.L	#4,D0						MOVE.W	(A4),D0			;blue		ADD.W	(A5),D0		BCS.S	@4				CMP.W	WEIGHT+RED(A6),D0		BLS.S	@5@4		MOVE.W	WEIGHT+RED(A6),D0@5			LSL.L	#4,D0						SWAP	D0			;return inverse table index		RTSAddPin5				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		;red		ADD.W	(A5)+,D0		BCS.S	@0				CMP.W	WEIGHT+BLUE(A6),D0		BLS.S	@1@0		MOVE.W	WEIGHT+BLUE(A6),D0@1		LSL.L	#5,D0						MOVE.W	(A4)+,D0		;green		ADD.W	(A5)+,D0		BCS.S	@2				CMP.W	WEIGHT+GREEN(A6),D0		BLS.S	@3@2		MOVE.W	WEIGHT+GREEN(A6),D0@3			LSL.L	#5,D0						MOVE.W	(A4),D0			;blue		ADD.W	(A5),D0		BCS.S	@4				CMP.W	WEIGHT+RED(A6),D0		BLS.S	@5@4		MOVE.W	WEIGHT+RED(A6),D0@5			LSL.L	#5,D0						SWAP	D0			;return inverse table index		RTS;*************************************************************************************; Here is the receiver for the SubPin arithmetic fill mode, for ovals and roundRects.; It uses mainly common code with the other oval handlers;>>>>>>>>>>>SubPinFillO	slSubPin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0		;if not, skip			<S433>				JMPRom	Old38B			;						<S433>	endif; set up handlers and use common code@0		MOVE.L	A0,A3			;set up pattern base		LEA	SubPinHandler,A0	;use SubPin		BRA	DoArithMode; Here is the handler for the SubPin mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countSubPinHandler		DC.W	SubPin3-SubPinHandler		DC.W	SubPin4-SubPinHandler		DC.W	SubPin5-SubPinHandler	SubPin3				MOVEQ	#0,D0				MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@0				CMP.W	WEIGHT+BLUE(A6),D0		BCC.S	@1@0		MOVE.W	WEIGHT+BLUE(A6),D0@1		LSL.L	#3,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@2				CMP.W	WEIGHT+GREEN(A6),D0		BCC.S	@3@2		MOVE.W	WEIGHT+GREEN(A6),D0@3			LSL.L	#3,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@4				CMP.W	WEIGHT+RED(A6),D0		BCC.S	@5@4		MOVE.W	WEIGHT+RED(A6),D0@5			LSL.L	#3,D0						SWAP	D0			;return inverse table index		RTSSubPin4				MOVEQ	#0,D0				MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@0				CMP.W	WEIGHT+BLUE(A6),D0		BCC.S	@1@0		MOVE.W	WEIGHT+BLUE(A6),D0@1		LSL.L	#4,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@2				CMP.W	WEIGHT+GREEN(A6),D0		BCC.S	@3@2		MOVE.W	WEIGHT+GREEN(A6),D0@3			LSL.L	#4,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@4				CMP.W	WEIGHT+RED(A6),D0		BCC.S	@5@4		MOVE.W	WEIGHT+RED(A6),D0@5			LSL.L	#4,D0						SWAP	D0			;return inverse table index		RTSSubPin5				MOVEQ	#0,D0				MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@0				CMP.W	WEIGHT+BLUE(A6),D0		BCC.S	@1@0		MOVE.W	WEIGHT+BLUE(A6),D0@1		LSL.L	#5,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@2				CMP.W	WEIGHT+GREEN(A6),D0		BCC.S	@3@2		MOVE.W	WEIGHT+GREEN(A6),D0@3			LSL.L	#5,D0						MOVE.W	(A5)+,D0		;red		SUB.W	(A4)+,D0		BCS.S	@4				CMP.W	WEIGHT+RED(A6),D0		BCC.S	@5@4		MOVE.W	WEIGHT+RED(A6),D0@5			LSL.L	#5,D0						SWAP	D0			;return inverse table index		RTS;*************************************************************************************; Here is the receiver for the AddMax arithmetic fill mode, for ovals and roundRects.; It uses mainly common code with the other oval handlers;>>>>>>>>>>>AddMaxFillOslMax8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip			<S433>		JMPRom	Old38D			;						<S433>			endif; OK, first do the pattern setup@0		MOVE.L	A0,A3			;set up pattern base		LEA	AddMaxHandler,A0	;use AddMax		BRA	DoArithMode		; Here is the handler for the AddMax mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countAddMaxHandler		DC.W	AddMax3-AddMaxHandler		DC.W	AddMax4-AddMaxHandler		DC.W	AddMax5-AddMaxHandler	AddMax3				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@0		MOVE.W	(A5),D0@0		ADDQ	#2,A5		LSL.L	#3,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@1		MOVE.W	(A5),D0@1		ADDQ	#2,A5		LSL.L	#3,D0						MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@2		MOVE.W	(A5),D0@2				ADDQ	#2,A5		LSL.L	#3,D0								SWAP	D0			;return inverse table index		RTSAddMax4				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@0		MOVE.W	(A5),D0@0		ADDQ	#2,A5		LSL.L	#4,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@1		MOVE.W	(A5),D0@1		ADDQ	#2,A5		LSL.L	#4,D0						MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@2		MOVE.W	(A5),D0@2				ADDQ	#2,A5		LSL.L	#4,D0								SWAP	D0			;return inverse table index		RTSAddMax5				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@0		MOVE.W	(A5),D0@0		ADDQ	#2,A5		LSL.L	#5,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@1		MOVE.W	(A5),D0@1		ADDQ	#2,A5		LSL.L	#5,D0						MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BCC.S	@2		MOVE.W	(A5),D0@2				ADDQ	#2,A5		LSL.L	#5,D0								SWAP	D0			;return inverse table index		RTS;*************************************************************************************; Here is the receiver for the AddMin arithmetic fill mode, for ovals and roundRects.; It uses mainly common code with the other oval handlers;>>>>>>>>>>>AddMinFillOslMin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip		<S433>				JMPRom	Old38F			;					<S433>	endif; OK, first do the pattern setup@0		MOVE.L	A0,A3			;set up pattern base		LEA	AddMinHandler,A0	;use addMin		BRA	DoArithMode		; Here is the handler for the AddMin mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countAddMinHandler		DC.W	AddMin3-AddMinHandler		DC.W	AddMin4-AddMinHandler		DC.W	AddMin5-AddMinHandler	AddMin3				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@0		MOVE.W	(A5),D0@0		ADDQ	#2,A5		LSL.L	#3,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@1		MOVE.W	(A5),D0@1		ADDQ	#2,A5		LSL.L	#3,D0						MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@2		MOVE.W	(A5),D0@2				ADDQ	#2,A5		LSL.L	#3,D0								SWAP	D0			;return inverse table index		RTSAddMin4				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@0		MOVE.W	(A5),D0@0		ADDQ	#2,A5		LSL.L	#4,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@1		MOVE.W	(A5),D0@1		ADDQ	#2,A5		LSL.L	#4,D0						MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@2		MOVE.W	(A5),D0@2				ADDQ	#2,A5		LSL.L	#4,D0								SWAP	D0			;return inverse table index		RTSAddMin5				MOVEQ	#0,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@0		MOVE.W	(A5),D0@0		ADDQ	#2,A5		LSL.L	#5,D0				MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@1		MOVE.W	(A5),D0@1		ADDQ	#2,A5		LSL.L	#5,D0					MOVE.W	(A4)+,D0		CMP.W	(A5),D0		BLS.S	@2		MOVE.W	(A5),D0@2				ADDQ	#2,A5		LSL.L	#5,D0								SWAP	D0			;return inverse table index		RTS;*************************************************************************************; Here is the receiver for the blend arithmetic fill mode, for ovals and roundRects.; It uses mainly common code with the other oval handlers;>>>>>>>>>>>BlendFillOslAvg8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip				<S433>		JMPRom	Old388			;							<S433>	endif; OK, first do the pattern setup@0		MOVE.L	A0,A3			;set up pattern base		LEA	BlendHandler,A0		;use blend		BRA	DoArithMode		; Here is the handler for the Blend mode.  A4 points to the source RGBColor, while; A5 points to the destination.  Return the index in D0 (to be looked up in the; inverse table). First there is a case table for using a static shift countBlendHandler		DC.W	Blend3-BlendHandler		DC.W	Blend4-BlendHandler		DC.W	Blend5-BlendHandler	Blend3		MOVEM.L	D1-D3,-(SP)				MOVEQ	#3,D2			;set up shift count		BRA.S	BlendCommonBlend4		MOVEM.L	D1-D3,-(SP)		MOVEQ	#4,D2BlendCommon		MOVEQ	#0,D0			;clear accum reg; do red		MOVE.W	(A4)+,D1		MULU	WEIGHT+BLUE(A6),D1				MOVE.W	(A5)+,D3		MULU	NOTWEIGHT+BLUE(A6),D3				ADD.L	D1,D3		SWAP	D3		MOVE.W	D3,D0		ASL.L	D2,D0; do green		MOVE.W	(A4)+,D1		MULU	WEIGHT+GREEN(A6),D1				MOVE.W	(A5)+,D3		MULU	NOTWEIGHT+GREEN(A6),D3				ADD.L	D1,D3		SWAP	D3		MOVE.W	D3,D0		ASL.L	D2,D0; do blue		MOVE.W	(A4)+,D1		MULU	WEIGHT+RED(A6),D1				MOVE.W	(A5)+,D3		MULU	NOTWEIGHT+RED(A6),D3				ADD.L	D1,D3		SWAP	D3		MOVE.W	D3,D0		ASL.L	D2,D0		SWAP	D0				MOVEM.L	(SP)+,D1-D3		RTSBlend5		MOVEM.L	D1-D3,-(SP)		MOVEQ	#5,D2		BRA.S	BlendCommon				;******************************************************************************************		; Now we start on the arithmetic fills for clipped rectangles.  Use the common; scan line handler for ovals/rrects to save code.; First we handle AddOver mode	if patchciRom THEN	UseOld368		JMPROM	Old368			;						<S433>					endif;>>>>>>>>>>>AddOverFillRrAddOver8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld368		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld368		;if so, skip   			<PB427	 BAL>	endif		LEA	AddOverHandler,A0	;set up the handlerArithFillCommon		MOVE.L	A0,-(SP)		;remember handler address		; set up the registers and invoke the common scan-line handler		MOVE.L	A4,A2			;set up region pointer		ASR	#3,D6			;bit index to byte index		MOVE.L	A5,A1			;set up destinationArithFillLoop				MOVEQ	#-1,D1		MOVEQ	#-1,D3			;edge masks all ones (edges in region)		MOVE.W	BUFSIZE(A6),D2		;set up the count		ADDQ	#4,D2			;make one based			<PB427	 BAL>		LSR.W	#2,D2		SUBQ	#1,D2			;make zero based		<PB427	 BAL>				MOVE.L	(SP),A0			;get handler address; call the appropriate handle, depending on whether the pattern is simple or complex					CMP.W	#8,PATROW(A6)		;is pattern real complex?		BGT.S	@0			;if so, go handle it		TST.B	endSwitch(A6)		;test pattern mode		BMI.S	@0			;treat bitmap as complex				MOVE.L	0(A3,D6),D0		;get left pattern		EOR	#4,D6		CMP.L	0(A3,D6),D0		;left same as right?		BEQ.S	@1			;if so, it's simple		EOR	#4,D6			;restore D6@0				BSR	ArithComplex1		;invoke scan-line handler for complex pats				BRA.S	@2@1		EOR	#4,D6		BSR	ArithSimplePat		; bump pointers to next time, and loop until done@2		MOVE.L	patOffset(A6),D6		;get pattern index		ASR.L	#3,D6			;bit index to byte index		moveq	#0,d0					;patPos should be a long		MOVE.W	patPos(A6),D0				TST.B	endSwitch(A6)		;test pattern mode		BEQ.S	AFPat1			;if zero, handle		BMI.S	AFBitMap1		;if <0, go handle bitmap; handle bumping the pattern pointers		MOVE.L	SRCADDR(A6),A3		;set up pattern pointer		SUB.l	D0,A3		ADD.W	PATROW(A6),D0		AND.W	PATVMASK(A6),D0		MOVE.W	D0,patPos(A6)		ADD.l	D0,A3				BRA.S	AFSetPatPtr; handle second type of patternAFPat1		ADDQ	#1,D0		AND	#15,D0		LEA	([EXPAT,A6],D0.W*4),A3				MOVE.W	D0,patPos(A6)AFSetPatPtr				MOVE.L	A3,SRCADDR(A6)		; bump to the next scan lineArithFillNextLine		MOVE.L	DSTROW(A6),D0		ADD.L	D0,DSTADDR(A6)		MOVE.W	VERT(A6),D0		ADD.W	VBUMP(A6),D0		MOVE.W	D0,VERT(A6)				CMP.W	LASTV(A6),D0		BNE.S	@0; all done, so strip stack and return		MOVE.L	SAVESTK2(A6),A7		RTS; set up registers and loop for the next line@0		MOVE.L	SEEKMASK(A6),A0		JSR	(A0)			;seek new region				MOVE.L	SRCADDR(A6),A3		;set up pattern pointer		MOVE.L	DSTADDR(A6),A1		;set up dest ptr		MOVE.L	RGNADDR(A6),A2		;set up region ptr			BRA	ArithFillLoop; handle bumping the source if it's a bitmapAFBitMap1		MOVE.L	SRCROW(A6),D0		ADD.L	D0,SRCADDR(A6)				BRA.S	ArithFillNextLine		;******************************************************************************************		; Handle SubOver clipped rectangle fill	if patchciRom THEN	UseOld36C		JMPRom	Old36C			;						<PB433>			endif;>>>>>>>>>>>SubOverFillRrSubOver8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld36C		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld36c		;if so, skip   			<PB427	 BAL>	endif		LEA	SubOverHandler,A0	;set up the handler		BRA	ArithFillCommon		;use comon code				;******************************************************************************************		; Handle AddPin clipped rectangle fill	if patchciRom THEN	UseOld367		JMPRom	Old367			;						<PB433>			endif;>>>>>>>>>>>AddPinFillR	rAddPin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld367		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld367		;if so, skip   			<PB427	 BAL>	endif		LEA	AddPinHandler,A0	;set up the handler		BRA	ArithFillCommon		;use comon code				;******************************************************************************************		; Handle SubPin clipped rectangle fill	if patchciRom THEN	UseOld369		JMPRom	Old369			;						<PB433>			endif;>>>>>>>>>>>SubPinFillR	rSubPin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld369		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld369		;if so, skip   			<PB427	 BAL>	endif		LEA	SubPinHandler,A0	;set up the handler		BRA	ArithFillCommon		;use comon code				;******************************************************************************************		; Handle AddMax clipped rectangle fill	if patchciRom THEN	UseOld36B		JMPRom	Old36B			;						<PB433>			endif;>>>>>>>>>>>AddMaxFillR	rMax8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld36B		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld36B		;if so, skip   			<PB427	 BAL>	endif		LEA	AddMaxHandler,A0	;set up the handler		BRA	ArithFillCommon		;use comon code				;******************************************************************************************		; Handle AddMin clipped rectangle fill	if patchciRom THEN	UseOld36D		JMPRom	Old36D			;						<PB433>			endif;>>>>>>>>>>>AddMinFillR	rMin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld36D		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld36D		;if so, skip   			<PB427	 BAL>	endif		LEA	AddMinHandler,A0	;set up the handler		BRA	ArithFillCommon		;use comon code				;******************************************************************************************		; Handle Blend clipped rectangle fill	if patchciRom THEN	UseOld366		JMPRom	Old366			;						<PB433>			endif;>>>>>>>>>>>BlendFillRrAvg8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld366		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld366		;if s0, skip   			<PB427	 BAL>	endif		LEA	BlendHandler,A0		;set up the handler		BRA	ArithFillCommon		;use comon code		;******************************************************************************************		; Now we start on the arithmetic fills for unclipped rectangles.  Use the common; scan line handler for ovals/rrects to save code.; First we handle AddOver mode, unclipped	if patchciRom THEN	UseOld352		JMPRom	Old352			;						<PB433>			endif;>>>>>>>>>>>AddOverUnClip	bAddOver8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld352		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld352		;if so, skip   			<PB427	 BAL>	endif		LEA	AddOverHandler,A0	;set up the handlerArithUCCommon		MOVE.L	A0,-(SP)		;remember handler address		; set up the registers and invoke the common scan-line handler		SUB.L	A2,A2			;no region pointer		ASR	#3,D6			;bit index to byte index		MOVE.L	A4,A3			;set up pattern pointer		MOVE.L	A5,A1			;set up destinationArithUCLoop				MOVE.L	FIRSTMASK(A6),D3		;set up left edge		MOVE.L	LASTMASK(A6),D1		;set up right edge; compute the count from the three pieces: left, mid and right		MOVE.W	LONGCNT(A6),D2		;get left count		BPL.S	@3			;if positive, we're cool				MOVEQ	#0,D2			;only one word		BRA.S	@4@3				ADD.W	MIDCOUNT(A6),D2		;add in the middle		ADD.W	PIXINLONG(A6),D2		;add in the right		ADDQ.W	#2,D2			;add for count bias		LSR.W	#2,D2			;bytes -> longs@4				MOVE.L	(SP),A0			;get handler address; call the appropriate handle, depending on whether the pattern is simple or complex					CMP.W	#8,PATROW(A6)		;is pattern real complex?		BGT.S	@0			;if so, go handle it		TST.B	ENDSWITCH(A6)		;test pattern mode		BMI.S	@0			;if bitmap, it's complex				MOVE.L	0(A3,D6),D0		;get left pattern		EOR	#4,D6		CMP.L	0(A3,D6),D0		;left same as right?		BEQ.S	@1			;if so, it's simple		EOR	#4,D6			;restore D6@0				MOVE.L	A1,-(SP)		BSR	ArithComplex1		;invoke scan-line handler for complex pats				MOVE.L	(SP)+,A1				BRA.S	@2@1		EOR	#4,D6				MOVEM.L	A1/A3,-(SP)			BSR	ArithSimplePat		MOVEM.L	(SP)+,A1/A3		; bump pointers to next time, and loop until done@2		TST.B	ENDSWITCH(A6)		;test pattern mode		BEQ.S	AFUCPat1		;if zero, handle		BMI.S	AFUCBitMap1		;if <0, go handle bitmap; handle bumping the pattern pointers		moveq	#0,d0					;patPos should be a long		MOVE.W	PATPOS(A6),D0		SUB.l	D0,A3		ADD.W	PATROW(A6),D0		AND.W	PATVMASK(A6),D0		MOVE.W	D0,PATPOS(A6)		ADD.l	D0,A3				BRA.S	ArithUCNextLine; handle second type of patternAFUCPat1		MOVE.W	PATPOS(A6),D0		ADDQ	#1,D0		AND	#15,D0		LEA	([EXPAT,A6],D0.W*4),A3				MOVE.W	D0,PATPOS(A6); bump to the next scan lineArithUCNextLine		MOVE.L	PATOFFSET(A6),D6		ASR.L	#3,D6			;bits to bytes		ArithUCNL2		ADD.W	DSTROW+2(A6),A1		;bump destination				SUBQ.W	#1,height(A6)		BNE	ArithUCLoop				ADDQ	#8,SP		RTS; handle unclipped blits source setupAFUCBitMap1		ADD.W	D6,A3		ADD.W	SRCBUMP(A6),A3		;bump to next line <PB448 DBG>		MOVEQ	#0,D6		BRA.S	ArithUCNL2				;******************************************************************************************		; Handle SubOver unclipped rectangle fill	if patchciRom THEN	UseOld356		JMPRom	Old356			;						<PB433>			endif;>>>>>>>>>>>SubOverUnclip	bSubOver8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld356		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld356		;if so, skip   			<PB427	 BAL>	endif		LEA	SubOverHandler,A0	;set up the handler		BRA	ArithUCCommon		;use comon code				;******************************************************************************************		; Handle AddPin unclipped rectangle fill	if patchciRom THEN	UseOld351		JMPRom	Old351			;						<PB433>			endif;>>>>>>>>>>>AddPinUnclipbAddPin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld351		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld351		;if so, skip   			<PB427	 BAL>	endif		LEA	AddPinHandler,A0	;set up the handler		BRA	ArithUCCommon		;use comon code				;******************************************************************************************		; Handle SubPin unclipped rectangle fill	if patchciRom THEN	UseOld353		JMPRom	Old353			;						<PB433>			endif;>>>>>>>>>>>SubPinUnclipbSubPin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld353		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld353		;if so, skip   			<PB427	 BAL>	endif		LEA	SubPinHandler,A0	;set up the handler		BRA	ArithUCCommon		;use comon code				;******************************************************************************************		; Handle AddMax unclipped rectangle fill	if patchciRom THEN	UseOld355		JMPRom	Old355			;						<PB433>			endif;>>>>>>>>>>>AddMaxUnclip	bMax8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld355		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld355		;if so, skip   			<PB427	 BAL>	endif		LEA	AddMaxHandler,A0	;set up the handler		BRA	ArithUCCommon		;use comon code				;******************************************************************************************		; Handle AddMin unclipped rectangle fill	if patchciRom THEN	UseOld357		JMPRom	Old357			;						<PB433>			endif;>>>>>>>>>>>AddMinUnclip	bMin8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld357		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld357		;if so, skip   			<PB427	 BAL>	endif		LEA	AddMinHandler,A0	;set up the handler		BRA	ArithUCCommon		;use comon code		;******************************************************************************************		; Handle Blend unclipped rectangle fill	if patchciRom THEN	UseOld350		JMPRom	Old350			;						<PB433>			endif;>>>>>>>>>>>BlendUnclip	bAvg8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld350		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld350		;if so, skip   			<PB427	 BAL>	endif		LEA	BlendHandler,A0		;set up the handler		BRA	ArithUCCommon		;use comon code		;******************************************************************************************;  Here's where we handle transparent mode.  The basic strategy is to create a mask from;  the pattern (for one and two long patterns) so we don't have to keep examining it;  pixel by pixel.  (If the mask is all ones, fall into the standard fills). 		; the first one is for transparent mode for ovals and roundRects;>>>>>>>>>>>TransFillOslTransparent8	if patchciRom THEN			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BEQ.S	@0				;if not, skip		JMPRom	Old38C			;			endif@0		CMP.W	#4,PATROW(A6)		;is it a simple pattern?		BGT.S	TransComplexPat		;if not, inspect it closer; it's a simple pattern, so make a mask according to the see-through colorTransSimple1		MOVE.L	(A0),D6			;fetch the pattern		MOVEQ	#-1,D4			;mask is initially all ones		MOVE.B	TRANSCOLOR(A6),D5		;get color to compare with				CMP.B	D6,D5		BNE.S	@0				CLR.B	D4@0		ROR.L	#8,D4		ROR.L	#8,D6				CMP.B	D6,D5		BNE.S	@1				CLR.B	D4@1		ROR.L	#8,D4		ROR.L	#8,D6				CMP.B	D6,D5		BNE.S	@2				CLR.B	D4@2		ROR.L	#8,D4		ROR.L	#8,D6				CMP.B	D6,D5		BNE.S	@3				CLR.B	D4@3		ROR.L	#8,D4		ROR.L	#8,D6			; if the mask is all ones, plot it quickly using the standard fill routine		MOVE.L	A2,D0			;if no clipping		BEQ.S	@4			;skip optimization (things not set up)				CMP.L	#-1,D4			;is mask all ones?		bne.s	@4				;no		jmp		([$E00+$380*4])	;yes, use standard pattern fill; OK, mask is in D4, A2 points to the region, pattern in D6 and A1 is the destination.  ; use the straightforward loop, since region optimizations aren't worth it since we; always have to read the destination.@4		TST.W	D2			;only one long?		BNE.S	TransSimpleLoop		;if not, skipTSL0		AND.L	D1,D3			;combine edges for last oneTransSimpleLoop		MOVE.L	A2,D0		BEQ.S	@0				AND.L	(A2)+,D3		;pick up the region mask@0				AND.L	D4,D3			;punch out transparent part				MOVE.L	D6,D0		AND.L	D3,D0				NOT.L	D3		AND.L	(A1),D3		OR.L	D0,D3		MOVE.L	D3,(A1)+				MOVEQ	#-1,D3				SUBQ.W	#1,D2			;decrement counter		BGT.S	TransSimpleLoop		;loop until done		BEQ.S	TSL0				RTS; see if the complex pattern is really a simple one, if so, we can speed things upTransComplexPat		MOVE.W	PATHPOS(A6),D6		;							<SMC 16Aug90>		ASR.W	#3,D6				;turn bits back into bytes	<SMC 16Aug90>		ADD.W	D0,D6				;							<SMC 16Aug90>				MOVE.W	PATHMASK(A6),D4		;get pattern mask		ASR	#3,D4			;turn bit index to byte  index		AND.W	D4,D6			;mask it		MOVE.L	EXPAT(A6),A3		ADD.l	PATVPOS(A6),A3		;compute pattern address		CMP.W	#8,PATROW(A6)		;is it a double pattern?		BGT.S	TransComplex1		;if not, must be complex				MOVE.L	0(A3,D6),D4		;get source longword		EOR	#4,D6		CMP.L	0(A3,D6),D4		;is it really simple?		BEQ	TransSimple1		;if so, go handle		EOR	#4,D6			;restore D6TransComplex1		MOVE.L	D7,-(SP)		MOVE.L	TRANSCOLOR(A6),D5		;get color to compare with				TST.W	D2		BNE.S	TCPatLoop		; it's complex, so plot it ourselves.  First fetch the pattern.TCPLoop0		AND.L	D1,D3TCPatLoop		MOVE.W	PATHMASK(A6),D4		;get pattern mask		ASR	#3,D4			;turn bit index to byte  index		AND.W	D4,D6			;mask it		MOVE.L	0(A3,D6),D7		;get source longword		ADDQ	#4,D6			CMP.L	D7,D5			;all transparent?		BEQ.S	TCPSkip		; now create a mask for it		MOVEQ	#-1,D4			;mask is initially all ones				CMP.B	D7,D5		BNE.S	@0				CLR.B	D4@0		ROR.L	#8,D4		ROR.L	#8,D7				CMP.B	D7,D5		BNE.S	@1				CLR.B	D4@1		ROR.L	#8,D4		ROR.L	#8,D7				CMP.B	D7,D5		BNE.S	@2				CLR.B	D4@2		ROR.L	#8,D4		ROR.L	#8,D7				CMP.B	D7,D5		BNE.S	@3				CLR.B	D4@3		ROR.L	#8,D4		ROR.L	#8,D7			; now we can finally plot it		MOVE.L	A2,D0		BEQ.S	@8				AND.L	(A2)+,D3		;pick up the region mask@8				AND.L	D4,D3			;punch out transparent part				MOVE.L	D7,D0		AND.L	D3,D0				NOT.L	D3		AND.L	(A1),D3		OR.L	D0,D3		MOVE.L	D3,(A1)+		; loop until doneNextTCP				MOVEQ	#-1,D3				SUBQ.W	#1,D2			;decrement counter		BGT.S	TCPatLoop		;loop until done		BEQ.S	TCPLoop0				MOVE.L	(SP)+,D7		RTSTCPSkip		MOVE.L	A2,D0		BEQ.S	@0				ADDQ.L	#4,A2@0				ADDQ	#4,A1				BRA.S	NextTCP		;******************************************************************************************; Here's where we handle the clipped transparent mode rectangle fill		;	if patchciRom THEN				;<SMC 08OCT90> <5>	if 0 THEN						;<SMC 08OCT90> <5>	UseOld36A		JMPRom	Old36A			;						<PB433>			endif;>>>>>>>>>>>TransFillRrTransparent8;	if patchciRom THEN				;<SMC 08OCT90> <5>	if 0 THEN						;<SMC 08OCT90> <5>			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld36A		;if not, skip		tst.l	d3				;right to left? 		<PB427	 BAL>		bmi.s	UseOld36A		;if s0, skip   			<PB427	 BAL>			endif; set up the registers and invoke the common scan-line handler		MOVE.L	A4,A2			;set up region pointer		ASR	#3,D6			;bit index to byte index		MOVE.L	A5,A1			;set up destinationTransFillLoop				MOVEQ	#-1,D1		MOVEQ	#-1,D3			;edge masks all ones (edges in region)		MOVE.W	BUFSIZE(A6),D2		;set up the count		ADDQ	#4,D2			;make one based			<PB427	 BAL>		LSR.W	#2,D2		SUBQ	#1,D2			;make zero based		<PB427	 BAL>		; call the appropriate handle, depending on whether the pattern is simple or complex					CMP.W	#8,PATROW(A6)		;is pattern real complex?		BGT.S	@0			;if so, go handle it		TST.B	endSwitch(A6)		;test pattern mode		BMI.S	@0			;treat bitmap as complex				MOVE.L	0(A3,D6),D0		;get left pattern		EOR	#4,D6		CMP.L	0(A3,D6),D0		;left same as right?		BEQ.S	@1			;if so, it's simple		EOR	#4,D6			;restore D6@0				BSR	TransComplex1		;invoke scan-line handler for complex pats				BRA.S	@2@1		EOR	#4,D6		MOVE.L	A3,A0		BSR	TransSimple1		; bump pointers to next time, and loop until done@2		moveq	#0,d0					;patPos should be a long		MOVE.W	patPos(A6),D0				TST.B	endSwitch(A6)		;test pattern mode		BEQ.S	TransPat1		;if zero, handle		BMI.S	TransBitMap1	;if <0, go handle bitmap		MOVE.L	patOffset(A6),D6		;get pattern index		ASR.L	#3,D6			;bit index to byte index; handle bumping the pattern pointers		MOVE.L	SRCADDR(A6),A3		;set up pattern pointer		SUB.l	D0,A3		ADD.W	PATROW(A6),D0		AND.W	PATVMASK(A6),D0		MOVE.W	D0,patPos(A6)		ADD.l	D0,A3				BRA.S	TransSetPatPtr; handle second type of patternTransPat1		MOVE.L	patOffset(A6),D6		;get pattern index		ASR.L	#3,D6			;bit index to byte index		ADDQ	#1,D0		AND	#15,D0		LEA	([EXPAT,A6],D0.W*4),A3				MOVE.W	D0,patPos(A6)TransSetPatPtr				MOVE.L	A3,SRCADDR(A6)		; bump to the next scan lineTransFillNextLine		MOVE.L	DSTROW(A6),D0		ADD.L	D0,DSTADDR(A6)		MOVE.W	VERT(A6),D0		ADD.W	VBUMP(A6),D0		MOVE.W	D0,VERT(A6)				CMP.W	LASTV(A6),D0		BNE.S	@0; all done, so strip stack and return		MOVE.L	SAVESTK2(A6),A7		RTS; set up registers and loop for the next line@0		MOVE.L	SEEKMASK(A6),A0		JSR	(A0)			;seek new region				MOVE.L	SRCADDR(A6),A3		;set up pattern pointer		MOVE.L	DSTADDR(A6),A1		;set up dest ptr		MOVE.L	RGNADDR(A6),A2		;set up region ptr			BRA	TransFillLoop; handle bumping the source if it's a bitmapTransBitMap1		MOVE.L	SRCROW(A6),D0									;<PB427	 BAL>		ADD.L	D0,SRCADDR(A6)				MOVE.l	patOffset(A6),D6			asr.l	#3,d6				;make byte offset <PB427	 BAL>		BRA.S	TransFillNextLine		;******************************************************************************************				;	if patchciRom THEN				;<SMC 08OCT90> <5>	if 0 THEN						;<SMC 08OCT90> <5>	UseOld354		JMPRom	Old354			;						<PB433>			endif		;>>>>>>>>>>>TransUnClip	bTransparent8;	if patchciRom THEN				;<SMC 08OCT90> <5>	if 0 THEN						;<SMC 08OCT90> <5>			CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?		BNE.S	UseOld354		;if not, skip		tst.l	(sp)			;right to left? 		<PB427	 BAL>		bmi.s	UseOld354		;if so, skip   			<PB427	 BAL>			endif		; set up the registers and invoke the common scan-line handler		SUB.L	A2,A2			;no region pointer		ASR	#3,D6			;bit index to byte index		MOVE.L	A4,A3			;set up pattern pointer		MOVE.L	A5,A1			;set up destinationTransUCLoop				MOVE.L	FIRSTMASK(A6),D3		;set up left edge		MOVE.L	LASTMASK(A6),D1		;set up right edge; compute the count from the three pieces: left, mid and right		MOVE.W	LONGCNT(A6),D2		;get left count		BPL.S	@3			;if positive, we're cool				MOVEQ	#0,D2			;only one word		BRA.S	@4@3		ADD.W	MIDCOUNT(A6),D2		;add in the middle		ADD.W	PIXINLONG(A6),D2		;add in the right		ADDQ.W	#2,D2			;add for count bias		LSR.W	#2,D2			;bytes -> longs; call the appropriate handle, depending on whether the pattern is simple or complex		@4			CMP.W	#8,PATROW(A6)		;is pattern real complex?		BGT.S	@0			;if so, go handle it		TST.B	ENDSWITCH(A6)		;test pattern mode		BMI.S	@0			;if bitmap, handle as complex				MOVE.L	0(A3,D6),D0		;get left pattern		EOR	#4,D6		CMP.L	0(A3,D6),D0		;left same as right?		BEQ.S	@1			;if so, it's simple		EOR	#4,D6			;restore D6@0				MOVE.L	A1,-(SP)		BSR	TransComplex1		;invoke scan-line handler for complex pats				MOVE.L	(SP)+,A1				BRA.S	@2@1		EOR	#4,D6				MOVEM.L	A1/A3,-(SP)			MOVE.L	A3,A0		BSR	TransSimple1		MOVEM.L	(SP)+,A1/A3		; bump pointers to next time, and loop until done@2		TST.B	ENDSWITCH(A6)		;test pattern mode		BEQ.S	TransUCPat1		;if zero, handle		BMI.S	TransUCBitMap1		;if <0, go handle bitmap; handle bumping the pattern pointers		moveq	#0,d0					;patPos should be a long		MOVE.W	PATPOS(A6),D0		SUB.l	D0,A3		ADD.W	PATROW(A6),D0		AND.W	PATVMASK(A6),D0		MOVE.W	D0,PATPOS(A6)		ADD.l	D0,A3				BRA.S	TransUCNextLine; handle second type of patternTransUCPat1		MOVE.W	PATPOS(A6),D0		ADDQ	#1,D0		AND	#15,D0		LEA	([EXPAT,A6],D0.W*4),A3				MOVE.W	D0,PATPOS(A6); bump to the next scan lineTransUCNextLine		MOVE.L	PATOFFSET(A6),D6		ASR.L	#3,D6			;bits to bytes		TransUCNL2		ADD.W	DSTROW+2(A6),A1		;bump destination				SUBQ.W	#1,height(A6)		BNE	TransUCLoop				ADDQ	#4,SP		RTS; handle unclipped blits source setupTransUCBitMap1		ADD.W	D6,A3		ADD.W	SRCBUMP(A6),A3		;bump to next line <PB448 DBG>		MOVEQ	#0,D6		BRA.S	TransUCNL2		;******************************************************************************************;   End of arithmetic transfer modes!		;******************************************************************************************							ENDPROC