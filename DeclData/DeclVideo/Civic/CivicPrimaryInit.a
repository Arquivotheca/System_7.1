;
;	File:		CivicPrimaryInit.a
;
;	Written by:	Mike Puckett, Fernando Urbina, March 1, 1992.
;
;	Copyright:	© 1992-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	  <SM16>	 8/12/93	BG		Changed various Cyclone-related boxflags to their official
;									names.
;	  <SM15>	08-03-93	jmp		Changed the reference names of the multiscan display constants
;									to their new names.
;	  <SM14>	 6/14/93	kc		Roll in Ludwig.
;	  <LW12>	  6/4/93	fau		Fixed bug# 1089553:  Verify that the Last_Config is part of the
;									family mode of the Default_Config.  Fixed typo when setting the
;									MMC_CLock when booting off composite.
;	  <LW11>	 5/14/93	fau		Adding the PUMA support: Determine if clock chip is a PUMA or a
;									Clifton.
;	  <LW10>	 4/29/93	fau		#1082085:  Used the new bit to the Cyclone slotPRAM flags to
;									indicate whether the "Boot on composite" should be NTSC or PAL.
;	  <SM13>	 4/29/93	fau		Synchronized with Ludwig.
;	   <LW9>	 4/14/93	fau		Changes required for the new way of doing video-in; support for
;									HRMultiSync.  Use new/changed spID's.
;	  <SM12>	  4/5/93	chp		Synchronize with Ludwig.
;	   <LW8>	 3/24/93	fau		Fixed bug #1072989:  When booting up with no monitor connected,
;									I was adjusting the sRsrcNeverMatch to be "non-video in"
;									subtracting $40 from it.  The next time we booted without a
;									monitor, the default_config was loaded, but this was the
;									"adjusted" one, which made us try to boot with an unknown spID.
;									I put in a compare to sRsrcNeverMatch before adjusting the spID.
;	   <LW7>	 3/22/93	fau		Added code to prune the board functional s-resource, depending
;									on the one specified in the Universal info.
;	   <LW6>	 3/21/93	fau		Increased the timing of the Reset pulse to give some extra time
;									for 40MHz systems.
;	   <LW5>	 2/26/93	fau		Removed EVT3 support.
;	   <LW4>	 2/24/93	fau		Fixed a bug where if the Last_CONFIG byte in PRAM had a video-in
;									capable spID, and the video-in bit in VRAM was not set, the
;									hardware would get programmed with the video-in parameters but
;									with the bus size incorrect.  The fix was to force the
;									Last_CONFIG byte to non-video-in if the PRAM bit is clear.
;	   <LW3>	 2/16/93	fau		Added Family mode support for all the video-out equivalent modes
;									for Apple monitors.  Removed support for 704x512 in the 13" RGB
;									Monitor.
;	   <LW2>	  1/4/93	fau		General cleanup:  Removed support for 24-bit mode (MMU).
;									Changed mmcBase... to ymcaBase...  Other sundry stuff.
;	  <SM11>	 12/4/92	fau		Changed to use the new BoxFlag names and got rid of temporary
;									support for Tempest since now we can do the same monitors as
;									with Cyclone.
;	  <SM10>	 12/3/92	fau		Added a Wait5ms routine for Clifton.  Got rid of hardwiring
;									Clifton to 1 Meg;  now I just let the routine size the VRAM.
;	   <SM9>	11/11/92	fau		Added Clifton support all over the place.
;	   <SM7>	 11/2/92	kc		Don't include SonicEqu.a.
;	   <SM6>	10/29/92	fau		Added support for booting off composite video if no monitor is
;									connected and the PRAM bit is set.
;	   <SM5>	10/28/92	SWC		Changed VideoEqu.a->Video.a and ShutdownEqu.a->Shutdown.a.
;	   <SM4>	10/27/92	fau		Wrong sense on a check for Tempest.  (beq instead of bne).
;	   <SM3>	10/27/92	fau		Added support for Tempest.
;	   <SM2>	10/23/92	fau		Changed MMCAddr to DecoderAddr.
;		 <1>	 10/6/92	GDW		New location for ROMLink tool.
;	   <SM9>	 9/30/92	fau		Added a TestFor YMCADecoder to distinguish between 25Mhz and
;									33MHz machines.
;	   <SM8>	 8/27/92	fau		Got rid of all support for early rev's of Civic.  New
;									CivicRegTableII was folded into CivicRegTable and deleted.
;	   <SM7>	 6/26/92	fau		Back to running at 25Mhz.  Added code to make sure sync outputs
;									are enabled.  Added the RGBBypass support for 12" and 13"
;									displays.
;	   <SM6>	 6/20/92	fau		Changed _SPutPRAMRec to _InitSlotPRAM when writing the Board ID.
;	   <SM5>	 6/19/92	KW		(fau,P9) Added GoldFish support for Set/GetRGBBypass (very
;									kludgy -- will go away when we have dynamic desktop).  Getting
;									base address out of s-resource now.  Civic 2 test for the new
;									oscillators -- the MMC_ClockSelect line changed polarity with
;									these new guys.  Got rid of checking for supported monitors for
;									video-in, since we support all monitors now.
;	   <SM4>	 6/18/92	KW		(fau,P8) Added video-in support for Vesuvio, Kong, Rubik, 19"
;									Display and all VGA families for Civic-based CPU's.
;	   <SM3>	  6/4/92	KW		(jmp,P7) Added support for Civic2:  32bpp and Convolution for
;									NTSC/PAL FF/ST.  Also, slightly optimized & improved the
;									soon-to-obsolete Civic vs. Civic2 checking code.  (Note:  PAL
;									convolution doesn’t seem to work, so I just commented it out of
;									the PAL family mode tables, but everything is there for it to be
;									added back in.)
;									(fau,P6) Added a new pCivicIIRegTable that has the extra bit
;									defined for Rowwords and also the DoubleLine register (1 bit)
;									tacked at the end of the table.  Modified pGetCivicReg in a
;									brute force manner to check which Civic it's running on and load
;									the appropriate table.
;									(fau,P5) Added video-in support for NTSC and PAL monitors
;									(Full-frame and Safe-title) for Civic-based CPU's.
;	   <SM2>	 5/29/92	kc		Fix Assembler warnings.
;		<P4>	  5/1/92	fau		Added video-in entries to the CivicModeList for 16" and 15".
;									Forced code to ignore video-in in monitors other than 13" or
;									16".  Programmed Civic as a 33MHz machine, per Eric Baden's
;									request.
;		<P3>	04/13/92	jmp		Added support for family modes, added support for video-in, and
;									cleaned up the vRAM-sizing routine.
;		<P2>	03/24/92	jmp		Added initial support for Apple-supported progressive-scan and
;									interlaced displays.
;		 <1>	03/04/92	jmp		first checked in

;---------------------------------------------------------------------
;	Header
;---------------------------------------------------------------------
				
				STRING 	C

				PRINT	OFF
				LOAD	'StandardEqu.d'

				INCLUDE 'HardwarePrivateEqu.a'
				INCLUDE 'ROMEqu.a'
				INCLUDE	'Video.a'
				INCLUDE	'SlotMgrEqu.a'
				INCLUDE	'UniversalEqu.a'
				
				INCLUDE	'DepVideoEqu.a'
				PRINT	ON

				MACHINE	MC68020
				SEG		'_sCivicPrimaryInit'
				
LCivicPrimaryInit		MAIN

				Dc.b	sExec2								; Header
				Dc.b	sCPU68020
				Dc.w	0
				Dc.l	BeginCivicInit-*

;---------------------------------------------------------------------
;	Local variables, definitions, etc....
;---------------------------------------------------------------------

					WITH	SEBlock,SPBlock

CivicFrame			Record		{A6Link},Decrement
Return				Ds.l	1								; Return address.
A6Link				Ds.l	1								; Saved A6.
spBlk				Ds		SPBlock							; SpBlock for generic use.
sPRAMBlk			Ds.b	SizeSPRAMRec					; sPRAMRec for generic use.
civicBaseAddr		Ds.l	1								; Pointer to Civic’s base address.
ymcaBaseAddr		Ds.l	1								; Pointer to MMC’s base address.
vRAMBaseAddr		Ds.l	1								; Pointer to base of vRAM.
vidParamsPtr		Ds.l	1								; Pointer to video parameters.
configParamsPtr		Ds.l	1								; Pointer to config parameters.
spFlags				Ds.b	1								; Local copy of slot pRAM flags byte.
boxFlag				Ds.b	1								; The machine's box flag (Cyclone or Tempest)
compOutFlag			Ds.b	1								; Cleared if we're driving composite out
					Ds.b	1								; <pad>
CFSize				Equ		*
					Endr
				
CVRAMConfigRec		Record	0								; 
sRsrcID				Ds.b	1								; sRsrc ID for this vRam configuration.
modeID				Ds.b	1								; Favored modeID (depth).
familiesOffset		Ds.w	1								; Offset to family mode table.
CVRAMConfigSize		Equ		*
					Endr
				
MiniGamma			Record	0								; Entries for mini gamma table used in DAFBInit.
blackRed			Ds.b	1								; Red
whiteRed			Ds.b	1								;
blackGreen			Ds.b	1								; Green
whiteGreen			Ds.b	1								;
blackBlue			Ds.b	1								; Blue
whiteBlue			Ds.b	1								;
					Ds.b	2								; <pad>
GT_Size				Equ		*
					Endr

					WITH	MiniGamma,CVRAMConfigRec
				
CivicConfigRec		Record	0,Increment
gammaTbl			Ds.b	GT_Size							; Mini-gamma table (defined in PrimaryInit.a).
CConfigHdrSize		Equ		*
c1MegVRAM			Ds.b	CVRAMConfigSize					; 1Meg vRAM prefereneces.
c2MegVRAM			Ds.b	CVRAMConfigSize					; 2Meg vRAM prefereneces.
CConfigRecSize		Equ		*
					Endr
				
					ENDWITH

;---------------------------------------------------------------------
;	Utils
;---------------------------------------------------------------------

;---------------------------------------------------------------------
;
;	GetCivicReg
;
;	This routine takes an offset into the CivicRegTable as input and
;		returns the address and width of the corresponding
;		Civic register.
;
;	-> D0:  The offset into the CivicRegTable of the desired Civic register.
;	<- D1:	The width (1 to 12 bits) of the Civic regiser/data.
;	<- A0:	Pointer to base address of the Civic register to write.
;
;	Trashes D0-D1/A0.

				WITH	CivicFrame,CivicEntry,CivicRecord

pGetCivicReg
				Lea		pCivicRegTable,A0					; Point to the CivicRegTable.
				
@GetCWidth		Move.w	width(A0,D0),D1						; Get the register width
				Move.w	offset(A0,D0),D0					; Get the register offset.
				
				Move.l	civicBaseAddr(A6),A0				; Point A0 at Civic’s base address.
				Adda.w	D0,A0								; Point to the desired register.

				Rts
				
				ENDWITH
				
;---------------------------------------------------------------------
;
;	WriteCivic
;
;	Civic registers are accessed 1 bit a time using D[0] of the processor
;		bus.  However, most of the registers are more than 1 bit wide.
;		So, this routine takes as input the base address of the Civic
;		register to write, the data to write out, and how wide the
;		register/data is.
;
;	Note:	Civic Registers are ONLY accessible in 32-bit addressing
;			mode.
;
;	-> D0:  The data to write out.
;	-> D1:	The width (1 to 12 bits) of the Civic regiser/data.
;	-> A0:	Pointer to base address of the Civic register to write.
;
;	Trashes D0-D1/A0.

pWriteCivic		
				Subq	#1,D1							; Set up for Dbra loop.

@WriteABit		Move.l	D0,(A0)+						; Write the current bit out.
				Lsr.l	#1,D0							; Set up for next write.
				Dbra	D1,@WriteABit					; Loop until done.
				
				Rts										; Return home.
				
;---------------------------------------------------------------------
;
;	ReadCivic
;
;	This routine complements the WriteCivic routine.  It takes as
;		input the Civic register to read and how wide the
;		register is.  It returns the register’s value.
;
;	Note:	Civic Registers are ONLY accessible in 32-bit addressing
;			mode.
;
;	<- D0:  The Civic register’s data.
;	-> D1:	The width (1 to 12 bits) of the Civic regiser/data.
;	-> A0:	Pointer to base address of the Civic register to write.
;
;	Trashes D1/A0.

pReadCivic		
				Move.l	D2,-(Sp)							; Save our non-trashable work register.
				
				Move.w	D1,D0								; Copy the register width.
				Lsl.w	#2,D0								; Multiply it by four.
				Adda.w	D0,A0								; Point to the last bit.
				
				Subq	#1,D1								; Set up for Dbra loop.
				Moveq	#0,D0								; Set up return value.

@ReadABit		Lsl.w	#1,D0								; Set up for this read.
				Move.l	-(A0),D2							; Get the current bit.
				Bfins	D2,D0{31,1}							; Save it.
				Dbra	D1,@ReadABit						; Loop until done.

				Move.l	(Sp)+,D2							; Restore our work register.
				Rts											; And return home.
				
;---------------------------------------------------------------------
;
;	PruneList
;
;	Loops thru a table of sRsrcIDs comparing the “keeper” with each
;		of the entries in the table.  Those IDs that don’t match
;		the keeper are pruned.
;
;	->	D0:	sRsrcID of the “keeper”
;	->	A0:	pointer to appropriately filled-out SpBlock
;	->	A1:	pointer to list of sRsrcIDs
;
;	Trashes: D0-D1/A1.
;
				WITH	SpBlock

CPIPruneList
				Move.b	D0,-(Sp)							; Remember the ID of the “keeper.”							
				Move.w	(A1)+,D1							; Get the zero-based counter into D1.

@Repeat			Move.b	(A1)+,D0							; Get an sRsrc ID.
				Cmp.b	(Sp),D0								; If it’s the keeper,
				Beq.s	@Until								;	then don’t prune it.
				Move.b	D0,spID(A0)							; Otherwise, prune it.
				_sDeleteSRTRec
@Until			Dbra	D1,@Repeat							; Loop until done.

				Tst.b	(Sp)+								; Clean up the stack.
				Rts											; Return to caller.
				
				ENDWITH

;---------------------------------------------------------------------
;
;	BuildFamilyList
;
;	Loops thru a table of sRsrcIDs comparing the “keeper” with each
;		of the entries in the table.  Those IDs that don’t match
;		the keeper are inserted back in as disabled.
;
;	->	D0:	sRsrcID of the “keeper”
;	->	A0:	pointer to appropriately filled-out SpBlock
;	->	A1:	pointer to list of sRsrcIDs
;
;	Trashes: D0-D1/A1.
;
				WITH	SpBlock,CivicFrame

CPIBuildFamilyList
				Move.b	D0,-(Sp)							; Remember the ID of the “keeper.”							
				Move.w	(A1)+,D1							; Get the zero-based counter into D1.

@Repeat			Move.b	(A1)+,D0							; Get an sRsrc ID.
@ChkIt			Cmp.b	(Sp),D0								; If it’s the keeper,
				Beq.s	@Until								;	then leave it alone.
				Move.b	D0,spID(A0)							; Otherwise, load that sRsrc ID.
				Clr.l	spsPointer(A0)						; Tell the Slot Manager that it’s in ROM.
				Move.l	#1,spParamData(A0)					; Say that we want it disabled.
				Clr.w	spRefNum(A0)						; Say that there’s no driver yet.
				_InsertSRTRec								; Do it!
@Until			Dbra	D1,@Repeat							; Loop until done.

				Tst.b	(Sp)+							; Clean up the stack.
				Rts										; Return to caller.
				
				ENDWITH

; This subroutine reads the Civic sense lines.  On entry, D6 should contain $03, $05, $06, or $07 to
;	indicate the type of extended sense we’re doing, and the CPU should have been put into 32-bit addressing
;	mode.  On exit, D6 contains the appropriate extended sense code.
;
; Note:	The idea behind the extended-sense-line ($07) algorithm is as follows:  First, drive sense line
;		“a” and read the values of “b” and “c.”  Next, drive sense line “b” and read the values of “a”
;		and “c.”  Finally, drive sense line “c” and read the values of “a” and “b.”  In this way, a
;		six-bit number of the form bc/ac/ab is generated.  The other extended-sense algorithms are
;		identical to that of $07, except one of the three lines doesn’t need to be driven.  For example,
;		with $03, “a” doesn’t need to be driven.  With $05, “b” doesn’t need to be driven, and
;		with $06, “c” doesn’t need to be driven.
;

				WITH	CivicRecord	

DoCivicExtendedSense

				Movem.l	D2-D3,-(Sp)						; Save work registers.
				
				Moveq	#0,D3							; Use D3 to store extended-sense code.
				Moveq	#0,D2							; Use D2 as temp from reads.
				
; Drive a, Read bc
;
				Cmp.b	#indexedSense2P,D6				; If this is not a type-3 extended sense,
				Bne.s	@DriveA							;	then go ahead and drive A.
				Move.b	D6,D2							; Otherwise, write out the assumed value,
				Bra		@EndA							;	and go on.

@DriveA			CivicDriveA								; abc <- 011
				CivicReadSenseLines D2					; abc -> ABC
				Andi.b	#civicAMask,D2					; 0BC
				
@EndA			Move.b	D2,D3							; 00 00 BC
				Lsl.b	#2,D3							; 00 BC 00
				
; Drive b, Read ac
;
				Cmp.b	#indexedSenseRGBFP,D6			; If this is not a type-5 extended sense,
				Bne.s	@DriveB							;	then go ahead and drive B.
				Move.b	D6,D2							; Otherwise, write out the assumed value,
				Bra		@EndB							; 	and go on.

@DriveB			CivicDriveB								; abc <- 101
				CivicReadSenseLines D2					; abc -> ABC
				Andi.b	#civicBMask,D2					; A0C
				
@EndB			Bclr	#civicSenseLineA,D2				; A0C becomes
				Beq.s	@OrIn							;  A0C or
				Bset	#civicSenseLineB,D2				;  A1C
				
@OrIn			Or.b	D2,D3							; 00 BC AC
				Lsl.b	#2,D3							; BC AC 00

; Drive c, Read ab
;
				Cmp.b	#indexedSenseHR,D6				; If this is not a type-6 extened sense,
				Bne.s	@DriveC							;	then go ahead and drive C.
				Move.b	D6,D2							; Otherwise, write out the assumed value,
				Bra		@EndC							;	and go on.

@DriveC			CivicDriveC								; abc -> 110
				CivicReadSenseLines D2					; abc <- ABC
				Andi.b	#civicCMask,D2					; AB0
			
@EndC			Lsr.b	#1,D2							; 0AB
				Or.b	D2,D3							; BC AC AB
				
				Move.b	D3,D6							; Save the extended-sense code.
				Movem.l	(Sp)+,D2-D3						; Restore work registers.
				Rts										; Return to caller.
				
				ENDWITH

;---------------------------------------------------------------------
;
; Wait5ms
;		Entry:	Not Used
;		Exit:	D0 destroyed
;---------------------------------------------------------------------
;
; This loop will wait 5 milliseconds before returning.  It is used for the Clifton clock chip

Wait5ms			Move.l	#(-5)<<16,d0					; outer loop count 500*1ms
@outer			Move.w	TimeDBRA,d0						; inner loop count 1ms
@inner			dbra	d0,@inner						; wait 1ms
				Addq.l	#1,d0							; increment outer loop counter
				Bne.s	@outer							; wait 5*1ms
				rts										; the long wait is over

;---------------------------------------------------------------------								<LW11> #PUMA
;																									<LW11> #PUMA
; IsItPUMA																							<LW11> #PUMA
;		Entry:	A0 (Endeavor Base)																	<LW11> #PUMA
;		Exit:	D0-D2 destroyed																		<LW11> #PUMA
;---------------------------------------------------------------------								<LW11> #PUMA
;																									<LW11> #PUMA
; This routine will try to read the ID register from Clifton or PUMA.  Clifton does not				<LW11> #PUMA
; have one, so it should read all 1's, where PUMA does.  The routine will exit with the				<LW11> #PUMA
; condition code set to 0 if it's a PUMA.															<LW11> #PUMA
															;										<LW11> #PUMA
IsItPUMA													;										<LW11> #PUMA
				move.l	#ControlWordSize-1,D2				; Get the loop counter					<LW11> #PUMA
				move.l	#ReadPUMAID,D1						; Enable MuxRef/Enable PROG Register	<LW11> #PUMA
@LoadID														;										<LW11> #PUMA
				Move.l	#1,D0								; Set up the mask for the bit			<LW11> #PUMA
				And.l	D1,D0								; Transfer the first bit to D0			<LW11> #PUMA
				Move.b	D0,EndeavorM(A0)					; write the bit out to Clifton			<LW11> #PUMA
				lsr.l	#1,D1								; get the next bit						<LW11> #PUMA
				Dbra	D2,@LoadID							; …for the whole word					<LW11> #PUMA
															;										<LW11> #PUMA
				Move.l	#(8-1),D2							; The loop counter						<LW11> #PUMA
				clr.b	D0									; We'll store the ID here				<LW11> #PUMA
@ReadID			Move.b	EndeavorM(A0),D1					; Read a bit							<LW11> #PUMA
				Andi.b	#1,D1								; Mask all but the 0th bit				<LW11> #PUMA
				Or.b	D1,D0								; Or into our save register				<LW11> #PUMA
				ror.b	#1,D0								; And get ready to accept the new bit	<LW11> #PUMA
				Dbra	D2,@ReadID							; …for the whole word					<LW11> #PUMA
															;										<LW11> #PUMA
				cmpi.b	#PUMAVer1Id,D0						; Is it our version 1 ID				<LW11> #PUMA
				rts											; 										<LW11> #PUMA
															;										<LW11> #PUMA
;---------------------------------------------------------------------
;	Main
;---------------------------------------------------------------------

				WITH	SEBlock,SPBlock,CivicFrame,CivicRecord

BeginCivicInit

;
; Set up initial “vendor” status.
;
				Link	A6,#CFSize						; Allocate stack space for locals.
				Move.w	#seSuccess,seStatus(A0)			; Just say that we’re okay.

;
; Perform some generic initializations.

				Clr.b	spBlk.spSlot(A6)				; Built-in video is always Slot $0.
				Clr.b	spBlk.spExtDev(A6)				; Why ask why? Just clear this guy.
				
				Move.l	UnivInfoPtr,A4					; Keep a pointer to ProductInfo.

;
; Initialize the BoardID part of the Slot $0 pRAM if necessary.
;
				WITH	SP_Params,ProductInfo,VideoInfo
				
				Lea		spBlk(A6),A0					; Point A0 at our local SpBlock.
				Lea		sPRAMBlk(A6),A2					; Get a pointer to our local sPRAMBlock.
				Move.l	A2,spResult(A0)					; Put our pointer in the SpBlock.
				_sReadPRAMRec							; Read Slot $0’s pRAM.
				
				Move.l	A4,A3							; Copy the ProductInfo pointer.
				Adda.l	VideoInfoPtr(A3),A3				; Point to the VideoInfo record.

				Move.b	SP_Flags(A2),spFlags(A6)		; Make a local copy of the pRAM flags.
				
				Tst.w	SP_BoardID(A2)					; If the board ID is non-zero,
				Bne.s	@PruneBoardSRsrc					;	then just go on.
				
				Move.b	BoardSRsrcID(A3),spID(A0)		; Get the appropriate board sRsrc ID.
				_sRsrcInfo								; Get the spsPointer.
				
				Move.b	#BoardID,spID(A0)				; Set up to get the correct board ID.
				_sReadWord								; Get it.
				
				Move.w	spResult+2(A0),SP_BoardID(A2)	; Save the board ID into pRAM.
				Move.l	A2,spsPointer(A0)				;
				_InitSlotPRAM							;
				
@PruneBoardSRsrc
				Lea		CivicSpIDTbl,A1					; Point to the table of supported board sRsrcs.
				Move.b	BoardSRsrcID(A3),D0				; Get the sRsrc ID of the keeper into D0.
				Bsr		CPIPruneList					; Call our pruning utility.

				ENDWITH

;
; Here’s where we actually get Civic built-in video going.  This includes setting up the functional
;	sRsrcs, as well as initializing the Civic hardware and getting a stable raster for the
;	type of display connected.
;
; Note:  We do all of the following in 32-bit addressing mode because the Civic registers are
;		 in an address space that is inaccessible in 24-bit mode.  (Previous note applies to the
;		 the time before the ROM was a 32-bit mode only ROM.
;

CivicVideoInit

; Get some useful values up front.
;
				WITH	ProductInfo,DecoderInfo,VideoInfo
				
				Move.l	A4,A3								; Copy the ProductInfo ptr.
				Move.b	ProductKind(A3),boxFlag(A6)			; Save this machine's boxflag
				Adda.l	DecoderInfoPtr(A3),A3				; Point to the base address table.
				Move.l	CivicAddr(A3),civicBaseAddr(A6)		; Save Civic’s base address.
				Move.l	DecoderAddr(A3),ymcaBaseAddr(A6)	; Save MMC/YMCA’s base address.
				
				Move.l	A4,A3								; Copy the ProductInfo ptr.
				Adda.l	VideoInfoPtr(A3),A3					; Point to the VideoInfo record.
				Move.l	VRAMPhysAddr(A3),vRAMBaseAddr(A6)	; Save the base of vRAM.
				
				ENDWITH
				
				Move.l	civicBaseAddr(A6),A0				; Point A0 at Civic’s base address.

; Disable Civic interrupts.
;
				pWrite_Civic #0,#Enable						; Disable Casio (the timing generator).

				pWrite_Civic #0,#VBLEnb						; Disable VBL interrupts.
				
				pWrite_Civic #0,#VDCEnb						; Disable VDC interrupts.
				pWrite_Civic #1,#VDCClk						; Disable VDC clock.
				
; Do initial Civic set up.
;
				Clr.b	compOutFlag(A6)						; Initialize our composite out flag

; We need to program Civic to run at 25/33/40MHz, depending on what type of machine we are running.
;
				cmp.b	#BoxQuadra840AV,boxFlag(A6)			; Are we running on a Cyclone at 40MHz			<SM16>
				Beq.s	@40MHz								; 
				cmp.b	#BoxCyclone33,boxFlag(A6)			; Are we running on a Cyclone at 33MHz
				Beq.s	@33MHz								; yes
				cmp.b	#BoxTempest33,boxFlag(A6)			; Are we running on a Tempest at 33MHz
				Beq.s	@33MHz								; yes
				cmp.b	#BoxCentris660AV,boxFlag(A6)		; Are we running on a Tempest at 25MHz			<SM16>
*				Beq.s	@25MHz								; yes

@25MHz
				pWrite_Civic #1,#SpeedCtl					; Set timing and…
				pWrite_Civic #1,#RefreshCtl					;	…refresh for 25MHz.
				Bra.s	@SetupVidBus						;
				
@40MHz														; For now, 40Mhz timing = 33Mhz timing
@33MHz			
				pWrite_Civic #0,#SpeedCtl					; Set timing and…
				pWrite_Civic #2,#RefreshCtl					;	…refresh for 33MHz

@SetupVidBus
				pWrite_Civic #0,#ConvEnb					; Disable convolution.
				pWrite_Civic #1,#BusSize					; Set up for 64-bit wide bus.
				
				pWrite_Civic #1,#HHLTB						; Disable the test registers.
				pWrite_Civic #1,#HLDB						;	(Why wasn’t this just done
				pWrite_Civic #1,#VLDB						;	 in hardware?)
				pWrite_Civic #1,#VHLTB						;
				
				pWrite_Civic #0,#VInDoubleLine				; Reset the line doubler.
				
; Size the amount of VRAM.  When done, D4 is {0,1}, where 0=1Meg, 1=2Meg.
;
				Moveq	#1,D4								; Set up as though…	
				pWrite_Civic #1,#VRAMSize					; 	…2Megs of vRAM are around.
				
				Move.l	vRamBaseAddr(A6),A0					; Point to the base of vRAM.
				Adda.l	#k2MvRAM-8,A0						; Point to the last 4 bytes of 2Megs.
				
				Move.l	#'Nano',(A0)						; Write something out there.
				Nop											; (This space is non-serial.)
				Move.l	#-1,4(A0)							; Clear those data lines.
				Nop											; (It’s still non-serial.)

				Cmp.l	#'Nano',(A0)						; If there are really 2Megs of vRAM
				Beq.s	@EndSize							;	then we’re done.

				pWrite_Civic #0,#VRAMSize					; Otherwise, set up for 1Meg.
				Subq	#1,D4								;

@EndSize

; Sense the type of display to drive.  When done, D6 contains the indexed code specifying which
;	display type we’re supposed to set up for.
;

				CivicResetSenseLines						; Reset the actual senselines themselves.
				Moveq	#0,D6								; Clear our senseline variable.
				
				CivicReadSenseLines D6						; Read the sense lines.
				
				Cmp.b	#indexedSense2P,D6					; If we got a type-3, then do the
				Beq.s	@Extended2P							;	extended Two-Page stuff.
				
				Cmp.b	#indexedSenseRGBFP,D6				; If we got a type-5, then do the
				Beq.s	@ExtendedRGBFP						;	extended RGB Full-Page stuff.
				
				Cmp.b	#indexedSenseHR,D6					; If we got a type-6, then do the
				Beq.s	@ExtendedHR							;	extended Hi-Res stuff.
				
				Cmp.b	#indexedNoConnect,D6				; If we got a type-7, then do the
				Beq.s	@ExtendedNoConnect					;	extened no-connect stuff.

				Bra		@EndSense							; Otherwise, we already recognize the display.

@Extended2P
@ExtendedRGBFP
				Bra		@EndSense							; We’ll support these later.

; • Check for Extended type-6 (HR)...
;
@ExtendedHR		Bsr		DoCivicExtendedSense				; Do the extended type-6 sense algorithm.
				
				Cmpi.b	#extendedHR,D6						; If there really is only a type-6 display,
				Beq.s	@EndHR								;	then just go on.
				
				Cmpi.b	#extendedHR,D6						; If there isn’t a multiscan-sensed display,
				Bne.s	@EndHR								;	then just go on.
				Move.b	#indexedSenseMSB1,D6				; Otherwise, say it’s a multiscan.
				Bra		@EndSense							; Vamoose.

@EndHR			Move.b	#indexedSenseHR,D6					; Just say we’ve got a type-6 for now.

				With	SP_Params
				
				LEA		sPRAMBlk(A6),A2						; Point to the sPRAM block.
				Move.b	SP_AltSense(A2),D0					; Get the alternate senseID pRam byte.
				Andi.b	#spAltSenseValidMask,D0				; If it is valid, then just pretend that
				Bne.s	@DoMonID							;	the monID monitor is attached.
				Bra		@EndSense							; Otherwise, just let it be a type-6.

@DoMonID		Move.b	SP_AltSense(A2),D6					; Get the no-connect pRam byte.
				Andi.b	#spAltSenseMask,D6					; Strip the validation code.
				Bra		@EndSense

				Endwith

; • Check for Extended type-7 (No Connect)...
;
@ExtendedNoConnect
				Bsr		DoCivicExtendedSense				; Do the extended no-connect algorithm.

				Lea		@XNCTable,A1						; Point to the table of extended no-connect codes.
@XNCLoop		Move.b	(A1)+,D0							; Pick up the next supported extended no-connnect code.
				Bmi.s	@EndNoConnect						; If we’re at the end of the list, then just leave.
				
				Move.b	(A1)+,D1							; Pick up the indexed version of the extended code.

				Cmp.b	D0,D6								; If we didn’t find a match, then
				Bne.s	@XNCLoop							;	just keep looping
				
				Move.b	D1,D6								; Translate the extended code into its indexed version.
				Bra.s	@EndSense

@XNCTable		Dc.b	extendedSensePAL,indexedSensePAL
				Dc.b	extendedSensePALBox,indexedSensePAL
				Dc.b	extendedSenseNTSC,indexedSenseNTSC
				Dc.b	extendedSenseVGA,indexedSenseVGA
				Dc.b	extendedSenseGF,indexedSenseGF
				Dc.b	extendedSense19,indexedSense19
				Dc.b	-1,-1

@EndNoConnect	Move.b	#indexedNoConnect,D6				; We don’t recognize the code, so say nothing’s connected.


; When no monitor that we recognize is connected, we first want to check to see if we’re at the
;	factory.  If we are, then the last 4-bytes of pRAM will contain 'RNIN'. If we aren’t
;	at the factory and we don’t recognize the no-connect code, then we set up to delete
;	all the video data structures and to turn built-in video off.
;
; Actually, we first want to check to see if the spCompOut bit of the PRAM flags is set.  If so,
;   this tells us that we want to drive out the composite out port, even though there is no monitor
;   connected on the DB-15 port

				Move.b	spFlags(A6),D0						; Get our flags
				Btst	#spCompOut,D0						; Do we want to drive out the composite port
				Beq.s	@Factory							; no, check to see if we're at the factory
				Btst	#spCompOutPAL,D0					; Test to see if we should drive PAL				<LW10>
				Beq.s	@DriveNTSC							; Nope, drive NTSC									<LW10>
				Move.b	#indexedSensePAL,D6					; yes, then drive PAL								<LW10>
				bra.s	@JumpOver							; skip over NTSC code								<LW10>
@DriveNTSC		Move.b	#indexedSenseNTSC,D6				; hard code for NTSC.								<LW10>
@JumpOver		Clr.b	D0									; clear all bits									<LW10>
				Bset	#0,D0								; set our bit
				Move.b	D0,compOutFlag(A6)					; Do we want to drive out the composite port
				Bra		@EndSense							
@Factory
				WITH	SP_Params

				Subq	#burnInSiz,Sp						; Get pRAM buffer on stack (4-bytes).
				Move.l	Sp,A0								; Point to it.
				Move.w	#burnInSiz,D0						; Set up parameters
				Swap	D0									;
				Move.w	#burnInLoc,D0						;
				_ReadXPram									; 
				Move.l	(Sp)+,D0							; 
				
				Cmp.l	#burnInSig,D0						; If we are at the factory, then
				Beq.s	@DoHR								;	just pretend an HR is attached.
				Bra.s	@EndSense							; Otherwise, nothing’s connected.
				
@DoHR			Move.b	#indexedSenseHR,D6					; Say an HR display is attached.

@EndSense		
				ENDWITH												

; Pick up the favored configuration based on the amount of vRAM and the type of display sensed or assumed.
;
				WITH	CVRAMConfigRec,CivicConfigRec
@GetConfig				
				Lea		CivicConfigTable,A1					; Point to the Civic configuration table.
				Move.w	#CConfigRecSize,D0					; Get the size of each entry into D0.
				Mulu	D6,D0								; Multiple it by the right entry.
				Adda.l	D0,A1								; Skip to the entry we want.
				Move.l	A1,configParamsPtr(A6)				; Save it for later.
				Adda.w	#CConfigHdrSize,A1					; Skip past the header.
				Move.w	#CVRAMConfigSize,D0					; Get the size of the vRAM entries.
				Mulu	D4,D0								; Multiply by the right entry.
				Adda.l	D0,A1								; Skip to the right vRAM entry.
				
				Move.b	modeID(A1),D7						; Get the default mode (depth).
				Move.b	sRsrcID(A1),D5						; Get the default sRsrcID.
				
				ENDWITH

; Initialize built-in video’s pRAM.
;
@InitPRAM			
				WITH	SP_Params

				Lea		spBlk(A6),A0						; Point to the spBlock.
				Lea		sPRAMBlk(A6),A2						; Point to the sPRAM block.

				Move.b	D6,SP_MonID(A2)						; Remember which monitor we sensed (or assumed).
				
;  The following is new code to verify that the SP_LastConfig spID is actually a valid spID				<LW12>
;  for the sensed display.  What we do is the following:  Get A1 pointing to the family mode			<LW12>
;  list for the particular display/VRAM size.  If there are no families, then just  do  				<LW12>
;  what we used to do.  Otherwise, we walk the family mode table looking for a match.					<LW12>
;  If we find one, we are happy and we do the same thing.  If we don't find one, we invalidate the 		<LW12>
;  SP_DfltConfig spID by writing a 0 to it  (We never really have a 0 spID).							<LW12>
;																										<LW12>
				WITH	CVRAMConfigRec,CivicConfigRec		;											<LW12>
															;											<LW12>
				Move.l	configParamsPtr(A6),A1				; Point to this config’s parameters.		<LW12>
				Adda.w	#CConfigHdrSize,A1					; Skip past the header.						<LW12>
				Move.w	#CVRAMConfigSize,D0					; Get the size of the vRAM entries.			<LW12>
				Mulu	D4,D0								; Multiply by the right entry.				<LW12>
				Adda.l	D0,A1								; Skip to the right vRAM entry.				<LW12>
				Move.w	familiesOffset(A1),D0				; If there are no families,					<LW12>
				Beq.s	@ChkDfltConfig						;	do what we used to do.					<LW12>
															;											<LW12>
				ENDWITH										;											<LW12>
@DoFamily													; Otherwise, make sure we are part of the family.	<LW12>
				Move.l	configParamsPtr(A6),A1				; Point back to this config’s parameters.	<LW12>
				Adda.w	D0,A1								; Point to the table of supported families.	<LW12>
				Move.b	SP_LastConfig(A2),D0				; Get the sRsrcID of the keeper into D0.	<LW12>
				Move.b	D0,-(Sp)							; Remember the ID of the “keeper.”			<LW12>						
				Move.w	(A1)+,D1							; Get the zero-based counter into D1.		<LW12>
															;											<LW12>
@Repeat			Move.b	(A1)+,D0							; Get an sRsrc ID.							<LW12>
@ChkIt			Cmp.b	(Sp),D0								; If it’s the keeper,						<LW12>
				Beq.s	@FoundIt							;	then leave it alone.					<LW12>
				Dbra	D1,@Repeat							; Loop until done.							<LW12>
				Move.b	#0,SP_DfltConfig(A2)				; Make sure we don't compare				<LW12>
@FoundIt													;											<LW12>
				Tst.b	(Sp)+								; Clean up the stack.						<LW12>
@ChkDfltConfig												;											<LW12>

				Cmp.b	SP_DfltConfig(A2),D5				; If this is the same configuration/family we had last time,
				Beq.s	@WritePRAM							;	then just write out the minimal pRAM info.
				
				Move.b	D5,SP_LastConfig(A2)				; Set the identification configuration.
				Move.b	D5,SP_DfltConfig(A2)				; Set the default/family configuration.
				
				Move.b	D7,SP_Depth(A2)						; Set the default depth for this configuration.

@WritePRAM		Move.l	A2,spsPointer(A0)						; Set up the pRAM parameter block.
				_sPutPRAMRec								; Write out Slot $0’s pRAM.
				
				Move.b	SP_LastConfig(A2),D5				; Get the right (family member) sRsrc into D5. 	
				
				
				ENDWITH

; First, prune all of the video sResources except for the selected one.  If there are no families, then we’re done.
;	Otherwise, we re-insert all the members of the selected configuration’s family as disabled.
;
				WITH	CVRAMConfigRec,CivicConfigRec

				Lea		CivicModeList,A1					; Point to the table of supported video sRsrcs.
				Move.b	D5,D0								; Get the sRsrcID of the keeper into D0.
				Bsr.s	CPIPruneList						; Call our pruning utility.
				
				Move.l	configParamsPtr(A6),A1				; Point to this config’s parameters.
				Adda.w	#CConfigHdrSize,A1					; Skip past the header.
				Move.w	#CVRAMConfigSize,D0					; Get the size of the vRAM entries.
				Mulu	D4,D0								; Multiply by the right entry.
				Adda.l	D0,A1								; Skip to the right vRAM entry.
				Move.w	familiesOffset(A1),D0				; If there aren’t any families,
				Beq.s	@EndConfig							;	then just go on.
				
				Move.l	configParamsPtr(A6),A1				; Point back to this config’s parameters.
				Adda.w	D0,A1								; Point to the table of supported families.
				Move.b	D5,D0								; Get the sRsrcID of the keeper into D0.
				Bsr.s	CPIBuildFamilyList					; Call our family-building utility.

@EndConfig				
				ENDWITH
;
; Now that everything is set up, we need to determine whether a known configuration is out there.
;	If so, we continue with the normal PrimaryInit process.  Otherwise, we shut things down and
;	leave.
;
				Cmp.b	#sRsrc_Civic_NeverMatch,D5			; If a known display is connected,
				Bne.s	InitCivicHW							;	then start the ball rolling.
				
				Bra		CivicExit							; Otherwise, just keep built-in video disabled.

; Initialize the video hardware.
;
				WITH	CivicVidParams,MiniGamma
InitCivicHW
				Clr.w	spID(A0)							; Start looking at spID 0, no external devices.
				Clr.b	spTBMask(A0)						; Only look for the board sRsrc.
				Move.w	#catBoard,spCategory(A0)			; Look for:	catBoard,
				Move.w	#typBoard,spCType(A0)				;			typBoard,
				Clr.w	spDrvrSW(A0)						;			0,
				Clr.w	spDrvrHW(A0)						;			0.
				Clr.l	spParamData(A0)						; (The board sRsrc must be enabled.)
				Bset	#foneslot,spParamData+3(A0)			; Limit search to this slot 0.
				_GetTypeSRsrc								; Get the spsPointer.
				
				Move.b	#sVidParmDir,spID(A0)				; Look for the video parameters directory.
				_sFindStruct
				
				Move.b	D5,spID(A0)							; Look in the directory for this config’s params.
				_sGetBlock
				
				Move.l	spResult(A0),A2						; Get a pointer to the vidParams.
				Move.l	A2,vidParamsPtr(A6)					; Save for later disposal.
				
				_sFindDevBase								; Get the base address for this spID
;
; The vpBaseOffset for 1 bpp is always 0, so no need to go look for it

				Move.l	spResult(A0),D3						; Move the base address.
				Lsr.l	#5,D3								; Normalize it for Civic
				Andi.l	#$FF,D3								; Only 8 bits are valid

; Set up to generate a stable raster.
;
				Move.l	civicBaseAddr(A6),A0				; Point to the base of Civic.
				Move.l	#1,Civic_SyncClr(A0)				; Disable Sync outputs.
				
				Btst	#fCivicVidIn,cvpFlags(A2)			; If we can’t do video-in in this configuration,
				Beq.s	@SetupScanCtl						; 	then just go on.
				pWrite_Civic #0,#BusSize					; Otherwise, set up the bus for both video-in & graphics.
				
@SetupScanCtl	
				Move.b	cvpScanCtl(A2),D2					; Pick up the ScanCtl parameter.
				pWrite_Civic D2,#ScanCtl					; Write it out.
				
				Move.b	cvpConvEnb(A2),D2					; Pick up the ConvEnb parameter.
				pWrite_Civic D2,#ConvEnb					; Write it out.

				Move.l	#Endeavor,A0						; Point to the VidClk.

; Now, we need to program the clock chip differently for Cyclone and for Tempest (Tempest really doesn't have an Endeavor)

				Cmp.b	#BoxCentris660AV,boxFlag(A6)		; Do we have a Tempest25								<SM16>
				beq.s	@DoClifton							;	…yes, program Clifton
				Cmp.b	#BoxTempest33,boxFlag(A6)			; Do we have a Tempest33
				beq.s	@DoClifton							;	…yes, program Clifton
				
				Move.b	cvpEndeavorClk(A2),D0				; Get the input clock source.
				Bne.s	@Use17MHz							; If one, use the 17MHz clock.
				Moveq.l	#0,D0								; Set up to select the 14MHz clock.
				Bra.s	@SelClk								;
@Use17MHz		Moveq.l	#-1,D0								; Set up to select the 14MHz clock.
@SelClk			Move.l	ymcaBaseAddr(A6),A1					; Otherwise, get a pointer to MMC.
				Move.l	D0,MMC_ClockSelect(A1)				; Select the desired input clock.

				Clr.b	EndeavorClk(A0)						; Always select Clk A.
				Move.b	cvpEndeavorM(A2),EndeavorM(A0)		; Program M.
				Move.b	cvpEndeavorN(A2),EndeavorN(A0)		; Program N.
				bra.s	@ProgramCivic						; Program the rest of Civic

@DoClifton
				Movea.l	A2,A5								; Save our scratch address								<LW11> #PUMA
				Bsr		IsItPUMA							; Test to see if it's a PUMA ( if CC ≠ 0, then Clifton)	<LW11> #PUMA
				Bne.s	@ItsClifton							; It's a Clifton										<LW11> #PUMA
				Adda.l	#(cvpPumaW-cvpCliftonW),A2			; Adjust our video parameters with the correct offset	<LW11> #PUMA
@ItsClifton													;														<LW11> #PUMA
				Move.b	cvpCliftonClk(A2),D0				; Get the input clock source.
				Bne.s	@Use17MHz2							; If one, use the 17MHz clock.
				Moveq.l	#0,D0								; Set up to select the 14MHz clock.
				Bra.s	@SelClk2							;
@Use17MHz2		Moveq.l	#-1,D0								; Set up to select the 14MHz clock.
@SelClk2		Move.l	ymcaBaseAddr(A6),A1					; Otherwise, get a pointer to MMC.
				Move.l	D0,MMC_ClockSelect(A1)				; Select the desired input clock.

; Writes to Clifton:
; 		D0:  Contains the word written out, with %000000?  (with ? being the bit for Clifton)
; 		D1:  Contains the bits we want to serially write out
;       D2:  Contains the loop counter for all the bits
;
;	Load the Clifton Control register to enable the MUX and the PROGram register

				move.l	#ControlWordSize-1,D2				; Get the loop counter
				move.l	#LoadCliftonControl,D1				; Enable MuxRef/Enable PROG Register
@LoadPROG
				Move.l	#1,D0								; Set up the mask for the bit
				And.l	D1,D0								; Transfer the first bit to D0
				Move.b	D0,EndeavorM(A0)					; write the bit out to Clifton
				lsr.l	#1,D1								; get the next bit
				Dbra	D2,@LoadPROG						; …for the whole word
				
;	Load the Frequency register 

				move.b	cvpCliftonWSize(A2),D2				; Get the size of the W Parameter
				sub.b	#1,D2								; adjust loop # for dbra
				extb.l	D2									; and make byte a long
				move.l	cvpCliftonW(A2),D1					; And the W parameter
@LoadFreq
				Move.l	#1,D0								; Set up the mask for the bit
				And.l	D1,D0								; Transfer the first bit to D0
				Move.b	D0,EndeavorM(A0)					; write the bit out to Clifton
				lsr.l	#1,D1								; get the next bit
				Dbra	D2,@LoadFreq						; …for the whole frequency
				
;	Load the Clifton Control register to keep MUXREF enabled and disable loading of PROG Register

				move.l	#ControlWordSize-1,D2				; Get the loop counter
				move.l	#LoadCliftonProgram,D1				; Enable MuxRef/disable PROG Register
@DisablePROG
				Move.l	#1,D0								; Set up the mask for the bit
				And.l	D1,D0								; Transfer the first bit to D0
				Move.b	D0,EndeavorM(A0)					; write the bit out to Clifton
				lsr.l	#1,D1								; get the next bit
				Dbra	D2,@DisablePROG						; …for the whole word
			
;   Wait for 5 msec to enable the new frequency to get stable

				jsr		Wait5ms								; trashes D0
				
;	Load the Clifton Control register to disable MUXREF and PROGram register.

				move.l	#ControlWordSize-1,D2					; Get the loop counter
				move.l	#LoadCliftonMuxRef,D1				; Disable MUXREF/disable PROG Register
@DisableMUXREF
				Move.l	#1,D0								; Set up the mask for the bit
				And.l	D1,D0								; Transfer the first bit to D0
				Move.b	D0,EndeavorM(A0)					; write the bit out to Clifton
				lsr.l	#1,D1								; get the next bit
				Dbra	D2,@DisableMUXREF						; …for the whole word
				
				Movea.l	A5,A2								; restore our address						<LW11> #PUMA
@ProgramCivic								
				pWrite_Civic cvpVHLine(A2),#VHLine			; Set up the vertical params.
				pWrite_Civic cvpVSync(A2),#VSync			;
				pWrite_Civic cvpVBPEq(A2),#VBPEq			;
				pWrite_Civic cvpVBP(A2),#VBP				;
				pWrite_Civic cvpVAL(A2),#VAL				;
				pWrite_Civic cvpVFP(A2),#VFP				;
				pWrite_Civic cvpVFPEq(A2),#VFPEq			;
				
				pWrite_Civic cvpHSerr(A2),#HSerr			; Set up the horizontal params.
				pWrite_Civic cvpHlfLn(A2),#HlfLn			;
				pWrite_Civic cvpHEq(A2),#HEq				;
				pWrite_Civic cvpHSP(A2),#HSP				;
				pWrite_Civic cvpHBWay(A2),#HBWay			;
				pWrite_Civic cvpHAL(A2),#HAL				;
				pWrite_Civic cvpHFP(A2),#HFP				;
				pWrite_Civic cvpHPix(A2),#HPix				;
				
				pWrite_Civic #$FF0,#VInHal					; For now, set the video-in params…
				pWrite_Civic #$000,#VInHFPD					;	…way into the blanking period.
				pWrite_Civic #$FF8,#VInHFP					;
				pWrite_Civic #$FF0,#VInVal					;
				pWrite_Civic #$FF8,#VInVFP					;
				
				pWrite_Civic cvpGSCDivide(A2),#GSCDivide	; Set up the framebuffer params.
				pWrite_Civic D3,#BaseAddr		;		
				pWrite_Civic cvpRowWords(A2),#RowWords		;
				pWrite_Civic cvpAdjF2(A2),#AdjF1			; Hack alert:  Swapped AdjF1 with AdjF2.
				pWrite_Civic cvpAdjF1(A2),#AdjF2			; (Note:  Other way works in driver!)
				pWrite_Civic cvpPipeD(A2),#PipeD			;
												
; Set up the CLUT/DAC.
; 
				WITH	ProductInfo,DecoderInfo
				
				Move.l	A4,A3								; Copy the ProductInfo ptr.
				Adda.l	DecoderInfoPtr(A3),A3				; Point to the base address table.
				Move.l	SebastianAddr(A3),A0				; Get the base address of the CLUT/DAC.
				
				ENDWITH
				
				Move.l	configParamsPtr(A6),A1				; Point to the config paramters.
				
				Move.w	cvpSebastPCBR(A2),D0				; Get the Sebastian PCBR value.
				Move.b	D0,SebastPCBR(A0)					; Set up the CLUT/DAC for 1bpp.
				Adda.w	#SebastDataReg,A0					; Point to the data register.

				Move.b	#$7F,SebastAddrReg-SebastDataReg(A0) ; Setup to write 1bpp white.
				Move.b	whiteRed(A1),(A0)
				Move.b	whiteGreen(A1),(A0)
				Move.b	whiteBlue(A1),(A0)
				Clr.b	(A0)
				
				Move.b	#$FF,SebastAddrReg-SebastDataReg(A0) ; Setup to write 1bpp black.
				Move.b	blackRed(A1),(A0)
				Move.b	blackGreen(A1),(A0)
				Move.b	blackBlue(A1),(A0)
				Clr.b	(A0)
	
; Paint the vRAM gray.
;
				Move.l	vRAMBaseAddr(A6),A0					; Point to the base of VRAM.
				Move.w	D3,D0								; Get the baseAddress offset.
				Lsl.w	#5,D0								; Normalize it.
				Adda.w	D0,A0								; Point to active video.
				
				Move.w	cvpNumRows(A2),D3					; Get the number of rows to gray.
				Move.l	#OneBitGray,D2						; Set the 1bpp gray pattern.
				
				Move.w	cvpRowWords(A2),D0					; Get the number of longwords/row.
				Tst.b	cvpScanCtl(A2)						; If we’re on an interlaced display
				Bne.s	@Interlace							;	then adjust accordingly.
				Lsl.w	#3,D0								; Normalize for progressive displays.
				Bra.s	@SizeIt								; (Skip interlace here.)
@Interlace		Lsl.w		#2,D0							; Normalize for interlaced displays.
@SizeIt			Subq		#1,D0							; Set up for Dbra loop.

@NxtRow			Move.w	D0,D1								; Get the number of longwords/row.
@NxtLong		Move.l	D2,(A0)+							; Write out gray to the frame buffer…
				Dbra	D1,@NxtLong							; …for each scanline.
				Not.l	D2									; Invert the pattern for the next row.
				Dbra	D3,@NxtRow							; Repeat for each row.
				
; Enable Casio.
;
				pWrite_Civic #0,#Reset						; Reset Casio.
				pWrite_Civic #0,#Reset						; Reset Casio.
				pWrite_Civic #0,#Reset						; Reset Casio.
				pWrite_Civic #0,#Reset						; Reset Casio.
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #0,#Reset						;
				pWrite_Civic #0,#Reset						;
				pWrite_Civic #0,#Reset						;
				pWrite_Civic #0,#Reset						;
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #1,#Reset						;
				pWrite_Civic #1,#Reset						;

				pWrite_Civic #1,#Enable						; Enable Casio.

				ENDWITH

; By-pass composite video-out, thereby enabling RGB.
;
; See if we have to drive out the composite connector
				
				Move.b	compOutFlag(A6),D0					; Get our flag to test
				Btst	#0,D0								; Do we want to drive out the composite port
				Beq.s	@DoDB15								; no, go do the regular DB15 output
				Move.l	ymcaBaseAddr(A6),A0					; MMC Clock Select.
				Move.l	#-1,MMC_Bypass(A0)					; Select the desired input clock, depending if we are			<LW12>
															; going to RGB or to Composite
				Move.l	civicBaseAddr(A6),A0				; Point to the base of Civic.
				Move.l	#1,Civic_SyncClr(A0)				; Disable Sync outputs.
				Bra.s	@FinishUp
@DoDB15
				Move.l	ymcaBaseAddr(A6),A0					; Get a pointer to MMC.
				Clr.l	MMC_Bypass(A0)						; Enable the RGB lines.
				Move.l	civicBaseAddr(A6),A0				; Point to the base of Civic.
				Clr.l	Civic_SyncClr(A0)					; Enable Sync outputs.

@FinishUp

; Dispose of vidParams and restore addressing mode…
;
				Move.l	vidParamsPtr(A6),A0					; Dispose of the video params block.
				_DisposPtr

CivicExit
				Unlk	A6									; Restore the stack.
				Rts											; Return home.
				
				ENDWITH

;---------------------------------------------------------------------
;	Data
;---------------------------------------------------------------------

				Align	4

; The CivicSpIDTbl is a list of all the board sRsrcIDs supported in the Civic
;	sRsrc directory.  It is used to prune all the unnecessary board sRsrc.
;

CivicSpIDTbl	Dc.w	EndCivicSpIDTbl-BeginCivicSpIDTbl-1
BeginCivicSpIDTbl
				Dc.b	sRsrc_BdCyclone
				Dc.b	sRsrc_BdTempest
EndCivicSpIDTbl

				Align	4
				
; Civic has a 1-bit wide interface, but many of its registers logically consist of up to 12-bits.
;	The following table is the instantiation of the CivicRecord defined in DepVideoEqu.a.  Each entry
;	consists of two fields.  The first field is the offset (from the Civic base address) to
;	the least significant bit (long-word aligned) of a particular Civic register.  The second
;	field is the logical size of the Civic register.  This table is used by the GetCivicRegister
;	routine defined above.  Eventually, this table should probably be moved into a Slot Resource
;	for better updating between the PrimaryInit and driver code that must use it.
;

pCivicRegTable	
				Dc.w	$000,01,$004,01,$008,01,$00C,01,$010,01,$014,01,$018,01,$01C,01,$020,03
				Dc.w	$02C,01,$040,01,$044,02,$04C,01,$050,01,$054,01,$058,01,$05C,01,$060,01
				Dc.w	$064,01,$068,01,$06C,01,$080,03,$08C,08,$0C0,09,$100,01,$104,01,$108,01
				Dc.w	$10C,01,$110,01,$114,01,$118,01,$11C,01,$120,01,$124,01,$128,01,$12C,01
				Dc.w	$140,12,$180,12,$1C0,12,$200,02,$240,12,$280,12,$2C0,08,$300,12,$340,12
				Dc.w	$380,12,$3C0,12,$400,12,$440,10,$480,12,$4C0,12,$500,12,$540,12,$580,12
				Dc.w	$5C0,12,$600,12,$640,12,$680,12,$6C0,12,$208,1

				Align	4
				
; The CivicModeList is a list of all the functional video sRsrcs.  It is used to prune all but
;	the selected video sRsrc.
;

CivicModeList	Dc.w	EndCivicML-BeginCivicML-1 
BeginCivicML
				Dc.b	sRsrc_Vid_Civic_NTSCFFConva,sRsrc_Vid_Civic_NTSCSTConv
				Dc.b	sRsrc_Vid_Civic_PALFFConva,sRsrc_Vid_Civic_PALSTConva
				
				Dc.b	sRsrc_Vid_Civic_vi2PRGBa,sRsrc_Vid_Civic_vi2PRGBb
				Dc.b	sRsrc_Vid_Civic_vi2PRGB512,sRsrc_Vid_Civic_vi2PRGB640a
				Dc.b	sRsrc_Vid_Civic_vi2PRGB768a
				Dc.b	sRsrc_Vid_Civic_viFPa,sRsrc_Vid_Civic_viFPb
				Dc.b	sRsrc_Vid_Civic_viFP512,sRsrc_Vid_Civic_viFP640
				Dc.b	sRsrc_Vid_Civic_viGS,sRsrc_Vid_Civic_viGS560
				Dc.b	sRsrc_Vid_Civic_vi2Pa,sRsrc_Vid_Civic_vi2Pb
				Dc.b	sRsrc_Vid_Civic_vi2P512,sRsrc_Vid_Civic_vi2P640,sRsrc_Vid_Civic_vi2P768
				Dc.b	sRsrc_Vid_Civic_viNTSCFFa,sRsrc_Vid_Civic_viNTSCFFb,sRsrc_Vid_Civic_viNTSCST
				Dc.b	sRsrc_Vid_Civic_viFPRGBa,sRsrc_Vid_Civic_viFPRGBb
				Dc.b	sRsrc_Vid_Civic_viHRa,sRsrc_Vid_Civic_viHRb,sRsrc_Vid_Civic_viHRNTSCST,sRsrc_Vid_Civic_viHR400
				Dc.b	sRsrc_Vid_Civic_viPALFFa,sRsrc_Vid_Civic_viPALFFb,sRsrc_Vid_Civic_viPALSTa,sRsrc_Vid_Civic_viPALSTb
				Dc.b	sRsrc_Vid_Civic_viVGAa,sRsrc_Vid_Civic_viVGAb
				Dc.b	sRsrc_Vid_Civic_viSVGA56a,sRsrc_Vid_Civic_viSVGA56b
				Dc.b	sRsrc_Vid_Civic_viSVGA72a,sRsrc_Vid_Civic_viSVGA72b
				Dc.b	sRsrc_Vid_Civic_viSxVGA60a,sRsrc_Vid_Civic_viSxVGA60b
				Dc.b	sRsrc_Vid_Civic_viSxVGA70a,sRsrc_Vid_Civic_viSxVGA70b
				Dc.b	sRsrc_Vid_Civic_viGFa,sRsrc_Vid_Civic_viGFb
				Dc.b	sRsrc_Vid_Civic_viGFNTSCST,sRsrc_Vid_Civic_viGFNTSCFFa,sRsrc_Vid_Civic_viGFNTSCFFb
				Dc.b	sRsrc_Vid_Civic_viGFPALFFa,sRsrc_Vid_Civic_viGFPALFFb
				Dc.b	sRsrc_Vid_Civic_vi19a,sRsrc_Vid_Civic_vi19b

EndCivicML
				
				Align	4

CVesuvioFamTbla	Dc.w	EndCVesuvioMLa-BeginCVesuvioMLa-1	
BeginCVesuvioMLa
					Dc.b	sRsrc_Vid_Civic_vi2PRGBa,sRsrc_Vid_Civic_vi2PRGB512
					Dc.b	sRsrc_Vid_Civic_vi2PRGB640a,sRsrc_Vid_Civic_vi2PRGB768a
EndCVesuvioMLa

CVesuvioFamTblb	Dc.w	EndCVesuvioMLb-BeginCVesuvioMLb-1	
BeginCVesuvioMLb
					Dc.b	sRsrc_Vid_Civic_vi2PRGBb,sRsrc_Vid_Civic_vi2PRGB512
					Dc.b	sRsrc_Vid_Civic_vi2PRGB640a,sRsrc_Vid_Civic_vi2PRGB768a
EndCVesuvioMLb

CFullPageFamTbla	Dc.w	EndCFullPageMLa-BeginCFullPageMLa-1	 -1		; -1 for assembler warning
BeginCFullPageMLa
					Dc.b	sRsrc_Vid_Civic_viFPa,sRsrc_Vid_Civic_viFP512,sRsrc_Vid_Civic_viFP640
					Ds.b	1	; padding for assembler warning
EndCFullPageMLa

CFullPageFamTblb	Dc.w	EndCFullPageMLb-BeginCFullPageMLb-1	 -1		; -1 for assembler warning
BeginCFullPageMLb
					Dc.b	sRsrc_Vid_Civic_viFPb,sRsrc_Vid_Civic_viFP512,sRsrc_Vid_Civic_viFP640
					Ds.b	1	; padding for assembler warning
EndCFullPageMLb

C2PageFamTbla	Dc.w	EndC2PageMLa-BeginC2PageMLa-1	
BeginC2PageMLa
				Dc.b	sRsrc_Vid_Civic_vi2Pa,sRsrc_Vid_Civic_vi2P512,sRsrc_Vid_Civic_vi2P640,sRsrc_Vid_Civic_vi2P768
EndC2PageMLa

C2PageFamTblb	Dc.w	EndC2PageMLb-BeginC2PageMLb-1	
BeginC2PageMLb
				Dc.b	sRsrc_Vid_Civic_vi2Pb,sRsrc_Vid_Civic_vi2P512,sRsrc_Vid_Civic_vi2P640,sRsrc_Vid_Civic_vi2P768
EndC2PageMLb

CRubikFamTbl	Dc.w	EndCRubikML-BeginCRubikML-1	
BeginCRubikML
				Dc.b	sRsrc_Vid_Civic_viGS,sRsrc_Vid_Civic_viGS560
EndCRubikML

CHiResFamTbla	Dc.w	EndCHiResMLa-BeginCHiResMLa-1-1 ; -1 for assember warning pad
BeginCHiResMLa
				Dc.b	sRsrc_Vid_Civic_viHRa,sRsrc_Vid_Civic_viHRNTSCST,sRsrc_Vid_Civic_viHR400
				Ds.b	1 ; assember warning pad
EndCHiResMLa

CHiResFamTblb	Dc.w	EndCHiResMLb-BeginCHiResMLb-1-1 ; -1 for assember warning pad
BeginCHiResMLb
				Dc.b	sRsrc_Vid_Civic_viHRb,sRsrc_Vid_Civic_viHRNTSCST,sRsrc_Vid_Civic_viHR400
				Ds.b	1 ; assember warning pad
EndCHiResMLb

CVGAFamTbla		Dc.w	EndCVGAMLa-BeginCVGAMLa-1-1 ; -1 for assember warning pad
BeginCVGAMLa
				Dc.b	sRsrc_Vid_Civic_viVGAa,sRsrc_Vid_Civic_viSVGA56a,sRsrc_Vid_Civic_viSVGA72a
				Dc.b	sRsrc_Vid_Civic_viSxVGA60a,sRsrc_Vid_Civic_viSxVGA70a
				Ds.b	1 ; assember warning pad
EndCVGAMLa

CVGAFamTblb		Dc.w	EndCVGAMLb-BeginCVGAMLb-1-1 ; -1 for assember warning pad
BeginCVGAMLb
				Dc.b	sRsrc_Vid_Civic_viVGAb,sRsrc_Vid_Civic_viSVGA56b,sRsrc_Vid_Civic_viSVGA72b	
				Dc.b	sRsrc_Vid_Civic_viSxVGA60b,sRsrc_Vid_Civic_viSxVGA70b
				Ds.b	1 ; assember warning pad

EndCVGAMLb

CNTSCFamTbla	Dc.w	EndCNTSCFamMLa-BeginCNTSCMLa-1
BeginCNTSCMLa
				Dc.b	sRsrc_Vid_Civic_viNTSCFFa,sRsrc_Vid_Civic_viNTSCST
				Dc.b	sRsrc_Vid_Civic_NTSCFFConva,sRsrc_Vid_Civic_NTSCSTConv
EndCNTSCFamMLa

CNTSCFamTblb	Dc.w	EndCNTSCFamMLb-BeginCNTSCMLb-1
BeginCNTSCMLb
				Dc.b	sRsrc_Vid_Civic_viNTSCFFb,sRsrc_Vid_Civic_viNTSCST
				Dc.b	sRsrc_Vid_Civic_NTSCFFConva,sRsrc_Vid_Civic_NTSCSTConv
EndCNTSCFamMLb

CPALFamTbla		Dc.w	EndCPALFamMLa-BeginCPALMLa-1
BeginCPALMLa
				Dc.b	sRsrc_Vid_Civic_viPALFFa,sRsrc_Vid_Civic_viPALSTa
				Dc.b	sRsrc_Vid_Civic_PALFFConva,sRsrc_Vid_Civic_PALSTConva
EndCPALFamMLa

CPALFamTblb		Dc.w	EndCPALFamMLb-BeginCPALMLb-1
BeginCPALMLb
				Dc.b	sRsrc_Vid_Civic_viPALFFb,sRsrc_Vid_Civic_viPALSTb
				Dc.b	sRsrc_Vid_Civic_PALFFConva,sRsrc_Vid_Civic_PALSTConva
EndCPALFamMLb

CGoldFishFamTbla	Dc.w	EndCGoldFishMLa-BeginCGoldFishMLa-1 ; 
BeginCGoldFishMLa
				Dc.b	sRsrc_Vid_Civic_viGFa,sRsrc_Vid_Civic_viGFNTSCST
				Dc.b	sRsrc_Vid_Civic_viGFNTSCFFa,sRsrc_Vid_Civic_viGFPALFFa
EndCGoldFishMLa

CGoldFishFamTblb	Dc.w	EndCGoldFishMLb-BeginCGoldFishMLb-1 ;
BeginCGoldFishMLb
				Dc.b	sRsrc_Vid_Civic_viGFb,sRsrc_Vid_Civic_viGFNTSCST
				Dc.b	sRsrc_Vid_Civic_viGFNTSCFFb,sRsrc_Vid_Civic_viGFPALFFb

EndCGoldFishMLb

CMultiFamTbla	Dc.w	EndCMultiMLa-BeginCMultiMLa-1 ; 
BeginCMultiMLa
				Dc.b	sRsrc_Vid_Civic_viHRa,sRsrc_Vid_Civic_viHRNTSCST,sRsrc_Vid_Civic_viHR400
				Dc.b	sRsrc_Vid_Civic_viGFPALFFa,sRsrc_Vid_Civic_viSVGA72a,sRsrc_Vid_Civic_viGFa
				Dc.b	sRsrc_Vid_Civic_vi19a,sRsrc_Vid_Civic_vi2PRGBa
EndCMultiMLa

CMultiFamTblb	Dc.w	EndCMultiMLb-BeginCMultiMLb-1 ;
BeginCMultiMLb
				Dc.b	sRsrc_Vid_Civic_viHRb,sRsrc_Vid_Civic_viHRNTSCST,sRsrc_Vid_Civic_viHR400
				Dc.b	sRsrc_Vid_Civic_viGFPALFFb,sRsrc_Vid_Civic_viSVGA72b,sRsrc_Vid_Civic_viGFb
				Dc.b	sRsrc_Vid_Civic_vi19b,sRsrc_Vid_Civic_vi2PRGBb

EndCMultiMLb

				Align	4
				
; The CivicConfigTable is an array of configuration parameters indexed
;	by display type.  Within each set of display parameters is a set
;	of parameters that are indexed by the amount of vRAM available.  These
;	parameters are used in setting up the intial values of the CLUT and
;	selecting the right functional sRsrc per display per vRAM configuration.
;

				WITH	CivicConfigRec

CivicConfigTable
				
CVesuvioTbl		Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_vi2PRGBa,FourthVidMode		; 1Meg vRAM prefs.
				Dc.w	CVesuvioFamTbla-CVesuvioTbl					; Offset to family modes.
				Dc.b	sRsrc_Vid_Civic_vi2PRGBb,FourthVidMode		; 2Meg vRAM prefs.
				Dc.w	CVesuvioFamTblb-CVesuvioTbl					; Offset to family modes.
				
CFullPageTbl	Dc.b	$00,$00,$00,$00,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viFPa,FirstVidMode			; 1Meg vRAM prefs.
				Dc.w	CFullPageFamTbla-CFullPageTbl				; Offset to family modes.
				Dc.b	sRsrc_Vid_Civic_viFPb,FirstVidMode			; 2Meg vRAM prefs.
				Dc.w	CFullPageFamTblb-CFullPageTbl				; Offset to family modes.
				
CRubikTbl		Dc.b	$05,$FF,$05,$FF,$05,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viGS,FourthVidMode			; 1Meg vRAM prefs.
				Dc.w	CRubikFamTbl-CRubikTbl						; Offset to family modes.										
				Dc.b	sRsrc_Vid_Civic_viGS,FourthVidMode			; 2Meg vRAM prefs.
				Dc.w	CRubikFamTbl-CRubikTbl						; Offset to family modes.										

CKongTbl		Dc.b	$00,$00,$00,$00,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_vi2Pa,FirstVidMode			; 1Meg vRAM prefs.
				Dc.w	C2PageFamTbla-CKongTbl						; Offset to family modes.
				Dc.b	sRsrc_Vid_Civic_vi2Pb,FirstVidMode			; 2Meg vRAM prefs.
				Dc.w	C2PageFamTblb-CKongTbl						; Offset to family modes.
				
CNTSCTbl		Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_NTSCSTConv,FourthVidMode	; 1Meg vRAM prefs.
				Dc.w	CNTSCFamTbla-CNTSCTbl						; Offset to family modes.										
				Dc.b	sRsrc_Vid_Civic_NTSCSTConv,FourthVidMode	; 2Meg vRAM prefs.
				Dc.w	CNTSCFamTblb-CNTSCTbl						; Offset to family modes.										
						
CRGBFullPageTbl	Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viFPRGBa,FourthVidMode		; 1Meg vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Civic_viFPRGBb,FourthVidMode		; 2Meg vRAM prefs.
				Dc.w	0											; No families.
				
CHiResTbl		Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viHRa,FourthVidMode			; 1Meg vRAM prefs.
				Dc.w	CHiResFamTbla-CHiResTbl						; Offset to family modes.
				Dc.b	sRsrc_Vid_Civic_viHRb,FourthVidMode			; 2Meg vRAM prefs.
				Dc.w	CHiResFamTblb-CHiResTbl						; Offset to family modes.
				
CNoConnectTbl	Dc.b	0,0,0,0,0,0,0,0								; No connect.
				Dc.b	sRsrc_Civic_NeverMatch,0					;
				Dc.w	0											;
				Dc.b	sRsrc_Civic_NeverMatch,0					;
				Dc.w	0											; 
				
CVGATbl			Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viVGAa,FourthVidMode		; 1Meg vRAM prefs.
				Dc.w	CVGAFamTbla-CVGATbl							; Offset to family modes.										
				Dc.b	sRsrc_Vid_Civic_viVGAb,FourthVidMode		; 2Meg vRAM prefs.
				Dc.w	CVGAFamTblb-CVGATbl							; Offset to family modes.										

CPALTbl			Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_PALSTConva,FourthVidMode	; 1Meg vRAM prefs.
				Dc.w	CPALFamTbla-CPALTbl							; Offset to family modes.										
				Dc.b	sRsrc_Vid_Civic_PALSTConva,FourthVidMode	; 2Meg vRAM prefs.
				Dc.w	CPALFamTblb-CPALTbl							; Offset to family modes.										
						
CGoldFishTbl	Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viGFa,FourthVidMode			; 1Meg vRAM prefs.
				Dc.w	CGoldFishFamTbla-CGoldFishTbl				; No families.
				Dc.b	sRsrc_Vid_Civic_viGFb,FourthVidMode			; 2Meg vRAM prefs.
				Dc.w	CGoldFishFamTblb-CGoldFishTbl				; No families.
				
C19Tbl			Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_vi19a,FourthVidMode			; 1Meg vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Civic_vi19b,FourthVidMode			; 2Meg vRAM prefs.
				Dc.w	0											; No families.
				
CMultiTbl		Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Civic_viGFa,FourthVidMode			; 1Meg vRAM prefs.
				Dc.w	CMultiFamTbla-CMultiTbl						; Offset to family modes.
				Dc.b	sRsrc_Vid_Civic_viGFb,FourthVidMode			; 2Meg vRAM prefs.
				Dc.w	CMultiFamTblb-CMultiTbl						; Offset to family modes.
				
				ENDWITH

				
		END
