;
;	File:		SonoraPrimaryInit
;
;	Written by:	Mike Puckett, December 2, 1991.
;
;	Copyright:	© 1991-1993 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	  <SM29>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
;									machines
;	  <SM28>	 11/3/93	RC		Took out test for VRAM so Factory test would work on PDM
;	  <SM27>	10-19-93	jmp		Quit defaulting the Full-Page Display to 1bpp now that
;									NewGDevice can handle mono-only displays correctly.
;	  <SM26>	 10/6/93	RC		Took out PDM EVT1 support from DoSonoraExtendedSense
;	  <SM25>	09-23-93	jmp		Commented out the RAM allocation family modes for PDM (since
;									we’re not doing the RAM allocation stuff).
;	  <SM24>	08-16-93	jmp		Now always write out the RAM/VRAM bits.
;	  <SM23>	08-03-93	jmp		Began cleaning up the support for dynamically allocating RAM in
;									PDM for video, as well as added initial support for the three
;									new Apple multiscan displays.
;	  <SM22>	 7/14/93	RC		stripping out debugging flags
;	  <SM21>	  6/3/93	PW		Fixed the build.  2 uses of SWRESET for AMIC registers were
;									changed to DMARST to coincide with AMICEqu.a and 1 use of
;									SWRESET for MACE register was changed to MACERESET.
;		<20>	  6/1/93	IH		Add rubrik560 and hr400 modes to multisync OK lise
;	  <SM19>	 5/28/93	IH		Add VGA mode to Multi-mode family
;	  <SM18>	  5/6/93	RC		Cleaned up the extended sense line support in PDM EVT2 and
;									greater units.  The old support for EVT1 units is also there
;									until EVT3
;	  <SM17>	 4/16/93	dwc		Mask and clear MACE and DMA ENET interrupts.
;	  <SM16>	04-07-93	jmp		Fixed problem where I was ALWAYS forcing the “default” bit depth
;									instead of using what the user set in Monitors.
;	  <SM15>	04-07-93	jmp		Added initial low-level support for the Display Manager.  Still
;									need to do depth validation (as opposed to just defaulting to a
;									particular depth) across family mode switches.
;	  <SM14>	04-01-93	jmp		Added initial support for the no-VRAM case where we use family
;									modes to represent the various RAM-based allocations.
;	  <SM13>	  3/9/93	jmp		Fully spelled out the differences between the AMIC (PDM) and
;									Sonora video hardware, added code that prunes all but the
;									appropriate CPU sResource, and moved around the Ethernet
;									(Sonic/Mace) reset code to be a bit more PMD/Sonora universal.
;	  <SM12>	  3/8/93	dwc		Added reset to PDM MACE and ENET DMA transmit and receive
;									channels.
;	  <SM11>	  3/5/93	CCH		Added code to prune Mace sRsrcs if it's not present.
;	  <SM10>	 2/20/93	SAM		Added a bit of PDMDebug code to drive the monitor sense lines
;									with a reversed polarity.
;	   <SM9>	  2/9/93	SAM		Added some Evt1 fix code to the monitor sense routine.
;	   <SM8>	01/13/93	jmp		Removed the extraneous MiniGamma record.
;	   <SM7>	12/09/92	jmp		Removed the PDM bring-up code.
;	   <SM6>	 11/6/92	jmp		Added a little more PDM bring-up code.
;	   <SM5>	 11/5/92	SWC		Changed VideoEqu.a->Video.a and ShutdownEqu.a->Shutdown.a.
;	   <SM4>	10/20/92	CCH		Conditionalized out an instruction that keeps PDM video from
;									coming up.
;	   <SM3>	10/17/92	jmp		Added initial support for PDM’s (broken) bring-up hardware.
;	   <SM2>	10/13/92	jmp		(jmp,H20) Even though it’s not technically necessary for Sonora
;									(Vail), I went ahead and tri-stated the senselines just prior to
;									the first read.  For PDM (whose video I/O is almost identical to
;									that of Sonora), this is necessary.
;	   <SM1>	 10/6/92	GDW		New location for ROMLink tool.
; ———————————————————————————————————————————————————————————————————————————————————————
;	  Pre-ROMLink comments begin here.
; ———————————————————————————————————————————————————————————————————————————————————————
;	   <SM4>	09/03/92	jmp		(jmp,H19) Fixed three problems:  1) Fixed a bug where the
;									machine would crash on boot if an unsupported display (such as
;									Vesuvio or Kong) were connected to built-in video.  2) Fixed a
;									bug where I was using _sPutPRAMRec instead of _InitSlotPRAM to
;									setup Slot $0 pRAM the first time.  And 3) Due to a change in
;									the Sonora hardware, had to change the way the sense-lines are
;									read.
;									(NJV,H18) Removed hasSonora1 conditionalized code (no longer
;									needed)
;									(jmp,H17) Corrected .s vs. non-.s branches and odd-alignment
;									problems.
;	   <SM3>	 6/18/92	KW		(jmp,H16) Added extended factory burn-in support (for various
;									displays), and added code to accomodate the Omega-2 when it
;									arrives.
;	   <SM2>	  6/4/92	KW		(NJV,H15) Temporarily using $57 for DFAC Sound initialization to
;									get rid of annoying playthrough.
;									(NJV,H14) Fixed bug with DFAC setup for sound
;	   <SM1>	  5/2/92	kc		Roll in Horror. Comments follow:
;	   <H13>	04/24/92	jmp		Changed the support for Egret Keyboard NMI to be toggle-able
;									with a Slot pRAM bit.
;	   <H12>	04/20/92	jmp		Fixed a bug where I was trashing A0 which caused direct-slot
;									video cards to hang due to the fact that none of the Sonora
;									functional sRsrcs were being pruned when no monitor was
;									connected.  Also, added some code to enable Egret Keyboard NMI.
;	   <H11>	04/20/92	jmp		Added full support for family modes.
;	   <H10>	 4/13/92	JC		Removed references to SonoraAddr and replaced with references to
;									VIA1Addr.
;		<H9>	 2/24/92	NJV		Added sound DFAC values to dot-clock setup portion of Omega
;		<H8>	 2/14/92	JC		Add support for Sonic Ethernet with Rev 1 Sonora parts
;		<H7>	02/04/92	jmp		Removed some extraneous Endwith statements.
;		<H6>	01/27/92	jmp		Changed the no-connect path so that it no longer supports the
;									alternate sense byte.  Now, only type-6’s trigger it.  Also,
;									fixed a problem I introduced in <H5> where I would cause
;									Vail/Carnation to hang if nothing was plugged into built-in
;									video.
;		<H5>	01/22/92	jmp		Updated the original “No Connect” code to take full advantage of
;									the newly-defined extended sense codes.  Changed the name from
;									“NoConnect” to “AltSense.”
;		<H4>	 1/14/92	jmp		Fixed a problem where I wasn’t setting up A3 correctly if Slot
;									pRAM was already setup.
;		<H3>	01/11/92	jmp		Eliminated several BoxFlag dependencies.
;		<H2>	12/19/91	jmp		Added the initial support for Rubik-560 mode for Sonora.
;		 <1>	12/12/91	jmp		first checked in

;---------------------------------------------------------------------
;	Header
;---------------------------------------------------------------------
				
				STRING 	C

				PRINT	OFF
				LOAD	'StandardEqu.d'

				INCLUDE	'AMICEqu.a'
				INCLUDE	'EgretEqu.a'
				INCLUDE	'IOPrimitiveEqu.a'
				INCLUDE	'SonicEqu.a'
				
				INCLUDE 'HardwarePrivateEqu.a'
				INCLUDE 'ROMEqu.a'
				INCLUDE	'Video.a'
				INCLUDE	'SlotMgrEqu.a'
				INCLUDE	'UniversalEqu.a'
				
				INCLUDE	'DepVideoEqu.a'
				PRINT	ON

				SEG		'_sSonoraPrimaryInit'
				BLANKS		ON
				STRING		ASIS
				MACHINE		MC68020

LSonoraPrimaryInit		MAIN	EXPORT
				Dc.b	sExec2								; Header
				Dc.b	sCPU68020
				Dc.w	0
				Dc.l	BeginSonoraInit-*

;---------------------------------------------------------------------
;	Local variables, definitions, etc....
;---------------------------------------------------------------------

				With	SEBlock,SPBlock,EgretPB

SonoraFrame		Record	{A6Link},Decrement
Return			Ds.l	1									; Return address.
A6Link			Ds.l	1									; Saved A6.
spBlk			Ds		SPBlock								; SpBlock for generic use.
sPRAMBlk		Ds.b	SizeSPRAMRec						; sPRAMRec for generic use.
egretBlk		Ds.b	EgretPbSize							; EgretPB for generic use.
hasVRAM			Ds.b	1									; If set, vRAM sizing needs to be performed.
hasExternDotClk	Ds.b	1									; If set, dot-clock must be programmed manually.
				Ds.b	1									; <pad>
vidParamsPtr	Ds.l	1									; Pointer to video parameters.
configParamsPtr	Ds.l	1									; Pointer to config parameters.
vidControlPtr	Ds.l	1									; Pointer to video control registers.
vidVIA2Ptr		Ds.l	1									; Pointer to VIA2.
SFSize			Equ		*
				Endr
				
				Endwith

SVRAMConfigRec	Record	0									; 
sRsrcID			Ds.b	1									; sRsrc ID for this vRam configuration.
modeID			Ds.b	1									; Favored modeID (depth).
familiesOffset	Ds.w	1									; Offset to family mode table.
SVRAMConfigSize	Equ		*
				Endr

				With	MiniGamma,SVRAMConfigRec

SonoraConfigRec	Record	0
gammaTbl		Ds.b	GT_Size								; Mini-gamma table (defined in PrimaryInit.a).
SConfigHdrSize	Equ		*
s256KVRAM		Ds.b	SVRAMConfigSize						; 256K vRAM preferences.
s512KVRAM		Ds.b	SVRAMConfigSize						; 512K vRAM preferences.
s768KVRAM		Ds.b	SVRAMConfigSize						; 768K vRAM preferences.
SConfigRecSize	Equ		*
				Endr

				Endwith

;---------------------------------------------------------------------
;	Utils
;---------------------------------------------------------------------

;---------------------------------------------------------------------
;
;	PruneList
;
;	Loops thru a table of sRsrcIDs comparing the “keeper” with each
;		of the entries in the table.  Those IDs that don’t match
;		the keeper are pruned.
;
;	->	D0:	sRsrcID of the “keeper”
;	->	A0:	pointer to appropriately filled-out SpBlock
;	->	A1:	pointer to list of sRsrcIDs
;
;	Trashes: D0-D1/A1.
;
				With	SpBlock

SPIPruneList
				Move.b	D0,-(Sp)							; Remember the ID of the “keeper.”							
				Move.w	(A1)+,D1							; Get the zero-based counter into D1.

@Repeat			Move.b	(A1)+,D0							; Get an sRsrc ID.
				Cmp.b	(Sp),D0								; If it’s the keeper,
				Beq.s	@Until								;	then don’t prune it.
				Move.b	D0,spID(A0)							; Otherwise, prune it.
				_sDeleteSRTRec
@Until			Dbra	D1,@Repeat							; Loop until done.

				Tst.b	(Sp)+								; Clean up the stack.
				Rts											; Return to caller.
				
				EndWith
				
;---------------------------------------------------------------------
;
;	BuildFamilyList
;
;	Loops thru a table of sRsrcIDs comparing the “keeper” with each
;		of the entries in the table.  Those IDs that don’t match
;		the keeper are inserted back in as disabled.
;
;	->	D0:	sRsrcID of the “keeper”
;	->	A0:	pointer to appropriately filled-out SpBlock
;	->	A1:	pointer to list of sRsrcIDs
;
;	Trashes: D0-D1/A1.
;
				With	SpBlock

SPIBuildFamilyList
				Move.b	D0,-(Sp)							; Remember the ID of the “keeper.”							
				Move.w	(A1)+,D1							; Get the zero-based counter into D1.

@Repeat			Move.b	(A1)+,D0							; Get an sRsrc ID.
				Cmp.b	(Sp),D0								; If it’s the keeper,
				Beq.s	@Until								;	then leave it alone.
				Move.b	D0,spID(A0)							; Otherwise, load that sRsrc ID.
				Clr.l	spsPointer(A0)						; Tell the Slot Manager that it’s in ROM.
				Move.l	#1,spParamData(A0)					; Say that we want it disabled.
				Clr.w	spRefNum(A0)						; Say that there’s no driver yet.
				_InsertSRTRec								; Do it!
@Until			Dbra	D1,@Repeat							; Loop until done.

				Tst.b	(Sp)+								; Clean up the stack.
				Rts											; Return to caller.
				
				EndWith

; This subroutine reads the Sonora sense lines.  On entry, A2 should point to the Sonora base address, D6
;	should contain $03, $05, $06, or $07 to indicate the type of extended sense we’re doing, and
;	the CPU should have been put into 32-bit addressing mode.  On exit, D6 contains the appropriate
;	extended sense code.
;
; Note:	The idea behind the extended-sense-line ($07) algorithm is as follows:  First, drive sense line
;		“a” and read the values of “b” and “c.”  Next, drive sense line “b” and read the values of “a”
;		and “c.”  Finally, drive sense line “c” and read the values of “a” and “b.”  In this way, a
;		six-bit number of the form bc/ac/ab is generated.  The other extended-sense algorithms are
;		identical to that of $07, except one of the three lines doesn’t need to be driven.  For example,
;		with $03, “a” doesn’t need to be driven.  With $05, “b” doesn’t need to be driven, and
;		with $06, “c” doesn’t need to be driven.
;

DoSonoraExtendedSense

				Movem.l	D0-D4,-(Sp)								; Save work registers.
				
				Moveq	#0,D1									; Use D1 to store extended-sense code.
				Moveq	#0,D0									; Use D0 as temp from reads.
								
				move.b	$0cb3,D2
				cmp.b	#$44, D2							; is it EVT1
				bne.s	@notEVTone							; no, not EVT1
				Move.b	#04,D2								; D2 == sonoraEnableAMask
				Move.b	#02,D3								; D3 == sonoraEnableBMask
				Move.b	#01,D4								; D4 == sonoraEnableCMask
				bra.s	@done
@notEVTone		Move.b	#03,D2								; D2 == sonoraEnableAMask
				Move.b	#05,D3								; D3 == sonoraEnableBMask
				Move.b	#06,D4								; D4 == sonoraEnableCMask
				
; Drive a, Read bc
;
@done			Cmp.b	#indexedSense2P,D6						; If this is not a type-3 extended sense,
				Bne.s	@DriveA									;	then go ahead and drive A.
				Move.b	D6,D0									; Otherwise, write out the assumed value,
				Bra.s	@EndA									;	and go on.

@DriveA			Move.b	D2,SonoraVdSenseRg(A2)					; abc <- 011 ••• Take out in PDM EVT3
;@DriveA			Move.b	#sonoraEnableAMask,SonoraVdSenseRg(A2)	; abc <- 011

				SonoraReadSenseLines D0							; abc -> ABC
				Andi.b	#sonoraAMask,D0							; 0BC
				
@EndA			Move.b	D0,D1									; 00 00 BC
				Lsl.b	#2,D1									; 00 BC 00
				
; Drive b, Read ac
;
				Cmp.b	#indexedSenseRGBFP,D6					; If this is not a type-5 extended sense,
				Bne.s	@DriveB									;	then go ahead and drive B.
				Move.b	D6,D0									; Otherwise, write out the assumed value,
				Bra.s	@EndB									; 	and go on.

@DriveB			Move.b	D3,SonoraVdSenseRg(A2)					; abc <- 101 ••• Take out in PDM EVT3
;@DriveB			Move.b	#sonoraEnableBMask,SonoraVdSenseRg(A2)	; abc <- 101

				SonoraReadSenseLines D0							; abc -> ABC
				Andi.b	#sonoraBMask,D0							; A0C
				
@EndB			Bclr	#sonoraSenseLineA,D0					; A0C becomes
				Beq.s	@OrIn									;  A0C or
				Bset	#sonoraSenseLineB,D0					;  A1C
				
@OrIn			Or.b	D0,D1									; 00 BC AC
				Lsl.b	#2,D1									; BC AC 00

; Drive c, Read ab
;
				Cmp.b	#indexedSenseHR,D6						; If this is not a type-6 extened sense,
				Bne.s	@DriveC									;	then go ahead and drive C.
				Move.b	D6,D0									; Otherwise, write out the assumed value,
				Bra.s	@EndC									;	and go on.

@DriveC			Move.b	D4,SonoraVdSenseRg(A2)					; abc -> 110 ••• Take out in PDM EVT3
;@DriveC			Move.b	#sonoraEnableCMask,SonoraVdSenseRg(A2)	; abc -> 110

				SonoraReadSenseLines D0							; abc <- ABC
				Andi.b	#sonoraCMask,D0							; AB0
			
@EndC			Lsr.b	#1,D0									; 0AB
				Or.b	D0,D1									; BC AC AB
				
@End			Move.b	D1,D6									; Save the extended-sense code.
				Movem.l	(Sp)+,D0-D4								; Restore work registers.
				Rts												; Return to caller.
				
; This subroutine programs Omega, which is the dot-clock generator.  To talk to Omega we have to go through
;	DFAC, which itself is accessed through Egret.  To program Omega, there are three parameters that are
;	packed into 16 bits, but we must program DFAC with 4 bytes (32 bits).  So, the input to this routine
;	should be in D0 as the hi-word as follows:  N [15:9], D [8:2], P [1:0].  The lo-word of
;	D0 should just be cleared.  Note:  This routine does not preserve D0.
;
; Note:  On PDM CPUs, the dot-clock is set up automatically.
;

				With	SonoraFrame,EgretPB
DoOmega
				Tst.b	hasExternDotClk(A6)					; If we don’t need to set up the dot-clock ourselves,
				Beq.s	@Done								;	then just skip this code.
				
				Ori.b	#sndSonoraReverseDFAC,D0			; Make sure the sound part of DFAC is correct.

				Lea		egretBlk(A6),A0						; Point to the Egret param block.
				Move.w	#(PseudoPkt<<8)+WrDFAC,pbCmdType(A0) ; Say that we’re writing DFAC.
				Move.l	D0,pbParam(A0)						; Put out the DFAC data.
				Move.w	#4,pbByteCnt(A0)					; We’re sending 4 bytes.
				Clr.w	pbResult(A0)						; Clear the result word.
				Clr.l	pbCompletion(A0)					; No completion routines here.
				_EgretDispatch

@Done			Rts
				
				Endwith
				
;---------------------------------------------------------------------
;	Main
;---------------------------------------------------------------------

				With	SEBlock,SPBlock,SonoraFrame

BeginSonoraInit

;
; Set up initial “vendor” status.
;
				Link	A6,#SFSize							; Allocate stack space for locals.
				Move.w	#seSuccess,seStatus(A0)				; Just say that we’re okay.
				
;
; Perform some generic initializations.
;
				Clr.b	spBlk.spSlot(A6)					; Built-in video is always Slot $0.
				Clr.b	spBlk.spExtDev(A6)					; Why ask why? Just clear this guy.
				
				Movea.l	UnivInfoPtr,A4						; Keep a pointer to ProductInfo.
				
;
; Initialize the BoardID part of the Slot $0 pRAM if necessary, and prune the board sResources.
;
				With	SP_Params,ProductInfo,VideoInfo
				
				Lea		spBlk(A6),A0						; Point A0 at our local SpBlock.
				Lea		sPRAMBlk(A6),A2						; Get a pointer to our local SPRAMBlock.
				Move.l	A2,spResult(A0)						; Put our pointer in the SpBlock.
				_sReadPRAMRec								; Read Slot $0’s pRAM.
				
				Move.l	A4,A3								; Copy the ProductInfo pointer.
				Adda.l	VideoInfoPtr(A3),A3					; Point to the VideoInfo record.

				Tst.w	SP_BoardID(A2)						; If the board ID is non-zero,
				Bne.s	@PruneBoardSRsrc					;	then just go on.
				
				Move.b	BoardSRsrcID(A3),spID(A0)			; Get the appropriate board sRsrc ID.
				_sRsrcInfo									; Get the spsPointer.
				
				Move.b	#BoardID,spID(A0)					; Set up to get the correct board ID.
				_sReadWord									; Get it.
				
				Move.w	spResult+2(A0),SP_BoardID(A2)		; Save the board ID into pRAM.
				Move.l	A2,spsPointer(A0)					; Point to the pRAM param block.
				_InitSlotPRAM								; Write it out.

@PruneBoardSRsrc
				Lea		SonoraSpIDTbl,A1					; Point to the table of supported board sRsrcs.
				Move.b	BoardSRsrcID(A3),D0					; Get the sRsrc ID of the keeper into D0.
				Bsr		SPIPruneList						; Call our pruning utility.
				
;
; Set up the right CPU sResource.  We only recognize ’020, ’030, and ’040 CPUs (or emulators); all others
;	are ignored (i.e., the CPU sResources are all deleted in that case).
;
				Move.b	CPUFlag,D1							; Get the CPUFlag (680x0-flag) for compares.
				
				Lea		@CPUTable,A1						; Get pointer to the table of valid CPU types.
@CPULoop		Move.b	(A1)+,D0							; Pick up the next CPU type.
				Beq.s	@EndPruneCPUSRsrcs					; If we’re done, leave.
				Move.b	(A1)+,spID(A0)						; Assume we won’t find a match.
				Cmp.b	D0,D1								; But, if they do match,
				Beq.s	@SkipDelete							;	then just go on.
				_sDeleteSRTRec								; Otherwise, delete non-matching CPU sRsrc type.
@SkipDelete		Bra.s	@CPULoop							; And loop until done.

@CPUTable		Dc.b	cpu68020,sRsrc_CPUMacIIci			; Table of 680x0 CPU types and corresponding sRsrcs.
				Dc.b	cpu68030,sRsrc_CPUMac030
				Dc.b	cpu68040,sRsrc_CPUMac040
				Dc.b	0,0

@EndPruneCPUSRsrcs
				
; Set various feature flags for use later.  (Note:  For now this is pretty lame code; we’ll
;	make it “smarter” later.)
;
				Cmp.b	#sRsrc_BdVail,BoardSRsrcID(A3)		; If we’re not on a Sonora,
				Bne.s	@MustBePDM							;	then we must be a PDM for now.
				
				St		hasVRAM(A6)							; Sonora CPUs have real vRAM.
				St		hasExternDotClk(A6)					; Sonora CPUs have Omegas.
				Bra.s	@EndFeatureSetup
				
@MustBePDM		Sf		hasVRAM(A6)							; PDMs don’t have vRAM.
				Sf		hasExternDotClk(A6)					; PDMs set up the dot-clock automatically.

@EndFeatureSetup

				Endwith

;
; Prune the Ethernet (Sonic or Mace) sResources as needed.
;
				Lea		spBlk(A6),A0						; Point A0 at our local SpBlock.
				
				TestFor	SonicExists							; If we have Sonic hardware, then
				Bne.s	@DeleteMace							;	delete Mace, and reset Sonic.
				
				Move.b	#sRsrc_Sonic,spID(A0)				; Prune the Sonic sRsrc.
				_sDeleteSRTRec								; 
				
				TestFor	MaceExists							; If we have Mace hardware,
				Bne.s	DoMaceReset							;	then reset it.
				
@DeleteMace		Move.b	#sRsrc_Sonora_Mace,spID(A0)			; Prune the Mace sRsrc.
				_sDeleteSRTRec
				Bra.s	SonoraVideoInit
		
				With	SonicRegs

				Move.l	A4,A2								; Copy the ProductInfo pointer.
				Add.l	ProductInfo.DecoderInfoPtr(A2),A2	; Point to the base address table.
				Move.l	DecoderInfo.SonicAddr(A2),A2		; Get the Sonic base address into A2.

				MOVEQ	#0,D0
				BSET	#EXUSR3,D0							; Set FC0 to 1 
				MOVE.L	D0,Data_Config2(A2)					; set extended data config			
				MOVEQ	#0,D0
				BSET	#EXBUS,D0							; enable extended data config
				MOVE.L	D0,Data_Config(A2)					; set extended data config			
				Moveq	#(1<<RxDisable),D0
				Move.l	D0,Command(A2)						; Disable packet reception.
@Wait			Move.l	Command(A2),D0
				Btst	#RxEnable,D0
				Bne.s	@Wait								; Wait until it disables.

				Move.l	#(1<<SoftReset),D0
				MOVE.L	D0,Command(A2)						; Enable use of CAM cells.

				Sub.l	D0,D0
				Move.l	D0,Int_Mask(A2)						; disable SONIC interrupts
				Move.l	D0,CAM_Enable(A2)					; wipe out the CAM

				Endwith
				
				Bra.s	SonoraVideoInit						; Skip the Mace code.

DoMaceReset
; (following is from DeclNet:Mace:MaceEqu.a which I can't include because of mega-duplication between it and SonicEqu.a.)
MACERESET	EQU		0				; software reset	
;
; Reset the Ethernet hardware <SM12>
; First, reset the MACE
				Movea.l	A4,A3								; Copy the ProductInfo pointer.
				Adda.l	ProductInfo.DecoderInfoPtr(A3),A3	; Point to the base address table.
				move.l	DecoderInfo.MACEAddr(A3),A2			; Point to the MACE
				Move.b	#(1<<MACERESET), MACE_BIU_CNFG(A2)	; Reset MACE
			IF nonSerializedIO THEN							;
				nop											; Allow write to complete
			ENDIF

; Mask all MACE interrupts <SM17>
				Move.b	#$77, MACE_INT_MSK(A2)				; Mask all MACE interrupts
			IF nonSerializedIO THEN							;
				nop											; Allow write to complete
			ENDIF

; Make sure all MACE interrupts are cleared <SM17>
				Move.b	MACE_INT(A2),D0						; Register is read/clear

;  	and the AMIC Ethernet DMA transmit and receive channels too, just to be safe
				Movea.l		DecoderInfo.AMICAddr(A3), A2	; Get the AMIC DMA base address
; Reset the AMIC ENET DMA transmit channel
				Move.b		#(1<<DMARST), AMIC_DMA_XMIT_CNTL(A2)
			IF nonSerializedIO THEN
				nop											; Allow write to complete
			ENDIF

; Make sure the DMA interrupt is cleared and disabled <SM17>
				Move.b		#(1<<DMAIF), AMIC_DMA_XMIT_CNTL(A2)
			IF nonSerializedIO THEN
				nop											; Allow write to complete
			ENDIF

; Reset the AMIC ENET DMA receive channel
				Move.b		#(1<<DMARST), AMIC_DMA_RECV_CNTL(A2) 
			IF nonSerializedIO THEN
				nop											; Allow write to complete
			ENDIF

; Make sure the DMA interrupt is cleared and disabled <SM17>
				Move.b		#(1<<DMAIF), AMIC_DMA_RECV_CNTL(A3) ; Clear recv DMA IF, disable DMA
			IF nonSerializedIO THEN
				nop											; Allow it to complete
			ENDIF

;  end of reset ENET hardware <SM12>
;

;
; Here’s where we actually get the Sonora video going.  This includes setting up the functional
;	sRsrcs, as well as initializing the Sonora hardware and getting a stable raster for the
;	type of display connected.
;

SonoraVideoInit

; Get some useful values up front.
;
				Move.l	A4,A3								; Copy the ProductInfo pointer.
				Adda.l	ProductInfo.DecoderInfoPtr(A3),A3	; Point to the base address table.
				Move.l	DecoderInfo.VIA1Addr(A3),A3			; Get the Sonora base address (same as VIA1) into A3.
				
; First, disable the Slot $0 (built-in video) VBL interrupts.
;
				Move.l	A3,A2								; Copy the Sonora base address.
				Adda.l	#SonoraVIA2Base,A2					; Point to the interrupt register space.
				Move.l	A2,vidVIA2Ptr(A6)					; Save it for later.
				
				Move.b	#(1<<SonoraVBLIRQEn),SonoraSlotIER(A2) ; Disable built-in video’s VBLs.
				
; Size the amount of VRAM.  When done, D4 is set to one of {0,1,2}, where 0=256K,1=512K,2=768K.
;	Note:  Although 1024K is theoretically possible in a Sonora system, it is not useable.  So,
;	we just say 768K is available (i.e., D4=2), even though we set up the hardware for 1024K
;	if it’s there (so that the vRAM memory controller works correctly).
;
; For PDM...
;
				Moveq	#0,D4								; Init the VRAM size register.
				
				Tst.b	hasVRAM(A6)							; If this CPU doesn’t have vRAM, then
				Beq		@EndSize1							;	skip the VRAM sizing stuff.
				
@TestVRAM		Move.l	A4,A1								; Copy the ProductInfo pointer.
				Adda.l	ProductInfo.VideoInfoPtr(A4),A1		; Point to the VideoInfo record.
				Move.l	VideoInfo.VRAMLogAddr32(A1),A1		; Get the framebuffer base address.
				
				Moveq	#true32b,D0							; Set up to flip into 32-bit addressing mode.
				_SwapMMUMode								; Do the flip.
				
				Move.b	#Sonora1024K,SonoraVRAMSize(A2)		; Set up the hardware for 1Meg of VRAM.
				
				Move.l	#'256K',(A1)						; Write a signature to longword 0 in physbank 0.
				Sub.l	#4,(Sp)								; Clear the data lines.
				Add.l	#4,(Sp)
								
				Cmp.l	#'256K',SonoraWrap(A1)				; If we got our signature back,
				Adda.l	#k256KvRAM*2,A1						; (Point to longword 0 in physbank 2.)
				Beq.s	@256K								; 	it wrapped, so go on.
				Addq	#1,D4								; Otherwise, we’ve got 512K on-board.
				Bra.s	@512Kb

@256K			Move.l	#'512?',(A1)						; Write signature to longword 0 in physbank 2.
				Sub.l	#4,(Sp)								; Clear the data lines.
				Add.l	#4,(Sp)

				Cmp.l	#'512?',(A1)						; If we got our signature back,
				Beq.s	@512Ka								;	we’ve got expansion vRAM.
				Move.b	#Sonora256K,SonoraVRAMSize(A2)		; Otherwise, there’s only 256K out there.
				Bra.s	@EndSize
				
@512Ka			Addq	#1,D4								; Say there’s at least 512K out there.
				Cmp.l	#'512?',SonoraWrap(A1)				; If we got our signature back,
				Beq.s	@Set512Ka							;	it wrapped, so set 512K.
				Move.b	#Sonora768Ka,SonoraVRAMSize(A2)		; Otherwise, there’s 768K out there.
				Addq	#1,D4								; Say there’s 768K out there.
				Bra.s	@EndSize
				
@Set512Ka		Move.b	#Sonora512Ka,SonoraVRAMSize(A2)		; Say that there’s 512K out there.
				Bra.s	@EndSize

@512Kb			Move.l	#'768?',(A1)						; Write signature to longword 0 in physbank 2.
				Sub.l	#4,(Sp)								; Clear the data lines.
				Add.l	#4,(Sp)

				Cmp.l	#'768?',(A1)						; If we got our signature back,
				Beq.s	@768Kb								;	we’ve got expansion vRAM.
				Move.b	#Sonora512Kb,SonoraVRAMSize(A2)		; Otherwise, there’s only 512K out there.
				Bra.s	@EndSize
				
@768Kb			Addq	#1,D4								; Say there’s 768K out there.
				Cmp.l	#'768?',SonoraWrap(A1)				; If we got our signature back,
				Beq.s	@Set768Kb							;	it wrapped, so set 768K.
				Bra.s	@EndSize							; Otherwise, there’s 1024K out there.	
				
@Set768Kb		Move.b	#Sonora768Kb,SonoraVRAMSize(A2)		; Say that there’s 768K out there.

@EndSize		_SwapMMUMode								; Flip back to previous addressing mode.
@EndSize1

; Sense the type of display to drive.  Because of a problem in Sonora, the dot clock must be going
;	in order to sense the type of display that is connected.  As a result, the video blanking signal
;	must be turn off -- i.e., syncs must be running. 
;
				Move.l	A3,A2								; Copy the Sonora base address.
				Adda.l	#SonoraVdCtlBase,A2					; Point to the video control address space.
				Move.l	A2,vidControlPtr(A6)				; Save it for later.

				Bclr	#SonoraVidBlnkBit,SonoraVdModeReg(A2) ; Turn off video blanking so that we can read the senselines.
				Move.l	#ndpHR,D0							; Set up to turn on Omega (we’ll just use 30.24 MHz).
				Bsr.s	DoOMega								; Turn on Omega (so that we can read the senselines).

				Moveq	#0,D6								; Clear our senseline variable.

				Move.b	#tristateSonoraSense,SonoraVdSenseRg(A2); Tristate the sense lines.
				SonoraReadSenseLines D6						; Read the senselines.
				Tst.b	D6									; Zero means we have a broken AMIC.
				Bne.s	@Ok									; -> Nope, all's well
				Move.b	#0,SonoraVdSenseRg(A2)				; Tristate the sense lines the broken way & continue
				SonoraDelay

				SonoraReadSenseLines D6						; Read the senselines.
				
@Ok				Cmp.b	#indexedSenseHR,D6					; If we got a type-6, then do the
				Beq.s	@ExtendedHR							;	extended Hi-Res stuff.
				
				Cmp.b	#indexedNoConnect,D6				; If we got a type-7, then do the
				Beq.s	@ExtendedNoConnect					;	extened no-connect stuff.
				Bra		@EndSense							; Otherwise, the display is already indexed.

; • Check for Extended type-6 (HR)...
;
@ExtendedHR		Bsr		DoSonoraExtendedSense				; Do the extended type-6 sense algorithm.
				
				Lea		@XT6Table,A1						; Point to the table of extended type-6 codes.
@XT6Loop		Move.b	(A1)+,D0							; Pick up the next supported extended type-6 code.
				Bmi.s	@EndExtHR							; If we’re at the end of the list, then just leave.
				Move.b	(A1)+,D1							; Pick up the indexed version of the extended code.
				Cmp.b	D0,D6								; If we didn’t find a match, then
				Bne.s	@XT6Loop							;	just keep looping.
				Move.b	D1,D6								; Translate the extended code into its indexed version.
				Bra		@EndSense							; And move on.

@EndExtHR		Move.b	#indexedSenseHR,D6					; Say that a type-6 display is connected.

				With	SP_Params
				
				LEA		sPRAMBlk(A6),A2						; Point to the sPRAM block.
				Move.b	SP_AltSense(A2),D0					; Get the alternate senseID pRam byte.
				Andi.b	#spAltSenseValidMask,D0				; If it is valid, then just pretend that
				Bne.s	@DoMonID							;	the monID monitor is attached.
				Bra		@EndSense							; Otherwise, just let it be a type-6.

@DoMonID		Move.b	SP_AltSense(A2),D6					; Get the no-connect pRam byte.
				Andi.b	#spAltSenseMask,D6					; Strip the validation code.
				Bra		@EndSense

				Endwith

; • Check for Extended type-7 (No Connect)...
;
@ExtendedNoConnect
				Bsr		DoSonoraExtendedSense				; Do the extended no-connect algorithm.
				
				Cmp.b	#extendedNoConnect,D6				; If nothing really is connected,
				Beq.s	@EndNoConnect						;	then just say so.

				Lea		@XNCTable,A1						; Point to the table of extended no-connect codes.
@XNCLoop		Move.b	(A1)+,D0							; Pick up the next supported extended no-connnect code.
				Bmi.s	@EndNoConnect						; If we’re at the end of the list, then just leave.
				
				Move.b	(A1)+,D1							; Pick up the indexed version of the extended code.

				Cmp.b	D0,D6								; If we didn’t find a match, then
				Bne.s	@XNCLoop							;	just keep looping.
				
				Move.b	D1,D6								; Translate the extended code into its indexed version.
				Bra		@EndSense

@XNCTable		Dc.b	extendedSenseVGA,indexedSenseVGA
				Dc.b	extendedSenseGF,indexedSenseGF
				Dc.b	-1,-1
				
@XT6Table		Dc.b	extendedMSB1,indexedSenseMSB1
				Dc.b	extendedMSB2,indexedSenseMSB2
				Dc.b	extendedMSB3,indexedSenseMSB3
				Dc.b	-1,-1

@EndNoConnect	Move.b	#indexedNoConnect,D6				; We don’t recognize the code, so say nothing’s connected.

; When no monitor is connected, we first want to check to see if we’re at the factory
;	If we are, then the last 4-bytes of pRAM will contain a special signature.  If
;	we aren’t at the factory and we don’t recognize the no-connect code, then we
;	set up to delete all the video data structures and to turn built-in video off.
;
; Note:  On Systems with no real VRAM, we just skip this code because no RAM will
;	have been allocated for video in this case.  Will this be a problem for the
;	factory?
;
				Tst.b	hasVRAM(A6)							; If we don’t have VRAM, then
				Beq		@EndSense							;	just go on. 
				
				With	SP_Params

				Subq	#burnInSiz,Sp						; Get pRAM buffer on stack (4-bytes).
				Move.l	Sp,A0								; Point to it.
				Move.w	#burnInSiz,D0						; Set up parameters
				Swap	D0									;
				Move.w	#burnInLoc,D0						;
				_ReadXPram									; 
				Move.l	(Sp)+,D0							; 
				
				Beq.s	@EndSense							; With no signature, just leave.

				Lea		@NCTable,A1							; Point to the table of no-connect signatures.
@NCLoop			Move.l	(A1)+,D1							; Pick up the next supported code.
				Beq.s	@EndSense							; If we’re at the end of the list, then just leave.
				
				Move.l	(A1)+,D2							; Pick up the indexed version of the no-connect signature.
				
				Cmp.l	D0,D1								; If we didn’t find a match, then
				Bne.s	@NCLoop								;	just keep looping.

				Move.b	D2,D6								; Translate the no-connect signature into an index.
				Bra.s	@EndSense

@NCTable		Dc.l	burnInSig,indexedSenseHR			; Table of recognized no-connect signatures with…
				Dc.l	burnInSigAlt,indexedSenseRubik		;	…corresponding index.
				Dc.l	burnInSig12,indexedSenseRubik
				Dc.l	burnInSig13,indexedSenseHR
				Dc.l	burnInSig15,indexedSenseRGBFP
				Dc.l	burnInSig16,indexedSenseGF
				Dc.l	0,0
				
@EndSense		Move.l	vidControlPtr(A6),A2				 ; Point to the video control register space.
				Bset	#SonoraVidBlnkBit,SonoraVdModeReg(A2) ; Turn on blanking for now.
				Moveq	#0,D0								; Set up to turn off Omega.
				Bsr.s	DoOmega								; Turn Omega off for now.

; Pick up the favored configuration based on the amount of vRAM and the type of display sensed or assumed.
;
				With	SVRAMConfigRec,SonoraConfigRec
@GetConfig
				Tst.b	hasVRAM(A6)							; If we don’t have VRAM,
				Beq.s	@NoVRAM								;	then say so.
				Lea		SonoraConfigTable,A1				; Point to the Sonora configuration table.
				Bra.s	@Config								; Go on.
@NoVRAM			Lea		PDMConfigTable,A1					; Point to the PDM (no VRAM) config table.
@Config			Move.w	#SConfigRecSize,D0					; Get the size of each entry into D0.
				Mulu	D6,D0								; Multiply it by the right entry.
				Adda.l	D0,A1								; Skip to the entry we want.
				Move.l	A1,configParamsPtr(A6)				; Save it for later.
				Adda.l	#SConfigHdrSize,A1					; Skip past the header.
				Move.w	#SVRAMConfigSize,D0					; Get the size of the VRAM entries.
				Mulu	D4,D0								; Multiply by the right entry.
				Adda.l	D0,A1								; Skip to the right VRAM entry.
				
				Move.b	modeID(A1),D7						; Get the default mode (depth).
				Move.b	sRsrcID(A1),D5						; Get the default sRsrcID.
				
				Endwith

; Initialize built-in video’s pRAM.
;
				With	SP_Params

InitPRAM			
				Lea		spBlk(A6),A0						; Point to the slot param block.
				Lea		sPRAMBlk(A6),A2						; Point to the sPRAM block.
				
				Move.b	SP_Flags(A2),D0						; Copy the flags byte.
				
				Bfins	D4,D0{spVRamBits:numSPVRamBits}		; Load the amount of VRAM (real or imaginary).
				Tst.b	hasVRAM(A6)							; If we have real VRAM, then
				Bne.s	@SetFlags							;	skip the no-VRAM stuff.
@NoVRAM			Bset	#spNoVRAM,D0						; Always set the no-VRAM bit here.
				Bclr	#spFamilyChanged,D0					; Always reset the family changed bit.
				Beq.s	@SetFlags							; If it was already reset, then go on.
				Move.w	#drHwSonora,ScrnInval				; Remind ourselves to manually update the 'scrn' resource (so disk can make things right).
@SetFlags		Move.b	D0,SP_Flags(A2)						; Remember which flags and such were set/reset.
				Move.b	D6,SP_MonID(A2)						; Remember which monitor we sensed (or assumed).
				
				Cmp.b	SP_DfltConfig(A2),D5				; If this is the same configuration/family we had last time,
				Beq.s	@WritePRAM							;	then just write out the just-set PRAM info.

				Move.b	D5,SP_LastConfig(A2)				; Set the identification configuration.
				Move.b	D5,SP_DfltConfig(A2)				; Set the default/family configuration.
				
				Move.b	D7,SP_Depth(A2)						; Set the default depth for this configuration.

@WritePRAM		Move.l	A2,spsPointer(A0)					; Set up the pRAM parameter block.
				_sPutPRAMRec								; Write out Slot $0’s pRAM.
				
				Move.b	SP_LastConfig(A2),D5				; Get the right (family member) sRsrc into D5. 				
				
				Endwith

; First, prune all of the video sResources except for the selected one.  If there are no families, then we’re done.
;	Otherwise, we’re either done (because we’ve come up with an unknow configuration), or we re-insert all the members
;	of the selected configuration’s family as disabled.
;
				With	SVRAMConfigRec,SonoraConfigRec

				Lea		SonoraModeList,A1					; Point to the table of supported video sRsrcs.
				Move.b	D5,D0								; Get the sRsrcID of the keeper into D0.
				Bsr		SPIPruneList						; Call our pruning utility.
				
				Cmp.b	#sRsrc_Sonora_NeverMatch,D5			; If we’ve come up with an unknown configuration,
				Beq		SonoraExit							;	then we’re now done.
				
				Move.l	configParamsPtr(A6),A1				; Point to this config’s parameters.
				Adda.w	#SConfigHdrSize,A1					; Skip past the header.
				Move.w	#SVRAMConfigSize,D0					; Get the size of the vRAM entries.
				Mulu	D4,D0								; Multiply by the right entry.
				Adda.l	D0,A1								; Skip to the right vRAM entry.
				Move.w	familiesOffset(A1),D0				; If there aren’t any families,
				Beq.s	@EndConfig							;	then just go on.
				
				Move.l	configParamsPtr(A6),A1				; Point back to this config’s parameters.
				Adda.w	D0,A1								; Point to the table of supported families.
				Move.b	D5,D0								; Get the sRsrcID of the keeper into D0.
				Bsr		SPIBuildFamilyList					; Call our family-building utility.

@EndConfig				
				Endwith

; Initialize the video hardware.
;
				With	SonoraVidParams,MiniGamma
					
InitSonoraHW
				
				Clr.w	spID(A0)							; Start looking at spID 0, no external devices.
				Clr.b	spTBMask(A0)						; Only look for the board sRsrc.
				Move.w	#catBoard,spCategory(A0)			; Look for:	catBoard,
				Move.w	#typBoard,spCType(A0)				;			typBoard,
				Clr.w	spDrvrSW(A0)						;			0,
				Clr.w	spDrvrHW(A0)						;			0.
				Clr.l	spParamData(A0)						; (The board sRsrc must be enabled.)
				Bset	#foneslot,spParamData+3(A0)			; Limit search to this slot 0.
				_GetTypeSRsrc								; Get the spsPointer.
				
				Move.b	#sVidParmDir,spID(A0)				; Look for the video parameters directory.
				_sFindStruct
				
				Move.b	D5,spID(A0)							; Look in the directory for this config’s params.
				_sGetBlock
				
				Move.l	spResult(A0),A1						; Get a pointer to the vidParams.
				Move.l	A1,vidParamsPtr(A6)					; Save for later disposal.

; Set up the dot-clock portion of Omega.
;
				With	EgretPB,SonoraOmega
				
				Tst.b	hasExternDotClk(A6)					; If we don’t need to set up the dot-clock ourselves,
				Beq.s	@EndOmegaSetup						;	then just go on.
				
				Move.l	A1,A0								; Copy the vidParams ptr.

				Move.l	vidVIA2Ptr(A6),A2					; Point to the VIA2.
				Move.b	SonoraVRAMSize(A2),D0				; Pick up the VRAM Sizing parameters.
				Cmp.b	#Sonora512Kb,D0						; If we’ve got 512K on the motherboard
				Beq.s	@Omega2								;	then we’ve got a new Omega.
				Cmp.b	#Sonora768Kb,D0						;
				Bne.s	@SetOmega							;
				
@Omega2			Addq	#SOmegaSize,A0						; Skip past the Omega-1 parameters.		

@SetOmega		Moveq	#0,D0								; n d p <- 0000000 0000000 00
				Move.b	SOmegaN(A0),D0						; n d p <- 0000000 00NNNNN NN
				Lsl.w	#OmegaDBits,D0						; n d p <- 00NNNNN NN00000 00
				Move.b	SOmegaD(A0),D1						; n d p <- 00NNNNN NN00000 00 (0DDDDDDD)
				Or.b	D1,D0								; n d p <- 00NNNNN NNDDDDD DD
				Move.b	SOmegaP(A0),D1						; n d p <- 00NNNNN NNDDDDD DD (000000PP)
				Lsl.w	#OmegaPBits,D0						; n d p <- NNNNNNN DDDDDDD 00 (000000PP)
				Or.b	D1,D0								; n d p <- NNNNNNN DDDDDDD PP
				Swap	D0									; Move the ndp value into the MSW.

				Bsr.s	DoOmega								; Now, go program Omega.
@EndOmegaSetup				
				Endwith

; Set up Sonora and Ariel.
;
				Move.l	vidControlPtr(A6),A2				; Point to the video control register space.
				Clr.b	SonoraVdColrReg(A2)					; Set the framebuffer controller 1bpp.

				Move.b	svpMonitorCode(A1),D0				; Get the appropriate monitor code.
				Bset	#SonoraVidBlnkBit,D0				; Set the video blanking bit.
				Move.b	D0,SonoraVdModeReg(A2)				; Write it out.
				
				Move.l	A4,A2								; Copy the ProductInfo pointer.
				Adda.l	ProductInfo.DecoderInfoPtr(A2),A2	; Point to the baseAddr table.
				Move.l	DecoderInfo.VDACAddr(A2),A2			; Get the base address of the VDAC.
				Move.b	#$08,ArielConfigReg(A2)				; Set the CLUT/DAC to 1bpp, master mode, no overlay.

				Adda.w	#ArielDataReg,A2					; Point to the CLUT/DAC data register.
				Move.l	configParamsPtr(A6),A5				; Point to the config parameters.

				Move.b	#$7F,ArielAddrReg-ArielDataReg(A2)	; Setup to write 1bpp white.
				Move.b	whiteRed(A5),(A2)
				Move.b	whiteGreen(A5),(A2)
				Move.b	whiteBlue(A5),(A2)
				
				Move.b	#$FF,ArielAddrReg-ArielDataReg(A2)	; Setup to write 1bpp black.
				Move.b	blackRed(A5),(A2)
				Move.b	blackGreen(A5),(A2)
				Move.b	blackBlue(A5),(A2)

; Gray the screen.
;
				Move.l	A4,A2								; Copy the ProductInfo pointer.
				Adda.l	ProductInfo.VideoInfoPtr(A2),A2		; Point to the VideoInfo record.
				Move.l	VideoInfo.VRAMLogAddr32(A2),A2		; Point to the base of VRAM.
				
				Moveq	#true32b,D0							; Set up to flip into 32-bit addressing mode.
				_SwapMMUMode								; Do flip.
				Move.b	D0,-(Sp)							; Save previous mode.
				
				Move.w	svpNumRows(A1),D3					; Get the number of rows.
				Move.l	#OneBitGray,D2						; Set the 1bpp gray pattern.
				
				Moveq	#1,D0								; Assume that we’re not doing Rubik-560.
				Cmp.b	#sRsrc_Vid_Sonora_GS560a,D5			; If we’re doing Rubik-560a,
				Beq.s	@Flag560							;	then say so.
				Cmp.b	#sRsrc_Vid_Sonora_GS560b,D5			; If we’re not doing Rubik-560b,
				Bne.s	@NxtRow								;	then just go on
@Flag560		Moveq	#0,D0								; Flag that we’re doing Rubik-560.

@NxtRow			Move.w	svp1bppRowLongs(A1),D1				; Get the number of longwords/row.
@NxtLong		Move.l	D2,(A2)+							; Write out gray to the frame buffer…
				Dbra	D1,@NxtLong							; …for each scanline.
				Tst.b	D0									; If this not is a Rubik-560,
				Bne.s	@Skip560							;	then just go on.
				Move.w	D2,(A2)+							; Otherwise, write out 16 more pixels.
@Skip560		Not.l	D2									; Invert the pattern for the next row.
				Dbra	D3,@NxtRow							; Repeat for each row.
				
				Move.b	(Sp)+,D0							; Set up to flip back to previous addressing mode.
				_SwapMMUMode								; Do flip.
				
				Move.l	vidControlPtr(A6),A2				; Point back at the video control registers.
				Move.b	SonoraVdModeReg(A2),D0				; Get the current monitor code value.
				Bclr	#SonoraVidBlnkBit,D0				; Reset the video blanking bit.
				Move.b	D0,SonoraVdModeReg(A2)				; Write it out to get video going.
				
				Endwith

; Clean up and go home.
;
				Move.l	vidParamsPtr(A6),A0					; Dispose of the vidParams pointer.
				_DisposPtr
				
SonoraExit		
				Unlk	A6									; De-allocate local stack frame.
				Rts											; Return to caller.
				
				Endwith
				
;---------------------------------------------------------------------
;	Data
;---------------------------------------------------------------------

				Align	4

; The SonoraSpIDTbl is a list of all the board sRsrcIDs supported in the Sonora
;	sRsrc directory.  It is used to prune all the unnecessary board sRsrc.
;

SonoraSpIDTbl	Dc.w	EndSonoraSpIDTbl-BeginSonoraSpIDTbl-1
BeginSonoraSpIDTbl
				Dc.b	sRsrc_BdVail
				Dc.b	sRsrc_BdPDM
EndSonoraSpIDTbl

				Align	4

SonoraModeList	Dc.w	EndSonoraML-BeginSonoraML-2
BeginSonoraML
				Dc.b	sRsrc_Vid_Sonora_FPa,sRsrc_Vid_Sonora_FPb,sRsrc_Vid_Sonora_FPc
				Dc.b	sRsrc_Vid_Sonora_GSa,sRsrc_Vid_Sonora_GSb
				Dc.b	sRsrc_Vid_Sonora_GS560a,sRsrc_Vid_Sonora_GS560b
				Dc.b	sRsrc_Vid_Sonora_RGBFPa,sRsrc_Vid_Sonora_RGBFPb,sRsrc_Vid_Sonora_RGBFPc
				Dc.b	sRsrc_Vid_Sonora_HRa,sRsrc_Vid_Sonora_HRb,sRsrc_Vid_Sonora_HRc
				Dc.b	sRsrc_Vid_Sonora_HR400a,sRsrc_Vid_Sonora_HR400b
				Dc.b	sRsrc_Vid_Sonora_VGAa,sRsrc_Vid_Sonora_VGAb,sRsrc_Vid_Sonora_VGAc
				Dc.b	sRsrc_Vid_Sonora_GFa,sRsrc_Vid_Sonora_GFb
				
				Dc.b	sRsrc_Vid_Sonora_FP,sRsrc_Vid_Sonora_GS,sRsrc_Vid_Sonora_GSM
				Dc.b	sRsrc_Vid_Sonora_RGBFP,sRsrc_Vid_Sonora_HR,sRsrc_Vid_Sonora_VGA
				Dc.b	sRsrc_Vid_Sonora_GF,sRsrc_Vid_Sonora_MSB1,sRsrc_Vid_Sonora_MSB2
				Dc.b	0
EndSonoraML

				Align	4
				
SRubikFamTbla	Dc.w	EndSRubikMLa-BeginSRubikMLa-1
BeginSRubikMLa
				Dc.b	sRsrc_Vid_Sonora_GSa,sRsrc_Vid_Sonora_GS560a
EndSRubikMLa

SRubikFamTblb	Dc.w	EndSRubikMLb-BeginSRubikMLb-1
BeginSRubikMLb
				Dc.b	sRsrc_Vid_Sonora_GSb,sRsrc_Vid_Sonora_GS560b
EndSRubikMLb

SHiResFamTbla	Dc.w	EndSHiResMLa-BeginSHiResMLa-1
BeginSHiResMLa
				Dc.b	sRsrc_Vid_Sonora_HRa,sRsrc_Vid_Sonora_HR400a
EndSHiResMLa

SHiResFamTblb	Dc.w	EndSHiResMLb-BeginSHiResMLb-1
BeginSHiResMLb
				Dc.b	sRsrc_Vid_Sonora_HRb,sRsrc_Vid_Sonora_HR400b
EndSHiResMLb

SHiResFamTblc	Dc.w	EndSHiResMLc-BeginSHiResMLc-1
BeginSHiResMLc
				Dc.b	sRsrc_Vid_Sonora_HRc,sRsrc_Vid_Sonora_HR400b
EndSHiResMLc

				Align	4

PFPFamTbl		Dc.w	EndPFPML-BeginPFPML-1
BeginPFPML
				Dc.b	sRsrc_Vid_Sonora_FPc,sRsrc_Vid_Sonora_FP
EndPFPML

PGSFamTbl		Dc.w	EndPGSML-BeginPGSML-2
BeginPGSML
				Dc.b	sRsrc_Vid_Sonora_GSb,sRsrc_Vid_Sonora_GSa,sRsrc_Vid_Sonora_GS
				Dc.b	0
EndPGSML

PRGBFPFamTbl	Dc.w	EndPRGBFPML-BeginPRGBFPML-1
BeginPRGBFPML
				Dc.b	sRsrc_Vid_Sonora_RGBFPc,sRsrc_Vid_Sonora_RGBFP
EndPRGBFPML

PHRFamTbl		Dc.w	EndPHRML-BeginPHRML-2
BeginPHRML
				Dc.b	sRsrc_Vid_Sonora_HRc,sRsrc_Vid_Sonora_HRb,sRsrc_Vid_Sonora_HR
				Dc.b	0
EndPHRML

PVGAFamTbl		Dc.w	EndPVGAML-BeginPVGAML-2
BeginPVGAML
				Dc.b	sRsrc_Vid_Sonora_VGAc,sRsrc_Vid_Sonora_VGAb,sRsrc_Vid_Sonora_VGA
				Dc.b	0
EndPVGAML

PGFFamTbl		Dc.w	EndPGFML-BeginPGFML-1
BeginPGFML
				Dc.b	sRsrc_Vid_Sonora_GFb,sRsrc_Vid_Sonora_GF
EndPGFML

PMSB1FamTbl		Dc.w	EndPMSB1ML-BeginPMSB1ML-2
BeginPMSB1ML
				Dc.b	sRsrc_Vid_Sonora_MSB1,sRsrc_Vid_Sonora_GSM,sRsrc_Vid_Sonora_MSB2
				Dc.b	0
EndPMSB1ML

PMSB2FamTbl		Dc.w	EndPMSB2ML-BeginPMSB2ML-1
BeginPMSB2ML
				Dc.b	sRsrc_Vid_Sonora_MSB2,sRsrc_Vid_Sonora_MSB1
EndPMSB2ML

				Align	4

; The SonoraConfigTable is an array of configuration parameters indexed
;	by monitor type.  Within each set of monitor parameters is a set
;	of parameters that are indexed by the amount of vRAM available.  These
;	parameters are used in setting up the intial values of the CLUT and
;	selecting the right functional sRsrc per monitor per vRAM configuration.
;
				With	SonoraConfigRec

SonoraConfigTable

				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; Vesuvio (Not Supported).
				
SFullPageTbl	Dc.b	$00,$00,$00,$00,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Sonora_FPa,FirstVidMode			; 256K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_FPb,FirstVidMode			; 512K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_FPc,FirstVidMode			; 768K vRAM prefs.
				Dc.w	0											; No families.
				
SRubikTbl		Dc.b	$05,$FF,$05,$FF,$05,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Sonora_GSa,FourthVidMode			; 256K vRAM prefs.
				Dc.w	SRubikFamTbla-SRubikTbl						; Offset to family modes.										
				Dc.b	sRsrc_Vid_Sonora_GSb,FourthVidMode			; 512K vRAM prefs.
				Dc.w	SRubikFamTblb-SRubikTbl						; Offset to family modes.										
				Dc.b	sRsrc_Vid_Sonora_GSb,FourthVidMode			; 768K vRAM prefs.
				Dc.w	SRubikFamTblb-SRubikTbl						; Offset to family modes.										
				
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; Mono Two-Page (Not Supported).
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; NTSC (Not Supported).
				
SRGBFullPageTbl	Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Sonora_RGBFPa,SecondVidMode		; 256K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_RGBFPb,ThirdVidMode		; 512K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_RGBFPc,FourthVidMode		; 768K vRAM prefs.
				Dc.w	0											; No families.
				
SHiResTbl		Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Sonora_HRa,ThirdVidMode			; 256K vRAM prefs.
				Dc.w	SHiResFamTbla-SHiResTbl						; Offset to family modes.										
				Dc.b	sRsrc_Vid_Sonora_HRb,FourthVidMode			; 512K vRAM prefs.
				Dc.w	SHiResFamTblb-SHiResTbl						; Offset to family modes.										
				Dc.b	sRsrc_Vid_Sonora_HRc,FourthVidMode			; 768K vRAM prefs.
				Dc.w	SHiResFamTblc-SHiResTbl						; Offset to family modes.										
				
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; No connect.
				
SVGATbl			Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Sonora_VGAa,ThirdVidMode			; 256K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_VGAb,FourthVidMode			; 512K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_VGAc,FourthVidMode			; 768K vRAM prefs.
				Dc.w	0											; No families.

				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; PAL (Not Supported).
				
SGoldFishTbl	Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.
				Dc.b	sRsrc_Vid_Sonora_GFa,SecondVidMode			; 256K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_GFb,FourthVidMode			; 512K vRAM prefs.
				Dc.w	0											; No families.
				Dc.b	sRsrc_Vid_Sonora_GFb,FourthVidMode			; 768K vRAM prefs.
				Dc.w	0											; No families.

				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; 19" (Not Supported).
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; MS (Not Supported).
				
PDMConfigTable
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; Vesuvio (Not Supported).			[0]
					
PFPTbl			Dc.b	$00,$00,$00,$00,$00,$FF,0,0					; Mini-gamma table.					[1]
				Dc.b	sRsrc_Vid_Sonora_FPc,FirstVidMode			; 
;				Dc.w	PFPFamTbl-PFPTbl							; Offset to family modes.										
				Dc.w	0											; No families.
				Dcb.b	8,0
				
PGSTbl			Dc.b	$05,$FF,$05,$FF,$05,$FF,0,0					; Mini-gamma table.					[2]
				Dc.b	sRsrc_Vid_Sonora_GSb,FourthVidMode			; 
;				Dc.w	PGSFamTbl-PGSTbl							; Offset to family modes.										
				Dc.w	0											; No families.
				Dcb.b	8,0
				
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; Mono Two-Page (Not Supported).	[3]
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; NTSC (Not Supported).				[4]
				
PRGBFPTbl		Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[5]
				Dc.b	sRsrc_Vid_Sonora_RGBFPc,FourthVidMode		; 
;				Dc.w	PRGBFPFamTbl-PRGBFPTbl						; Offset to family modes.										
				Dc.w	0											; No families.
				Dcb.b	8,0
				
PHRTbl			Dc.b	00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[6]				
				Dc.b	sRsrc_Vid_Sonora_HRc,FourthVidMode			; 
;				Dc.w	PHRFamTbl-PHRTbl							; Offset to family modes.										
				Dc.w	0											; No families.
				Dcb.b	8,0
				
				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; No connect.						[7]
				
PVGATbl			Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[8]
				Dc.b	sRsrc_Vid_Sonora_VGAc,FourthVidMode			;
;				Dc.w	PVGAFamTbl-PVGATbl							; Offset to family modes.										
				Dc.w	0											; No families.
				Dcb.b	8,0

				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; PAL (Not Supported).				[9]
				
PGFTbl			Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[A]
				Dc.b	sRsrc_Vid_Sonora_GFb,FourthVidMode			;
;				Dc.w	PGFFamTbl-PGFTbl							; Offset to family modes.										
				Dc.w	0											; No families.
				Dcb.b	8,0

				Dcb.b	SConfigRecSize,sRsrc_Sonora_NeverMatch		; 19" (Not Supported).				[B]
				
PMSB1Tbl		Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[C]
				Dc.b	sRsrc_Vid_Sonora_MSB1,FourthVidMode			;
				Dc.w	PMSB1FamTbl-PMSB1Tbl						; Offset to family modes.										
				Dcb.b	8,0

PMSB2Tbl		Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[D]
				Dc.b	sRsrc_Vid_Sonora_MSB2,FourthVidMode			;
				Dc.w	PMSB2FamTbl-PMSB2Tbl						; Offset to family modes.										
				Dcb.b	8,0

PMSB3Tbl		Dc.b	$00,$FF,$00,$FF,$00,$FF,0,0					; Mini-gamma table.					[E]
				Dc.b	sRsrc_Vid_Sonora_MSB2,FourthVidMode			;
				Dc.w	PMSB2FamTbl-PMSB3Tbl						; Offset to family modes.										
				Dcb.b	8,0

				Endwith
		END