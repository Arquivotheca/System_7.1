;__________________________________________________________________________________________________;;	File:		Universal.a;;	Contains:	This module provides Data structures and routines to support Universal ROMs.;				It can also be used in Non-Universal ROMs to provide tables for initializing;				base addresses and hardware.;;	Written by:	Gary G. Davidian;;	Copyright © 1989-1993 by Apple Computer, Inc.  All rights reserved.;;	Change History (most recent first):;;	  <SM62>	12/17/93	PN		Fix the test for Pratt decoder;	  <SM61>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ;									machines.;	  <SM60>	 12/7/93	BG		Modified the Frigidaire entries in the djMEMC @MachineTbl to;									properly reflect the VIA PortA values for CPU ID+Speed.;	  <SM59>	11/17/93	KW		forSTP601 in GetCPUIDReg to or in Risc product to the id.;	  <SM58>	 11/9/93	KW		made some changes for STP machines.  changes are conditionalized;									by forSTP601;	  <SM57>	 9/26/93	KW		(H35 BG) Modified the djMEMC memory controller setup so that it;									chooses between Wombats and Speedbumped Wombats and initializes;									the memory controller to use a different set of wait states for;									the Speedbumped machines. This is because the Speedbump'ed;									units do not want to have to use faster-speed DRAM, which;									currently the Quadra 800 (Wombat33inFridge) requires. The;									Speedbumped 650 (Wombat33inLego) will expect 80ns DRAM, just as;									the Centris650 (Wombat25inLego) did.;	  <SM56>	 8/13/93	KW		adding two more smurf wombats;	  <SM55>	 8/12/93	BG		Changed various Cyclone-related boxflags to their official;									names.;	  <SM54>	 8/11/93	KW		made the forSmurf check in GetCPUIDReg dynamic. Currently;									recoginizes Quadra700/900/950 and Centris610/650 quadra800;	  <SM53>	 7/27/93	GMR		Added routine to do a runtime check for BART (on PDM).;	  <SM52>	  7/2/93	PN		Add conditional for export hasCPUIDregs;	  <SM51>	 6/29/93	SAM		(PDW) Added code to check for a cf96 in GetCPUID (for;									PDM/ColdFusion).;	  <SM50>	 6/14/93	kc		Roll in Ludwig.;	   <LW7>	 4/29/93	fau		Updated the Cyclone/Tempest timing to 120ns ROMS for final;									shipment.;	  <SM49>	  6/3/93	SAM		Exporting GetCPUIDReg.;	  <SM48>	 5/10/93	SAM		Added a few nops in the PDM specific CPU ID check.;	  <SM46>	 4/26/93	RC		Get ride of warning due to bra.s;	  <SM45>	 4/21/93	joe		Added hack to GetCPUIDReg for PDM EVT2.  (CPUID register doesn't;									work right, so use extra bits in SCSI DMA Ctl reg to check for;									AMIC2.);	  <SM44>	 4/20/93	joe		Added to PDM-style CPUID reg check.  The old;									long-word-access-only code would read the register, write some;									value back, and re-read the register, making sure that the;									second read yielded the same data as the first.  The PDM-style,;									byte-access CPUID register read code now does this too.;	  <SM43>	 4/20/93	jb		Fixed up the code to work on either a normal or PDM-style CPUID;									register.;	  <SM42>	 3/31/93	chp		Synchronize SuperMario with changes from <LW5>.;	   <LW5>	 2/26/93	fau		Removed support for Cyclone EVT3 and changed all labels having;									MMC with YMCA.;	  <SM41>	 2/23/93	RB		Fixed a check for djMEMC in InitVIAs where it was depending on;									d3 which wasn't set up. Now checking decoder kind in the low;									byte of d2.;	  <SM40>	  2/8/93	rab		Rolled in the following change from Horror for Wombat: <H30>;									11/18/92 BG Modified TestForSonic so that instead of just;									reading a register at SonicBase to determine if Sonic is;									present, we actually WRITE a SW Reset command to Sonic. This;									way, not only do we detect it, but we make sure Sonic is always;									reset when booting/restarting.;	  <SM39>	 1/15/93	PN		In case of Quadra 900 which has a Caboose chip, we do not;									execute the DoEgretInit but do a CudaDone otherwise we kill;									Quadra900.;	  <SM38>	01/09/93	RM/HY	Disable asynchronous messages on Egret based machines. This;									fixes a problem which could potentially causes hangs to occurr;									on restart if enough time elapses before Egret can respond to ;									these messages.  ;	  <SM37>	12/23/92	RC		Added Support for Smurf on Wombat;	  <SM36>	12/17/92	RB		Removed some of the LC930 conditionals. Added back other hasXXXX;									conditionals to make it easier to build 1 off 1 Meg ROMs.;	  <SM35>	12/11/92	FU		Was always checking BoxCyclone33 when programming the YMCA.;	  <SM34>	 12/4/92	fau		Added support for Cyclone40 and Tempest33.;	  <SM33>	11/20/92	fau		Didn't put a ; on one of my comments.;	  <SM32>	11/20/92	fau		Added a TestForMUNI to GetExtHardwareInfo so that Tempest can;									check whether the Nubus adapter is there or not.  Programmed;									MUNI for Tempest.;	  <SM31>	 11/7/92	rab		Roll in Horror changes. Comments follow:;		<H29>	 8/10/92	SWC		Fixed the MSC VIA/RBV initialization to disable slot interrupts.;		<H28>	  7/2/92	ag		Change initial state of the Jaws/dart via2 modemRst bit. It;									should be 0 to insure the modem is in reset when not in use.;									This also avoids current leakage to the modem.;		<H27>	 6/25/92	CCH		Added conditionalized support for Quadra on RISC-based emulator.;		<H26>	  6/4/92	HY		Add ptr to sound primitives vector table in LC product info table.;		<H25>	  6/3/92	BG		Conditionally changed -InitVIAs- temporarily to build the;									correct sequence of code for the BIOS1 chip on Wombat til BIOS;									is revved to have VIA1 work correctly.  This change only takes;									effect if you Build -p -WombatEVT1.;		<H24>	 5/28/92	NJV		Added SoundPlayAndRecord bit to ProductInfo Tables of machines;									that can play and record simultaneously.;		<H22>	05-18-92	jmp		Changed the “sRsrcZydecoDir” name to the more generic;									“sRsrcBFBasedDir” (BF=BoxFlag) name.;		<H18>	  5/3/92	BG		Removed references to hasOrwell2, since it is now superfluous to;									hasOrwell.;		<H17>	 4/24/92	HJR		Added CheckForNiagra so that we may distinguish from;									Jawsdecoder.;	  <SM30>	 11/3/92	SWC		Changed SlotEqu.a->Slots.a.;	  <SM29>	 11/2/92	kc		Make change to prevent unwanted branch island (to data).;	  <SM28>	10/27/92	fau		Rolled in a Horror patch for TestForFPU that also works for;									040's without and FPU.  This is to support Tempest.  Added the;									necessary changes to the programming of the YMCA for Tempest.;	  <SM27>	10/25/92	HY		Add code in jumpintoRom to turn on & grey LC/LC II screen early.;	  <SM26>	10/20/92	fau		Stopped using "MMC/YMCAexists" and replaced by either comparing;									against DecoderKind or by using PSCexists.  Also, changed;									YMCAAddr/MMCAddr to use DecoderAddr.;	  <SM25>	10/18/92	CCH		Added support for PDM and conditionalized support for Smurf.;	  <SM24>	10/12/92	RB		For the 1 Meg LC930 ROM, exclude all code not related to the LC;									hardware.;	  <SM23>	 9/30/92	fau		Added support for Cyclone EVT4.  This involved new DRAM/ROM;									speed values and a modification to GetHardwareInfo so that it;									looks at the CycloneEVT4 product info.;	  <SM22>	 9/25/92	RB		Excluded some functions such as INITVias from executing while;									booting from RAM. Added a ROM base for the LC 2. Hacked;									GetCPUIDReg to return Cyclone when ROMinRAM testing.;	  <SM21>	 8/27/92	CCH		Removed some now obsolete conditionals for Smurf card.;	  <SM20>	 8/25/92	chp		Fix assembler warning.;	  <SM19>	 8/24/92	PN		Take out CycloneboxEVT1;	  <SM18>	 8/20/92	CCH		Don't initialize Orwell when running on a Cub Card.;	  <SM17>	 8/17/92	CCH		Extended Universal support to 96-bits, added GetExtHardwareInfo;									routine to provide dynamic checking for feature existence.;	  <SM16>	08-11-92	jmp		Fixed a problem in the GetCPUIDReg routine where the CACR was;									being trashed; this caused ’030 machines to die before BootBeep.;	  <SM15>	  8/9/92	CCH		Removed uneeded conditionals and  temporarily return a CPU ID;									for RISC cards.;	  <SM14>	 7/28/92	fau		Corrected the Cyclone MMC_DRAMspeed0/1 to point to a 25MHz CPU;									with 60ns DRAM, instead of 25MHz with 80ns DRAM.;	  <SM13>	 7/21/92	kc		Fix duplicate lable.;	  <SM12>	 7/13/92	CCH		Added conditionalized support for Cub Card.;	  <SM11>	 6/30/92	kc		Fix bug introduced with last checkin (trashing d0). ;	  <SM10>	 6/26/92	GS		(RBM)  Add call to CudaInit to perform a SyncAck cycle prior to;									any transaction with Cuda. This will disable all asynchronous;									message sources within Cuda and will prevent any collisions from;									occuring in the low level io primitive routines prior to;									installation of the Cuda manager.;	   <SM9>	 6/21/92	RB		• Added a temporary check for EVT1 Cyclone in InitVIAs and;									CheckBases so that we don't have to support two builds for the;									next few weeks.;	   <SM8>	  6/9/92	kc		Roll in Horror change from UniversalPatch.a,14.;	   <H16>	 5/28/92	BG		Fixed a bug in GetHardwareInfoPatch. If you have the -Ext- bit;									set in your CPU ID register, -GetVIAInputs- gets called to read;									VIA1 to see what machine you really are. However, A1 was a bad;									register to save the A6 return value in. A3 is better.;	   <SM7>	 5/25/92	RB		Changed a couple of branch longs to short branches since the;									code is not in patches anymore. Some VIA1 init code got lost in;									pass <SM5>, so it has been restored now.;	   <SM6>	 5/22/92	RB		Removed an ENDIF;	   <SM5>	 5/22/92	RB		Forgot to add comments in the previous checkin. Added tables for;									Cyclone, checks for MMC which identify a a Cyclone machine (for;									now I think) and got rid of the IF forCyclone changes previously;									made. Added VIA init stuff for Cyclone, its decoder table and;									video info.;	   <SM4>	 5/22/92	RB		Making changes for Cyclone;	   <SM3>	 5/17/92	kc		Roll the Horror changes. Comments follow: • From;									UniversalPatch.a:;	   <H14>	 4/20/92	NJV		Adding changes needed to support Patch ROMs;	   <H13>	 4/13/92	JC		Remove dynamic speed determination from Sonora setup code.;	   <H12>	 2/20/92	JC		Fix register trashing bug in test for Sonic code and remove;									temporary branch around Sonic test.;	   <H11>	 2/14/92	JC		Clean up Sonora Memory controller initialization, dynamically;									determine clock speed, and add TestforSonic code.;	   <T13>	 4/26/91	ag		Relocate the stack pointer after we jump into rom, otherwise a;									berr will cause ram to be written to!;	   <T12>	 4/22/91	ag		added patch to reinitialize berr handler after jump into rom.;									removed aux wait state initialization in jaws.;	   <T11>	 2/16/91	BG		Changed the Orwell initialization to understand 33MHz.;	   <T10>	 1/15/91	HJR		Added new code in memoryCtrlInitPatch for Jaws initialization.;		<T7>	 11/7/90	BG		Made changes for new rev. of Orwell (2) permanent.;		<T4>	10/30/90	BG		Added changes for new rev. of Orwell (2).;		<T3>	10/25/90	CCH		Added support for ReAnimator when forRomulator equate is set.;									• From Univeral.a:;		<H9>	12/16/91	HJR		Export some symbols and introduce Decoder Niagra and Product;									Dartanian into product list. Temporarily use the same routine;									for CheckForJaws and CheckForNiagra until Niagra has some;									distinguishing characteristic.;		<H8>	12/12/91	SWC		Don't touch RvMonP in InitVIAs if we're running on an MSC since;									that register offset is used for, among other things, RAM;									sizing.;		<T9>	 12/7/90	BG		(actually JMA) Added support for dual SCSI buses used on;									Eclipse.  Also - merged CheckForRPU with new CheckForSCSI96;									routine into new patch.;		<T6>	 1/18/90	SWC		Fixed an alignment problem where code grew by 2 bytes in;									TestForIOP. Also changed FMCInit to FMCRPUInit since we don't;									know if we have parity yet.;		<T6>	10/29/90	CCH		Fixed forRomulator conditional statement.;		<T5>	10/25/90	CCH		Added support for ReAnimator when forRomulator equate is set.;	   <SM2>	  4/7/92	JSM		Roll-in revision <63> from Reality:;		<63>	 3/24/92	JSM		Nuke more code names: boxAuroraCX25 is boxMacIIci, boxF19 is;									boxMacIIfx.;		<62>	 1/27/92	KC		Move Allign 16 macro above rombase table.;		<61>	 1/23/92	RB		Changed the order of items in the Decoder lookup table. Changed;									the Eclipse VIA info record.;		<60>	 1/20/92	RB		Backed out to the revision <58>. For some reason making the code;									that sets up a bus error handler a procedure would freeze the;									machine upon startup. Very weird because the problem is not;									obvious. If only that 040 emulator worked...added an ALIGN for;									the 040 emulator.  Got rid of the padForOverpatch at the end of;									the file.;		<59>	 1/15/92	RB		Revisited terror changes. Added a forRomulator change. Made code;									that sets up the buss error handler a subroutine since it gets;									called twice.;		<58>	12/29/91	RB		Added Terror changes and rolled in patches to support Quadras;									and PowerBooks.;		<57>	12/21/91	RB		Need to change boxTim and boxEclipse to the release names.;		<56>	10/17/91	JSM		Get rid of all the stupid conditionals.;		<55>	 10/1/91	JSM		Don’t use onMvMac conditional, Modern Victorian never existed.;		<54>	 10/1/91	JSM		Don’t use eclipseDebug.;		<53>	 9/10/91	JSM		Cleanup header.;		<52>	 1/18/91	KIP		<JDR> Add Sound8BitMono bit to the Universal ROM flags for TIM,;									since it has built-in sound input.;		<51>	10/24/90	JJ		Rex V8: Roll in changes from Rex V8 splitoffs.;		<50>	10/22/90	JJ		Rex V8: Change VISAChipBit to V8ChipBit.;		<49>	 9/25/90	SAM		Changed boxElsie/boxErickson to boxMacLC/boxMacIIsi;		<48>	 9/13/90	MSH		Converted Waimea to TIM.  This involved the boxflag, names, and;									clock/PRAM implementation.;		<47>	  9/1/90	BG		Updated Eclipse-related information to reflect the EVT1 boards.;		<46>	 8/15/90	BG		Fixed an error in the conditionals at the bottom of JumpIntoROM.;		<45>	 8/14/90	BG		Added an address map definition for SONIC on Eclipse. This uses;									the previously unused Address23 in the I/O map tables.;		<44>	 8/14/90	BG		Saved the original bus error vector for the NUB on Eclipse.;		<43>	  8/2/90	CCH		Temporarily cleared hwCfgFPU on Eclipse.;		<42>	 6/25/90	BG		Modified the EclipseNuBus information to correctly reflect the;									fact that slot E is not available on the current prototypes.;		<41>	 6/18/90	CCH		Added eclipse-specific changes, and removed occurences of the;									onEclipse equate.;		<40>	 6/11/90	GA		Correct VideoInfo 24-bit base address for Erickson. Somehow, it;									seemed to get lost from <39>.;		<39>	  6/7/90	HJR		Changes the 24 Bit Address in MDU and Erickson to 32 Bit;									Addresses since the video stuff pulls that address and Quickdraw;									requires it to be a 32 bit address.;		<38>	 5/25/90	MSH		JAWS check was all wrong.  Changed logical 24 Bit address in MDU;									and Erickson to reflect actual 24 Bit address.;		<37>	 5/17/90	JJ		Change address of diagnostic ROM for VISA decoder.;		<36>	 5/14/90	MSH		Moved built in video to logical slot E and the PDS connector to;									slot B.;		<35>	  5/2/90	CV		Updating nuBus slot info to reflect change in the video slot for;									Erickson.;		<34>	  5/1/90	DAF		Updating Erickson VideoInfo for Built-in Video in Slot $E.;		<33>	 4/24/90	DAF		Reordered Elsie VideoInfo records to match new RBVPrimaryInit.a;		<32>	 4/21/90	GMR		Reversed order of entries in RamInfo tables.;		<31>	 4/20/90	JJ		Removed support for VISA 1 from Elsie RAM Info Table.;		<30>	 4/20/90	JJ		Change initial sound volume value for Elsie and Erickson from 2;									to 6.;		<29>	 4/12/90	MSH		Fixed the Waimea clock/PRAM info in tables.;		<28>	 4/11/90	JJ		Change sound volume initilization value from 1 to 2 on Erickson;									and Elsie to avoid BURNIN rack problem.;		<27>	 4/11/90	JJ		Change VIA1Init table for Erickson and Elsie to set DDRA bits;									0:2 to be outputs.;		<26>	  4/4/90	JJ		Modified Elsie Video Information Tables.;		<25>	  4/4/90	MSH		Added Waimea to the tables.  Made the pad bytes at the bottom;									conditional for overpatching only.;		<24>	  4/2/90	djw		Fixup universal NuBusInfo tables for Elsie, Erickson, and;									Eclipse.;		<23>	 3/26/90	CCH		Added sound input to external feature flags for Erickson, Elsie,;									and Eclipse.;		<22>	 3/23/90	JJ		Made RAMInforElsie tables conditional on hasVISA2.;		<21>	 3/22/90	JJ		Fixed bug in JumpIntoROM.  Now relocates pointers to Decoder;									Info and Product Info before "jmp @intoROM(d3.l)".;		<20>	  3/9/90	JJ		Changed RAMInfoElsie table to conform to VISA2 memory;									configurations.;		<19>	 2/23/90	BG		Moved reference to Orwell to before the Glue DecoderTable entry;									since Eclipse/Orwell will pass the GLUE test, but a MacII will;									fail the Orwell test.;		<18>	 2/21/90	BG		Fixed off-by-one error in Orwell setup code.;		<17>	 2/20/90	CCH		Set Eclipse smallest bank size to 4 meg.;		<16>	 2/16/90	BG		Modified TestForFPU to check if we're running on an 040 before;									the SFC check. Running on an 040 implies you have an FPU. The;									SFC check will fail on an 040 because it does not support;									coprocessor communications.  Also modified OrwellDecoderTable to;									include the possibility of a DiagROM, etc.;		<15>	 2/13/90	JJ		Stupid mistake in Version <14>.;		<14>	 2/13/90	JJ		Added VISA chip indicator to External Feature flags in VISA;									decoder table and Elsie information table.;		<13>	  2/9/90	BG		Adding Eclipse-specific hardware information. Also added a;									*CheckForOrwell* routine to determine if we're dealing with;									Orwell decoder. Also added Orwell initialization code in;									JumpIntoROM.;		<12>	  2/7/90	OR		Add CheckForVISADecoder routine and all information tables for;									Elsie.;		<11>	  2/7/90	CV		Rearranged order of CheckFeatures & CheckOptionals to use d1,;									not d3 in TestForFPU. d3 contains warmstart value. Sorry!;		<10>	  2/4/90	GMR		Fixed VIA init table for Erickson, so it properly initializes;									the vACR reg for Egret.;		 <9>	  2/4/90	CV		Removed isUniversal conditional on TestForFPU. Caused HcMac &;									Macpp to fail.;		 <8>	  2/3/90	CV		Added TestForFPU to check for an optional FPU.;		 <7>	  2/1/90	CV		Adding a table for via1 initialization for Erickson. Erickson;									was using the IIci table, but EGRET requires different;									initialization. On Erickson, three lines are used to communicate;									with EGRET and five lines are unconnected.;		 <6>	 1/25/90	GMR		Renamed the ADB/Clock types so they don't conflict with assembly;									conditionals (like iopADB).;		 <5>	 1/15/90	GMR		Added ADB and Clock/Pram bits to External Features longword, to;									help support Erickson/Elsie which use the Egret chip.;		 <4>	 1/11/90	CCH		Added include of “HardwarePrivateEqu.a”.;		 <3>	  1/8/90	CV		Adding table information to allow recognition of Erickson as a;									new CPU. Changing the via1 id value for AuroraSE25 to 0. The;									value it was set to ($16) conflicts with Erickson's cpu id.;		 <2>	  1/2/90	SWC		Changed CheckForOSSFMC to work with TI as well as NCR parts.;	   <2.5>	11/15/89	GMR		Added TestForRPU to check for the optional RPU chip on OSS/FMC,;									changed the decoder table for OSS/FMC and the InfoF19 table.;									Fixed bug in TestForIOP when setting increment mode.;	   <2.4>	 8/22/89	BBM		UGLY HACK. made a quick patch to the bbu table just to get emacs;									working.;	   <2.3>	 7/25/89	CCH		Changed JumpIntoROM to preserve the value in the VBR if;									forRomulator is true.;	   <2.2>	 7/16/89	GGD		Changed the product info for the former Aurora 16 to be the same;									as Aurora 25, but without the PGC option. Added a flag to the;									ExtValid flags of Aurora 25 to indicate that it has the PGC;									option installed. Renamed AuroraCX25 to be MacIIciPGC and;									AuroraCX16 to be MacIIci.;	   <2.0>	 6/30/89	GGD		Initialized the new DefaultRSRCs field in the ProductInfo;									record. Added some padding to allow for overpatching. Added;									NuBus Slot Info.;	  <•2.1>	 6/30/89	GGD		Changed resource combos from 0,1 to 1,2;	   <2.1>	 6/30/89	GGD		Changed the DefaultRSRCs from {0,1} to {1,2};	   <2.0>	 6/30/89	GGD		Initialized the new DefaultRSRCs field in the ProductInfo record.;									Added some padding to allow for overpatching.  Added NuBus Slot Info.;	   <1.9>	 6/12/89	djw		Added slot video pram addr to video table;	   <1.8>	 6/11/89	GGD		Added Video, Ram Bank, hwCfgFlags, and ROM85 info to tables.;									Updated GetHwInfo to also return the hwCfgFlags. Updated VIA2;									initialization values.;	   <1.7>	 6/10/89	GGD		Added info for new aurora boxes. GetHwInfo now clears the beok;									bit when done.;	   <1.6>	 5/29/89	GGD		Fixed wrong register bug in FMC initialization. Removed the Test;									in Ram checks.;	   <1.5>	 5/20/89	GGD		Updated to use new IOP equates from HardwareEqu, deleted local;									IOP equates.;	   <1.4>	 5/16/89	rwh		separated out Mac II Via 2 info to set MMU control bit as an;									output.;	   <1.3>	 5/15/89	GGD		Changed RBV BufB initialization to disable Par.Test~ so that;									correct parity will be generated.;	   <1.2>	 5/10/89	CCH		Added a test that will make the vFC3 bit an output when running;									in RAM.;	   <1.1>	  5/1/89	GGD		Fixed conditionals in CheckForGLUE so that NuMac will work;									again.;	   <1.0>	 4/30/89	GGD		Adding to EASE for the first time. Support for Universal ROM.;__________________________________________________________________________________________________			print	off			LOAD	'StandardEqu.d'			INCLUDE	'HardwarePrivateEqu.a'			INCLUDE	'UniversalEqu.a'			INCLUDE	'PowerPrivEqu.a'			INCLUDE	'STEqu.a'			INCLUDE	'Slots.a'			INCLUDE	'DepVideoEqu.a'								; <58> rb			INCLUDE	'EgretEqu.a'								; <SM38>			print	on			print	nomdir			machine	mc68030			mc68881												; needed for TestForFPU	<SM28>		Universal	proc	export			import	CPUIDProductLookup,ProductLookup,DecoderLookup			import	BaseOfRom, CudaInit			import	SendEgretCmd								; <SM38>			EXPORT	CheckForUnknown			export	GetHardwareInfo			export	GetExtHardwareInfo													; <SM17>			export	JumpIntoROM			export	InitVIAs			EXPORT	CheckNextMap,MapFound						;<SM31>								;	<H2>	IF hasCPUIDRegister THEN			;												; <SM24> rb <SM36> rb			EXPORT	GetCPUIDReg									;<SM49>	ENDIF;_______________________________________________________________________;;  Routine:		JumpIntoROM;  Inputs:		A6 - return address;;  Outputs:		A0 - Pointer to DecoderInfo record for this machine;				A1 - Pointer to ProductInfo record for this machine;				D0 - Flags indicating which base addresses are valid;				D1 - Flags indicating which external features are valid;				D2 - Bits 31..16, hwCfgFlags info (possibly unknown);				D2 - Bits 15..8, BoxFlag info (possibly unknown);				D2 - Bits  7..0, Address Decoder Kind (zero if unknown);;  Destroys:	A2,A3,SP,D3,D4,D5;  Called by:	BSR6;;  Function:	Locates the System ROM, which we are executing out of,;				but which may be mapped down to zero (overlay mode).;				We will jump into the ROM at its normal base address,;				and then initialize the VIAs to disable overlay.;;_______________________________________________________________________			with	DecoderInfo,ProductInfo,DecoderKindsJumpIntoROM			move.l	#aStack,sp			; set stack pointer value			movea.l	a6,a4				; save the return address;	Setup VBR to point to a temporary Bus Error handler, because we need to use;	Bus Errors to destinguish the address decoders on the 68020/030 machines.			lea		GotBusError,a0		; get the handler address			move.l	a0,d0				; value to search for@loop		cmp.l	-(a0),d0			; check for a match			beq.s	@found				; use the entry if it matches			tst.l	(a0)				; check for end of list			bne.s	@loop				; if not, keep searching			lea		BusErrVct,a0		; set it up in RAM			move.l	d0,(a0)				; assume ram based, insert entry@found		subq.w	#BusErrVct,a0		; make it the bus error vector		  IF forRomulator THEN			; 										<T5>			TestInRAM	a3				; are we in RAM?			beq.s	@notInRAM			;			movec	vbr,d5				; save contents of vbr					<T5>		  	movec	vbr,a3				; get vbr address in a1								move.l	BusErrVct(a3),d2	; save original (read: NUB) buserr vect				movec	d2,USP				; ... in an out-of-the-way place				move.l	BusErrVct(a0),BusErrVct(a3)	; copy old vector to new table	@notInRAM		  ELSE							; 										<T6> 			movec.l	a0,vbr				; install the vector table		  ENDIF@TryAgain	moveq.l	#0,d2				; figure it out from scratch			bsr6	GetHardwareInfo		; figure out what we are running on			btst.l	#ROMExists,d0		; see if we have a ROM			beq.s	@TryAgain			; if not, we're screwed, but try again anyway;	Now figure out what the new base of ROM should be,		IF forRomulator THEN			;										<T5>			TestInRam	A2				; running in RAM?						<T5>			bne.s	intoROM				; yep, skip this..						<T5>		endif			biglea	BaseOfRom,a2		; where we currently start			move.l	ROMAddr(a0),d3		; where we want to start (from savepatch)			<3> <cv>			sub.l	a2,d3				; offset we need to add to relocate					<3> <cv>			adda.l	d3,a0				; relocate decoder info pointer						<3> <cv>			adda.l	d3,a1				; relocate product info pointer						<3> <cv>	;	if not forRamRom then			; ••• need to make this a runtime check •••			adda.l	d3,a4				; relocate the return address			jmp		intoROM(d3.l)		; relocate our program counter	;	endifintoROM									; now we are in ROM;	Setup VBR to point to a temporary Bus Error handler, because we need to use;	Bus Errors to destinguish the address decoders on the 68020/030 machines.			adda.l	d3,sp				; relocate the stack to rom addresses			<T13>			lea		GotBusError,a0		; get the handler address						<T12>			move.l	a0,d0				; value to search for							<T12>@loop		cmp.l	-(a0),d0			; check for a match								<T12>			beq.s	@found				; use the entry if it matches					<T12>			tst.l	(a0)				; check for end of list							<T12>			bne.s	@loop				; if not, keep searching						<T12>			lea		BusErrVct,a0		; set it up in RAM								<T12>			move.l	d0,(a0)				; assume ram based, insert entry				<T12>@found		subq.w	#BusErrVct,a0		; make it the bus error vector					<T12>		  IF forRomulator THEN			; 												<T12>			TestInRAM	a3				; are we in RAM?								<T12>			beq.s	@notInRAM			;												<T12>			movec	vbr,d5				; save contents of vbr							<T12>		  	movec	vbr,a3				; get vbr address in a1							<T12>						move.l	BusErrVct(a3),d2	; save original (read: NUB) buserr vect			<T12>			movec	d2,USP				; ... in an out-of-the-way place				<T12>			move.l	BusErrVct(a0),BusErrVct(a3)	; copy old vector to new table			<T12>@notInRAM		  ELSE							; 												<T12> 			movec.l	a0,vbr				; install the vector table						<T12>		  ENDIF@TryAgain	moveq.l	#0,d2				; figure it out from scratch					<T12>			bsr6	GetHardwareInfo		; figure out what we are running on				<T12>			btst.l	#ROMExists,d0		; see if we have a ROM							<T12>			beq.s	@TryAgain			; if not, we're screwed, but try again anyway	<T12>		  	IF NOT ROMinRAM THEN				;												<SM22> rb			bsr6	InitVIAs			; initialize the VIAs (turns off vOverlay)		<T12>	ENDIF								;												<SM22> rb;	Here, after running GetHardwareInfo we have:										<SM10>{rbm}<2>;																						<SM10>{rbm}<2>;  		a0 - Pointer to table of base addresses											<SM10>{rbm}<2>;		a1 - Pointer to ProductInfo record for this machine								<SM10>{rbm}<2>;		d0 - Flags indicating which base addresses are valid							<SM10>{rbm}<2>;		d1 - Flags indicating which external features are valid							<SM10>{rbm}<2>;		d2 - Bits 31..16, hwCfgFlags info (possibly unknown)							<SM10>{rbm}<2>;		d2 - Bits 15..8, BoxFlag info (possibly unknown)								<SM10>{rbm}<2>;		d2 - Bits  7..0, Address Decoder Kind (zero if unknown)							<SM10>{rbm}<2>;																								<SM10>{rbm}<2>;	CudaInit implies a SyncAck cycle which synchronizes Cuda to the system and disables			<SM10>{rbm}<2>;	all asynchronous messages sources (Auto Poll, RTC, Power Messages, Unknown).  No further	<SM10>{rbm}<2>;	individual disabling of asynchronous message sources is required. (R. Montagne 5/25/92)		<SM10>{rbm}<2>;																								<SM10>{rbm}<2>			move.l	d0,d3				; save a copy of d0								<SM11>			move.l	#EgretFWMask,d0		; mask for Egret Firmware						<SM10>{rbm}<2>			and.l	d1,d0				; isolate the field								<SM10>{rbm}<2>			sub.l	#Egret8,d0			; see if we have Egret FW						<SM10>{rbm}<2>			beq.w	@DoEgretInit		; do Egret 8 FW INIT, LC/si			<SM10>{rbm}<2>	<SM38>			sub.l	#Egret8,d0			; see if we have Caboose FW						<SM10>{rbm}<2>			beq.s	@CudaDone			; just exit Quadra900		<SM10>{rbm}<2>	<SM39> PN			sub.l	#Egret8,d0			; see if we have Cuda FW						<SM10>{rbm}<2>			bne.s	@CudaDone			; if not, just exit								<SM10>{rbm}<2>	IF NOT ROMinRAM THEN				;												<SM22> rb			BigBSR6	CudaInit			;Setup Cuda Sysnc Ack with System				<SM10>{rbm}<2>			bra.s	@CudaDone			;														<SM38>	ENDIF								;												<SM22> rb@DoEgretInit							;														<SM38>			movea.l	DecoderInfo.VIA1Addr(a0),a1	; get VIA 1 base address						<SM38>			move.w	#4000,d0 			;														<SM38>@wait			eieioSTP				tst.b	(a1)				; sync to hardware for 1.2µS per access					<SM38>					dbra	d0,@wait			; Egret must see idle before command, it's busy			<SM38>										; doing ADB reset for 3mSec so delay in idle state		<SM38>		eieioSTP				move.l	#(NopCmd<<16)|pseudoPkt,d0 ;												<SM38>			moveq	#0,d2				; no bytes to send										<SM38>			bsr6	SendEgretCmd		; send the command to disable async. messages			<SM38>			moveq.l	#0,d2				; figure it out from scratch							<SM38>			bsr6	GetHardwareInfo		; restore all the registers we trashed 					<SM38>			move.l	d0,d3				; by calling SendEgretCmd								<SM38>@CudaDone			move.l	d3,d0				; restore d0									<SM11>		IF forSTP601 THEN			jmp		(a4)				; Orwell,djmec already inited...return	ENDIF	IF hasOSS THEN						;												<SM36> rb			btst.l	#OSSExists,d0		; see if we have an OSS			beq.s	@noOSS				; if not, don't need to init it			movea.l	OSSAddr(a0),a3		; get the OSS base address			move.b	#OSSRomInit,OSSRomCntl(a3)	;overlay off, 2 ROM wait states@noOSS	ENDIF								;												<SM36> rb		IF hasFMC THEN						;												<SM36> rb			btst.l	#FMCExists,d0		; see if we have a FMC			beq.s	@noFMC				; if not, don't need to init it			movea.l	FMCAddr(a0),a3		; get the FMC base address			move.w	#FMCRPUInit,d3		; initial value for config register		<T6>			moveq.l	#16-1,d4			; loop counter to load 16 bits@FMCload	move.b	d3,FMCConfig(a3)	; load in a bit							<1.6>			lsr.w	#1,d3				; put next bit into position			dbra	d4,@FMCload			; repeat till all bits loaded			move.b	d3,FMCLatch(a3)		; latch the config data@noFMC	ENDIF								;												<SM36> rb		IF hasSonora THEN					; begin hasSonora								<H11>.Start <SM36> rb			move.l	ExtValid(a1),d3		; get External Flags								btst.l	#SonoraExistsBit,d3	; see if we have an Sonora ASIC						beq		@noSonora			; IF we have a Sonora THEN						lea		CPUIDReg,A2			;get value in CPU ID Reg				<H13>.Start			move.l	(a2),d3			and.l	#$0000ff00,d3		; only look at CPU ID reg Design Center Value			movea.l	RBVAddr(a0),a2			; get base of RBV/VIA2 Registers			move.b	#0,SonoraVRAMSize(a2) 	;force VRAM to 256k for now			move.b	#$40,SonoraRAMSize(a2)	;force to 25 Mhz PDS slot speed			<SM4> rb			move.b	#3,SonoraSpeedReg(a2) 	;Set up for 33Mhz timing			cmpi.w	#cpuIDHiEnd,d3			; check if we are a high end box			bge.s	@noSonora				; branch if high end box			lea		CPUIDReg,A2				;get value in CPU ID Reg				<H27><SM31>			move.l	(a2),d3					; 										<H27><SM31>			and.w	#cpuIDFieldMask,d3		; d3 = ID field of CPU ID Register 		<H26><SM31>			cmpi.w	#Vail33IDField,d3		; is it a 33 MHz Vail ?? 				<H26><SM31>			beq.s	@noSonora				; yep, don't change the timing 			<H26><SM31>			movea.l	RBVAddr(a0),a2			; get base of RBV/VIA2 Registers		<H29><SM31>			move.b	#2,SonoraSpeedReg(a2) 	;Set up for 25Mhz or less timing		<H13>.End@noSonora									; end hasSonora 						<H11>.End	ENDIF									;										<SM36> rb	IF hasOrwell THEN					;											<SM36> rb										; Eclipse/040 Memory Controller INIT			cmp.b	#OrwellDecoder,DecoderKind(a1)	; see if we have an Orwell Mem. Cntrlr			bne.s	@noOrwell			; NOPE ... we don't need to init. it			cmp.b	#boxRiscQuadra700,ProductKind(a1)	; see if we're on a RISC Quadra	<SM54>			beq.s	@noOrwell			; don't reset orwell then						<SM54>			cmp.b	#boxRiscQuadra900,ProductKind(a1)	; see if we're on a RISC Quadra	<SM54>			beq.s	@noOrwell			; don't reset orwell then						<SM54>			cmp.b	#boxRiscQuadra950,ProductKind(a1)	; see if we're on a RISC Quadra	<SM54>			beq.s	@noOrwell			; don't reset orwell then;	Set up various Orwell configuration registers to useable values.					movea.l	DecoderAddr(a0),a3	; get base address of Orwell regs		<SM17>			move.l	#ORWELL_INIT25,d4	; get Orwell 25MHz initialization value	<T11>			moveq.l	#OrCfgRegSize-3,d3	; (34-3 = 34-1-2) -1 for DBRA,			<T4><T7>										;  -2 because 32-bit max constant size	<T4>			movea.l	VIA2Addr(a0),a2		; get base of VIA2 to check for 33 MHz	<T11>			bclr	#v2Speed,VDirB(a2)	; make sure the 25/33MHz direction=input<T11>			btst	#v2Speed,VBufB(a2)	; are we running at 25 MHz or 33 MHz?	<T11>			beq.s	@25MHz				; IF CPU_Speed == 33MHz THEN			<T11>			move.l	#ORWELL_INIT33,d4	;   get Orwell 33MHz init. value		<T11>@25MHz									; ENDIF									<T11>;	Note - the above configuration constants are ONLY accurate for non-parity	<T11>;			operation.															<T11>			lea		OrBankBCfgAddr(a3),a2; get address of config regs.			<T11>			@OrwellINIT	move.l	d4,(a2)+			; send that bit out there						lsr.l	#1,d4				; get the next bit in position					dbra	d3,@OrwellINIT		; repeat til all bits loaded		;	now move in the last two bits that didnt fit in the original 32-bit constant<T4><T7>			moveq	#ORINITWaitWr1,d4	; get initial value of optional write wait state<T4><T7>			move.l	d4,(a2)+			; ... and send that bit out				<T4><T7>;	RAS precharge (the last bit) is done separately below because it too relies	<T11>;	on the clock speed the processor is running at.								<T11>;	Now hit the associated latch registers to actually store the values					move.l	d3,OrLoadBanks(a3)	; initialize DRAM bank starting addrs			move.l	d3,OrLoadSpeeds(a3)	; initialize Clock/DRAM/ROM speeds				move.l	d3,OrLoadRefresh(a3); initialize refresh rate						move.l	d3,OrLoadParity(a3)	; initialize parity on/off + type				move.l	d3,OrLoadMode(a3)	; initialize page mode (on/off)			<T4><T7>			move.l	d3,OrLoadWaitStates(a3); initialize optional wait states	<T4><T7>;	RAS Precharge timing is different depending on 25/33 MHz.			move.l	OrClkSpeedAddr(a3),d4; now that clock speed is set, get it	<T11>			btst	#0,d4				; only LSBit is valid from each reg addr<T11>			beq.s	@use33MHzvalue		; IF Clock_Speed == 25MHz THEN			<T11>			moveq	#ORINITRAS25,d4		;   get value of 25 MHz RAS precharge	<T4><T7><T11>			bra.s	@initRAS			;   and get on with it					<T11>@use33MHzvalue							; ELSE									<T11>			moveq	#ORINITRAS33,d4		;   get value of 33 MHz RAS precharge	<T4><T7><T11>@initRAS								; ENDIF			move.l	d4,(a2)				; ... and finish init of config reg		<T4><T7>			move.l	d3,OrLoadPrecharge(a3); initialize RAS precharge (on/off)	<T4><T7>@noOrwell	ENDIF								;										<SM36> rb		IF hasJaws THEN						;										<SM36> rb			btst.l	#JAWSExists,d0		; see if we have a JAWS					<T10> HJR			beq.s	@noJAWS				; if not, don't need to init it			movea.l	JAWSAddr(a0),a2		; get base address of Jaws regs						movea.l	a2,a3				; copy the register									adda.l	#JAWSGetCPUClock,a3	; get address of CPU clock register			move.b	(a3),d3				; read CPU clock register			andi.b	#1,d3				; clear the top bits			move.b	d3,JAWSRAMWaitS(a2)	; set ram wait states according to the speed register@noJAWS	ENDIF								;										<SM36> rb		IF hasYMCA THEN										;												<SM36> rb			cmp.b	#YMCADecoder,DecoderKind(a1)		; Do we have a YMCA								<SM26> fau start			bne		@noYMCA								; Not a YMCA									<SM26> fau end			Move.l	DecoderAddr(a0),A2					; Get Base of YMCA.								<SM23> <SM26> <SM34>			Cmp.b	#BoxQuadra840AV,ProductKind(a1)		; Are we running on a Cyclone40					<SM34> <LW2><SM55>			Beq.s	@DoCyclone40						; if so, go program it							<SM34>			Cmp.b	#BoxCyclone33,ProductKind(a1)		; Are we running on a Cyclone33					<SM34> 			Beq.s	@DoCyclone33						; if so, go program it							<SM34>			Cmp.b	#BoxTempest33,ProductKind(a1)		; Are we running on a Tempest25					<SM34> <LW2> 			Beq.s	@DoTempest33						; if so, go program it							<SM34>			Cmp.b	#BoxCentris660AV,ProductKind(a1)	; Are we running on a Tempest25					<SM34> <LW2><SM55>			Beq		@DoTempest25						; if so, go program it							<SM34>			Bra		@noYMCA								; Not a Cyclone Type Machine				@DoCyclone40			Move.l	#0,YMCA_DRAMspeed0(A2)				; Set DRAM speed to 60ns with a 40MHz CPU		<SM34><LW7>			Move.l	#-1,YMCA_DRAMspeed1(A2)				;												<SM34><LW7			Move.l	#0,YMCA_CPUspeed0(A2)				; Set CPU Speed to 40 MHz						<SM34><LW7			Move.l	#-1,YMCA_CPUspeed1(A2)						Move.l	#0,YMCA_ROMspeed0(A2)				; Set ROM speed to 127ns (7 cycles).			<SM34><LW7>			Move.l	#0,YMCA_ROMspeed1(A2)				;												<SM34><LW7>			Move.l	#-1,YMCA_ROMspeed2(A2)				;												<SM34>;  Program MUNI if it exists			bsr6	GetExtHardwareInfo					; Get the bits for extended features 32-63		<SM34>			beq		@NoYMCA								; No MUNI here									<SM34>			Move.l	#$1c,MUNIBase+MUNI_Control			; Set MUNI for 33MHz.							<SM34>			Bra.s	@noYMCA								; Skip over Tempest programming					<SM34>@DoCyclone33@DoTempest33											;												<SM34>			Move.l	#-1,YMCA_DRAMspeed0(A2)				; Set DRAM speed to 60ns with a 33MHz CPU		<SM23>			Move.l	#0,YMCA_DRAMspeed1(A2)				;												<SM23>						Move.l	#-1,YMCA_CPUspeed0(A2)				; Set CPU Speed to 33 MHz						<SM23> 			Move.l	#0,YMCA_CPUspeed1(A2)						Move.l	#-1,YMCA_ROMspeed0(A2)				; Set ROM speed to 125 (6 cycles).				<SM23> <LW7>			Move.l	#-1,YMCA_ROMspeed1(A2)				;												<SM23> <LW7>			Move.l	#0,YMCA_ROMspeed2(A2)				;												<SM23> <LW7>		;  Program MUNI if it exists			bsr6	GetExtHardwareInfo					; Get the bits for extended features 32-63		<SM32>			beq.s	@NoYMCA								; No MUNI here									<SM32>			Move.l	#$18,MUNIBase+MUNI_Control			; Set MUNI for 33MHz.							<SM23>			Bra.s	@NoYMCA								; Skip over Tempest programming					<SM26>			@DoTempest25			Move.l	#0,YMCA_DRAMspeed0(A2)				; Set DRAM speed to 60ns with a 25MHz CPU		<SM26><LW7>			Move.l	#0,YMCA_DRAMspeed1(A2)				;												<SM26><LW7>						Move.l	#0,YMCA_CPUspeed0(A2)				; Set CPU Speed to 25 MHz						<SM26><LW7>			Move.l	#0,YMCA_CPUspeed1(A2)			Move.l	#0,YMCA_ROMspeed0(A2)				; Set ROM speed to 140ns (5 cycles).			<SM26><LW7			Move.l	#-1,YMCA_ROMspeed1(A2)				;												<SM26>			Move.l	#0,YMCA_ROMspeed2(A2)				;												<SM26>;  Program MUNI if it exists			bsr6	GetExtHardwareInfo					; Get the bits for extended features 32-63		<SM32>			btst.l	#MUNIExists-32,d0					; Normalize MUNIExists since it's in 32-63		<SM32>			beq.s	@NoYMCA								; No MUNI here									<SM32>			Move.l	#$14,MUNIBase+MUNI_Control			; Set MUNI for 25MHz.							<SM32>	@NoYMCA	ENDIF												;												<SM36> rb		IF hasVisaDecoder THEN							;														<SM36> rb			cmp.b	#VISADecoder,DecoderKind(a1)	; do we have a VISA										<SM27>			bne.s	@noVISA							; if not don't do anything								<SM27>;																											<SM27>;  VISA machines need there screens greyed out earlier than primary init time								<SM27>;  to avoid garbage being left over on the screen from a previous reboot									<SM27>						move.l	VDACAddr(a0),a2			; get base address of Color Table chip							<SM27>			move.l	a2,a3					; save base address in a3										<SM27>			clr.b	V8DACwCntlReg(a2)		; clears the overlay enable bit and puts ariel in slave mode	<SM27>;											; to insure all outputs are off while CLUT is being filled		<SM27>			adda	#V8DACwDataReg,a2		; point to data register										<SM27>			clr.b	V8DACwAddReg-V8DACwDataReg(a2)	; start at the beginning of CLUT, 4-bit mode			<SM27> 			move.b	#$7F,d3					; get a 50% value												<SM27>			move	#$FF,d4					; get count														<SM27>@Repeat		move.b	d3,(a2)					; put red (CLUT autoincrements destination address)				<SM27>			move.b	d3,(a2)					; put green														<SM27>			move.b	d3,(a2)					; put blue														<SM27>			dbra	d4,@Repeat 				;																<SM27>			ori.b	#$08,V8DACwCntlReg(a3)	; turn video on by putting machine in master mode 				<SM27>				@noVISA	ENDIF									;																<SM36> rb		IF hasDJMEMC THEN						;									<SM36> rb;	djMEMC Configuration Register initialization								<H18> thru next <H18>;	(Done here so that it isn't done multiple times in SizeMemPatch)			<SM30> begin			move.l	ExtValid(a1),d3			; get External Flags			btst.l	#djMEMCChipBit,d3		; see if we have a djMEMC			beq		@nodjMEMC				; IF we have a djMEM THEN			cmp.b	#boxRiscCentris650,ProductKind(a1)			; see if we're on a RISC Wombat Centris650 	<SM54>			beq		@nodjMEMC									; don't reset djMEMC then					<SM54>			cmp.b	#boxRiscQuadra800,ProductKind(a1)			; see if we're on a RISC Wombat Quadra800 	<SM54>			beq		@nodjMEMC									; don't reset djMEMC then					<SM54>			cmp.b	#boxRiscCentris610,ProductKind(a1)			; see if we're on a RISC Wombat Centris610 	<SM54>			beq		@nodjMEMC									; don't reset djMEMC then					<SM54>;	Set up djMEMC+BIOS Configuration Registers:;	-------------------------------------------;;	Get machine type + CPU speed information from VIA1;;		Useful VIA1 PortA bits to read:  PA6, PA4, PA2, PA1  ($56);;			PA6      = Lego (1), or Frigidaire (0) plastics for Wombat;			PA4, PA2 = CPU Speed.  0=20MHz, 1=25MHz, 2=33MHz, 3=40MHz;			PA1      = WLCD (0) or NOT! [Reserved] (1);;		Retrieve CPU Speed information from VIA1 Port A			move.l	VIA1Addr(a0),a2				; get VIA1 address to get machine/cpu_speed info			moveq	#%00101000,d3				; force VIA1 VDirA to have the correct directions	eieioSTP			move.b	d3,VDirA(a2)				; ... so we can read the CPU ID extension info			moveq	#%00010100,d3				; get VBufA, bits PA4, PA2 (dont need PA6, PA1)	eieioSTP			and.b	VBufA(a2),d3				; get plastics_type/cpu_speed information@hasValue	lsr.b	#2,d3						; shift over to get PA2 in LSBit			btst	#4-2,d3						; test PA4.  remember it's been shifted from bit pos. 4->2			beq.s	@PA4IsZero					; if its already zero, don't do anything			bset	#1,d3						; otherwise move it down to correct place for indexing@PA4IsZero	andi.b	#$03,d3						; make sure ONLY bottom 2 bits are set			moveq.l	#-1,d4						; initial offset into @MachineTbl-one_entry				<H35> thru next <H35> <SM57>@nextEntry	addq.l	#1,d4						; get next entry			tst.w	(@MachineTbl,d4.w*2)		; if entry is zero, you've hit EndOfTable			beq.s	@unknownMachine				; deal with unknown machine			moveq.l	#%01010110,d0				; CPU ID mask value for VIA	eieioSTP			and.b	VBufA(a2),d0				; get CPU ID value			cmp.b	(@MachineTbl+1,d4.w*2),d0	; is it this machine?			bne.s	@nextEntry					; no, try again			LEA		@djConfigTable,A3			; assume original table			move.b	(@MachineTbl,d4.w*2),d0		; check whether we're an Original or a Bumped machine			beq.s	@doIt						; 0=Original, use @djConfigTable.@unknownMachine									; SpeedBump or Unknown machine, assume SpeedBump			LEA		@BumpConfigTable,A3			; use SpeedBump configuration table@doIt			LEA		MEMCAddr,A2					; Get djMEMC base			move.w	(a3,d3.w*2),d0				; use CPU speed as index into table for config value	<H35>	<SM57>			MOVE.L	D0,MEMCconfig(A2)			; set up configuration register			move.w	(@djRefreshTable,d3.w*2),d0	; also use CPU speed as index into refresh period table			MOVE.L	D0,MEMCRefresh(A2)			; set up refresh period			LEA		BIOSAddr,A2					; get base of BIOS			MOVE.L	BIOS_Config(A2),d0			; get Config register value			andi.b	#$F7,d0						; drop old D0{0:0} value			or.b	(@BIOS_Config,d3.w),d0		; only change bit 0 of this register			MOVE.L	d0,BIOS_Config(A2)			; and write it out (only bottom 8-bits "stick")			move.w	(@BIOS_Timeout,d3.w*2),d0	; get watchdog timer timeout count-down value			MOVE.L	d0,BIOS_Timeout(A2)			; and and write this out			bra.s	@nodjMEMC					; finished with memory controller initialization;	djMEMC Configuration register initialization values for different CPU speeds;;		[ See the djMEMC ERS for a full description of the Configuration Register ]			align	4							; longword align;		djMEMC Configuration Register initialization values@djConfigTable@dj20Config		dc.w	%0000000100000001		; fastwr=1, ROMspeed=1@dj25Config		dc.w	%0000000000011010		; drpchg=1, drpw=1, ROMspeed=2@dj33Config		dc.w	%0000000010100011		; mhz33=1, cyc23ta=1, ROMspeed=3							<H24>@dj40Config		dc.w	%0000001011110100		; dwcpw=1, mhz33=1, drcpw=1, cyc2ta=1, drpchg=1, ROMspeed=4	<H22>;		DRAM refresh cycle times assuming a 15.6µs refresh period				<H25>;		(Refresh = (MHz * 15.6 ) - 27).  Fractional parts are rounded DOWN		<H25>@djRefreshTable@dj20Refresh	dc.w	285						; (20MHz * 15.6µs) - 27			<H25>@dj25Refresh	dc.w	363						; (25MHz * 15.6µs) - 27			<H25>@dj33Refresh	dc.w	487						; (33MHz * 15.6µs) - 27			<H25>@dj40Refresh	dc.w	597						; (40MHz * 15.6µs) - 27			<H25>;	BIOS Configuration Register initialization values							<h28>@BIOS_Config@BIOS_Config20	dc.b	%00000001				; BCLK_25 = 1					<H28>@BIOS_Config25	dc.b	%00000001				; BCLK_25 = 1					<H28>@BIOS_Config33	dc.b	0						; BCLK_25 = 0					<H28>@BIOS_Config40	dc.b	0						; BCLK_25 = 0					<H28>;	BIOS watchdog timer timeout count-down value								<H28>@BIOS_Timeout@BIOS_Timeout20	dc.w	$0280					;								<H28>@BIOS_Timeout25	dc.w	$01E0					;								<H28>@BIOS_Timeout33	dc.w	$00D5					;								<H28>@BIOS_Timeout40	dc.w	0						;								<H28>;	Table for determining whether or not to use "SpeedBump"ed Config values		<H35> thru next <H35>	<SM57>@DJ_ORIG		EQU		0@DJ_BUMP		EQU		1@MachineTbl				; Type   CPU VIA ID				dc.b	@DJ_ORIG,%00010010		; 33MHz Frigidaire package (Quadra 800)					<SM60>				dc.b	@DJ_BUMP,%00010110		; 40MHz Frigidaire package (unreleased)					<SM60>				dc.b	@DJ_ORIG,%01000000		; 20MHz WLCD (Centris 610)				dc.b	@DJ_BUMP,%01000100		; 25MHz WLCD (Quadra 610)				dc.b	@DJ_BUMP,%01010000		; 33MHz WLCD (unreleased)								<SM60>				dc.b	@DJ_ORIG,%01000110		; 25MHz Lego package (Centris 650)				dc.b	@DJ_BUMP,%01010010		; 33MHz Lego package (Quadra 650)				dc.b	@DJ_BUMP,%01010110		; 40MHz Lego package (Quadra 650 SpeedBump, unreleased)	<SM60>				dc.b	@DJ_ORIG,0				; if here, this is EndOfTable												; VIA CPUID of 0 is a reserved (unused) machine.;	Configuration register values for SpeedBumped machines (by clock speed)@BumpConfigTable@bump20Config	dc.w	%0000000100000001		; fastwr=1,                                              ROMspeed=1@bump25Config	dc.w	%0000000000011010		;                                      drpchg=1, drpw=1, ROMspeed=2@bump33Config	dc.w	%0000000011111011		;          mhz33=1, drcpw=1, cyc2ta=1, drpchg=1  drpw=1, ROMspeed=4	<H24>@bump40Config	dc.w	%0000001011111100		; dwcpw=1, mhz33=1, drcpw=1, cyc2ta=1, drpchg=1, drpw=1, ROMspeed=5	<H22>												;								<H35>		<SM57>@nodjMEMC										;								<SM30> end	ENDIF								;										<SM36> rb	; =======================================================================================================;	Pratt Configuration Register initialization								<K4> thru next <K4>;	(Done here so that it isn't done multiple times in SizeMemPatch)	IF hasPratt THEN	    IF isUniversal THEN					;			cmp.b	#PrattDecoder,DecoderKind(a1)	; do we have a Pratt										<SM27>			BNE.S	@NotPratt				; IF we have a Pratt THEN	    ENDIF								; 	{ isUniversal }			MOVE.B	#(1<<WhitneySWIMReset)|\; 	Clear the reset line to swim					(1<<WhitneyEnetReset)\	; 	Clear the reset line to Sonic					,WhitneyPwrCtl			; @NotPratt	ENDIF									; { hasPratt }						<K4>; =======================================================================================================		IF	forRomulator THEN			; 										<T3>			TestInRAM	a3				; are we in RAM?			beq.s	@notInRAM2			;			movea.l	d5,a3				; get location of original VBR			<T3>			movec	USP,d5				; retrieve original buserr value		<T3>			move.l	d5,BusErrVct(a3)	; and restore it in the exception table	<T3>			movec	a3,vbr				; restore vbr							<T3>@notInRAM2		ENDIF							; { forRomulator }						<T3>			jmp		(a4)				; all inited, return		ALIGN	16						; <60><62> rb, for the 040 emulator...			dc.l	0,0,0,0								; end of list			dc.l	(GotBusError-BaseOfRom)+$40A00000	; base of Elsie II ROM			<SM22> rb			dc.l	(GotBusError-BaseOfRom)+$00A00000	; base of Elsie ROM		<51>			dc.l	(GotBusError-BaseOfRom)+$40000000	; alternate base of normal ROM <58> rb			dc.l	(GotBusError-BaseOfRom)+$40800000	; base of normal ROM			dc.l	(GotBusError-BaseOfRom)+$00000000	; base of overlay ROM		GotBusError	btst.l	#beok,d7			; indicate that bus error occured			move.l	a5,a7				; restore stack			rts6						; return;_______________________________________________________________________;;  Routine:		InitVIAs;  Inputs:		A0 - Pointer to table of base addresses;				A1 - Pointer to ProductInfo record for this machine;				D0 - Flags indicating which base addresses are valid;				D1 - Flags indicating which external features are valid;				D2 - Bits 15..8, BoxFlag info (possibly unknown);				D2 - Bits  7..0, Address Decoder Kind (zero if unknown);				A6 - return address;;  Outputs:		None;;  Destroys:	A2,A3,D3;  Called by:	BSR6;;  Function:	Initializes the VIA1/VIA2/RBV direction, output and interrupt;				registers as well as general initialization of the VIAs.;;_______________________________________________________________________			with	DecoderInfo,ProductInfoInitVIAs			btst.l	#VIA1Exists,d0		; see if we have VIA1			beq		@VIA1done			; if not, skip it			movea.l	VIA1Addr(a0),a2		; get VIA base address					<SM5> rb			movea.l	a1,a3				; get product info ptr					<SM5> rb			adda.l	VIA1InitPtr(a3),a3	; point to the init info				<SM5> rb			btst.l	#PSCExists,d0		; is this a Cyclone ?			<SM5> rb<SM4> rb, start <SM26>			beq.s	@WombatVIAInit		; if not, check if we're a Wombat;;	This change is valid only for the Cyclone VIA1 Info Table...  ;	The other machine tables will have to be updated to follow this initialization;	or there will be problems.  The DirA, BufA, and DirB, BufB regs have been Inited;	in a different order than in previous ROMS...  THIS MUST BE UPDATED!!!!;	gjs	????;		eieioSTP			move.b	(a3)+,vDirA(a2)		; init direction for port A				<P9> gjs		eieioSTP			move.b	(a3)+,vBufA(a2)		; init output port A					<P9> gjs		eieioSTP			move.b	(a3)+,vDirB(a2)		; init direction for port B				<P9> gjs		eieioSTP			move.b	(a3)+,vBufB(a2)		; init output port B					<P9> gjs		eieioSTP			move.b	(a3)+,vPCR(a2)		; init peripheral control reg			<SM7> rb		eieioSTP			move.b	(a3)+,vACR(a2)		; init auxiliary control reg			<SM7> rb		eieioSTP			move.b	#$7F,vIER(a2)		; Disable all VIA interrupts.			<SM7> rb		eieioSTP			bra.s	@VIA1done			; cool, keep going						<SM5> rb@WombatVIAInit							;										<SM31>	IF hasDJMEMC THEN					;										<SM36> rb			cmpi.b	#djMEMCDecoder,d2	; are we on a Wombat?					<SM31><SM41>			bne.s	@doOldVIAInit		; if not, initialize VIAs the old way	<SM31><SM41>		eieioSTP			move.b	(a3)+,vBufA(a2)		; init output port A					<SM31>		eieioSTP			move.b	(a3)+,vDirA(a2)		; init direction for port A				<SM31>		eieioSTP			move.b	#$1C,vACR(a2)		; enable shift-out on ACR						<H25><SM31>		eieioSTP			move.b	#0,vSR(a2)			; preset shift register with an ADB resetCmd	<H25><SM31>		eieioSTP			move.b	(a3)+,vBufB(a2)		; init output port B							<SM31>		eieioSTP			move.b	(a3)+,vDirB(a2)		; init direction for port B				<SM31>		eieioSTP			move.b	-2(a3),vBufB(a2)	; (re-)init output port B				<H25><SM31>		eieioSTP			move.b	(a3)+,vPCR(a2)		; init peripheral control reg			<SM31>		eieioSTP			move.b	(a3)+,vACR(a2)		; init auxiliary control reg			<SM31>		eieioSTP			move.b	#$7F,vIER(a2)		; Disable all VIA interrupts.			<SM31>		eieioSTP			bra.s	@VIA1done			; cool, keep going						<SM31>	ENDIF								;										<SM36> rb	@doOldVIAInit								;									<SM4> rb, start		eieioSTP			move.b	(a3)+,vBufA(a2)		; init output port A		eieioSTP			move.b	(a3)+,vDirA(a2)		; init direction for port A		eieioSTP			move.b	(a3)+,vBufB(a2)		; init output port B		eieioSTP			move.b	(a3)+,vDirB(a2)		; init direction for port B		eieioSTP			move.b	(a3)+,vPCR(a2)		; init peripheral control reg		eieioSTP			move.b	(a3)+,vACR(a2)		; init auxiliary control reg		eieioSTP			move.b	#$7F,vIER(a2)		; Disable all VIA interrupts.		eieioSTP	@VIA1done			btst.l	#VIA2Exists,d0		; see if we have VIA2			beq.s	@VIA2done			; if not, skip it			movea.l	VIA2Addr(a0),a2		; get VIA2 base address					<SM4> rb, start			movea.l	a1,a3				; get product info ptr			adda.l	VIA2InitPtr(a3),a3	; point to the init info				IF hasPSC THEN						;										<SM36> rb			btst.l	#PSCExists,D0		; Make sure we're on a Cyclone.			<SM26>			Beq.s	@NonPSC				; Not? Then do conventional init.		<SM26>									Move.b	PSCVIA2SInt(A2), D3	; get PortA (slots) current values		eieioSTP			Or.b	(A3)+, D3			; or in via2 init info values		eieioSTP			Move.b	D3, PSCVIA2SInt(A2)	; save new values		eieioSTP			Move.b	#$7F, PSCVIA2IER(A2) ; disable all VIA2 interrupts.		eieioSTP			Move.b	#$40, PSCVIA2IFR(A2) ; clear sound frame int.		eieioSTP			Bra.s	@VIA2done			; this takes care of Cyclones			@NonPSC									;										<SM4> rb, end <SM26>	ENDIF								;										<SM36> rb			eieioSTP			move.b	vBufA(a2),d3		; get current values		eieioSTP			or.b	(a3)+,d3			; or in the default values		eieioSTP			move.b	d3,vBufA(a2)		; init output port A		eieioSTP			move.b	(a3)+,vDirA(a2)		; init direction for port A		eieioSTP			move.b	(a3)+,vBufB(a2)		; init output port B		eieioSTP			move.b	(a3)+,vDirB(a2)		; init direction for port B		eieioSTP			move.b	(a3)+,vPCR(a2)		; init peripheral control reg		eieioSTP			move.b	(a3)+,vACR(a2)		; init auxiliary control reg		eieioSTP			move.b	#$7F,vIER(a2)		; Disable all VIA2 interrupts.		eieioSTP; Simulate the Macintosh VBL interrupt by using timer 1 to output a square wave on PB7 of VIA #2.; On NuMac, this output is tied to the CA1 pin of VIA #1 which is used for VBL on a Mac.; Timer 1 causes the PB7 output to invert each time the counter reaches 0.; There is an additional 2 tick delay while the VIA resets the counter.  We get 783360 ticks/sec; (Which is C16M/20).  Mac VBL interrupt is 60.15 (C16M/(704*370)). The VIA responds on the; negative edges only.  So:;	timer 1	= (ticks/rate)/2 - 2;			= ((C16M/20)/(C16M/(704*370)))/2 - 2; Note: VIA2 PB7 is not tied to anything on Waimea.  JAWS generates this clock for us.@T2Count	equ		((704*370)/20)/2-2	; VIA ticks per half-cycle		eieioSTP			move.b	#@T2Count**$FF,vT1C(a2) ; Load low byte into counter/latch.		eieioSTP			move.b	#@T2Count>>8,vT1CH(a2)	; Load high byte and off we go!		eieioSTP@VIA2done			btst.l	#RBVExists,d0		; see if we have an RBV			beq.s	@RBVdone			; if not, skip it			movea.l	RBVAddr(a0),a2		; get RBV base address		eieioSTP			move.b	#$7F,RvIER(a2)		; disable all  interrupts		eieioSTP			move.b	#$8F,RvDataB(a2)	; initialize data reg. B			<1.3>		eieioSTP			BTST	#MSCChipBit,D1		; are we using an MSC variant?					<H8>			BEQ.S	@NoMSC				; -> no, continue on							<H29><SM31>;	This is the point where we check to see if an external FPU is attached to 				<H31>;	the system.  In the	 case of Escher, the onboard FPU will power up disabled,			<H31>;	but we want to enable it here if we don't detect anything else sitting on 				<H31>;	the coprocessor bus.																	<H31>;;	The idea is to move VBR DOWN the difference between the F-Line and;	BusError, so that if you were to execute an F-Line instruction and;	couldn't handle it, you would end up fetching the address of the;	BusErrVector and going thru the BusErrVector.  The BusErr handler;	expects A6 to contain the address of where it should return TO.			movec	VBR,d3					; retrieve VBR												sub.l	#Line1111-BusErrVct,d3	; temporarily move VBR down			movec	d3,VBR					; shuffle VBR for F-Line test			moveq	#1,d3					; non-zero value in D3 for later comparison			move.l	a7,a5					; sp to restore if you dont have an FPU			move.l	a6,a3					; save return address			bset	#beok,d7				; set bus error expected flag			lea		@noFPU,a6				; where to come back to if you dont have an FPU			FNOP							; execute suspect command			clr.l	d3						; if you got here, you already have an FPU@noFPU		tst.b	d3						;			beq.s	@ignore					; already using an FPU so ignore internal			bclr	#MSCEnableFPU,RvDataB(a2);enable onboard FPU@ignore			movec	VBR,d3					; return VBR to it's old value			add.l	#Line1111-BusErrVct,d3			movec	d3,VBR					; ... so everyone is happy									bclr	#beok,d7				; release bus error expected flag							move.l	a3,a6					; restore return address						<H31>			MOVE.B	#$7F,RvSEnb(A2)		; disable all slot interrupts					<H29><SM31>		eieioSTP			RTS6						;												<H29><SM31>@NoMSC									;												<H29><SM31>		eieioSTP			move.b	#1<<RvVIDOff,RvMonP(a2)	; turn off onboard video					<SM31>		eieioSTP			move.b	#$FF,RvSEnb(a2)		; set all slots to be interrupt enabled			<SM31>		eieioSTP@RBVdone			rts6;_______________________________________________________________________;;  Routine:		GetHardwareInfo;  Inputs:		D2 - Bits 15..8, BoxFlag info (only if decoder kind <> 0);				D2 - Bits  7..0, Address Decoder Kind (zero if unknown);				A6 - return address;				A7, D7, VBR - setup for bus error handler;;  Outputs:		A0 - Pointer to DecoderInfo record for this machine;				A1 - Pointer to ProductInfo record for this machine;				D0 - Flags indicating which base addresses are valid 0-31;				D1 - Flags indicating which external features are valid 0-31;				D2 - Bits 31..16, hwCfgFlags info (possibly unknown);				D2 - Bits 15..8, BoxFlag info (possibly unknown);				D2 - Bits  7..0, Address Decoder Kind (zero if unknown);;  Destroys:	A2, A5;  Called by:	BSR6;;  Function:	Determines the hardware configuration of this machine.;;	NOTE:	The 'beok' bit in D7 will always be cleared when this routine exits.;;_______________________________________________________________________			EXPORT	FoundMatch			;												<SM31>			with	DecoderKinds,DecoderInfo,ProductInfoGetHardwareInfo; Use the new CPUID register scheme if supported on this CPU. (from GetHardwareInfoPatch)			bset.l	#beok,d7			; allow bus errors			movea.l	a7,a5				; mark the stack for bus error handler	IF hasCPUIDRegister THEN			;												; <SM24> rb <SM36> rb			movea.l	a6,a1				; save return address for GetHardwareInfo in a1			bsr6	GetCPUIDReg			; get CPUID register if it exists			movea.l	a1,a6				; restore return address for GetHardwareInfo			beq.s	@foundCPUIDReg		; IF we don't have a CPUID register THEN			bra		HasNoCPUIDReg		;	->CONTINUE in GetHardwareInfo using old recognition method <SM7> rb@foundCPUIDReg							; ENDIF			biglea	CPUIDProductLookup-4,a2	; get address of CPUID product lookup table@MatchLoop								; LOOP (through product info entries to match CPU ID)			addq.w	#4,a2				;	bump to next entry			move.l	(a2),d1				;	see if end of list reached			beq		UnknownCPU			;	if we got to the end, we're severely hosed.			lea		(a2,d1.l),a1		;	a1 := pointer to ProductInfo record			cmp.w	CPUIDValue(a1),d0	;	see if product and CPU ID match			bne.s	@MatchLoop			;	if not, keep searching			btst	#11,d0				;	is the complete CPU ID in the CPUID register?			beq		Matched				;	-> yes, we've got it			cmpi.b	#PrattDecoder,\			;	IF Decoder is a Pratt THEN								<K4>						DecoderKind(a1)		;		Found Match											<K4>			beq		Matched					;		{ For Now just handle one case }					<K4>			movea.l	DecoderInfoPtr(a1),a0 ;	get the pointer to this machine's decoder table			adda.l	a1,a0			move.l	DefaultBases(a0),d0	;	 and get the default bases flags	IF hasYMCA THEN						;																<SM36> rb			cmp.b	#YMCADecoder,DecoderKind(a1)		; Do we have a YMCA controller					<SM26> fau start			bne.s	@GetVia								; No, go do the regular kind					<SM26> fau end			Move.l	DecoderAddr(a0),A1	; Base of YMCA.									<SM23> <SM26>			Move.l	YMCA_CPUID0(A1),D0	; Bit 0 of CPU ID.								<SM23> 			Move.l	YMCA_CPUID1(A1),D1	; Bit 1 of CPU ID.								<SM23> 			Rol.l	#1,D0				; Move to bit 0.								<SM23> 			And.b	#1,D0				; Only care about bit 0.						<SM23> 			Rol.l	#2,D1				; Move to bit 1.								<SM23> 			And.b	#2,D1				; Only care about bit 1.						<SM23> 			Or.b	D1,D0				; Complete ID.									<SM23> 			Move.l	YMCA_CPUID2(A1),D1	; Bit 2 of CPU ID.								<SM23> 			Rol.l	#3,D1				; Move to bit 1.								<SM23> 			And.b	#4,D1				; Only care about bit 1.						<SM23> 			Or.b	D1,D0				; Complete ID.									<SM23> 			Move.l	YMCA_CPUID3(A1),D1	; Bit 3 of CPU ID.								<SM23> 			Rol.l	#4,D1				; Move to bit 1.								<SM23> 			And.b	#8,D1				; Only care about bit 1.						<SM23> 			Or.b	D1,D0				; Complete ID.									<SM23> 			move.l	(a2),d1				; Get the relative offset to the ProductInfo record			lea		(a2,d1.l),a1		;	 and make it absolute			Cmp.b	YMCAIdMatch(A1),D0	; Do they match?								<SM23> 						Beq.s	Matched				; Yes? Then let's get outta here.				<P2>			Move.w	CPUIDValue(a1),d0	; Ack!!!  We blew away D0 and it's needed in the MatchLoop loop, so										; we go and restore it.  We are out of registers here.			Bra.s	@MatchLoop			; No? Then try next product.					<P2>	ENDIF								; hasYMCA										<SM36> rb@GetVia									;													<SM4> rb, end			movea.l	a6,a3				;	save return address for GetHardwareInfo in a1			<H16>			bsr6	GetVIAInputs		;	read all of the VIA input lines into D1			movea.l	a3,a6				;	restore return address for GetHardwareInfo				<H16>			move.l	(a2),d0				;	get the relative offset to the ProductInfo record			lea		(a2,d0.l),a1		;	 and make it absolute			and.l	VIAIdMask(a1),d1	;	mask the VIA inputs			cmp.l	VIAIdMatch(a1),d1	;	see if they match			beq.s	Matched				;	if so, you're done.  else ...							<H17><SM31>			movea.l	a2,a3				;   save your place in the table in A3						<H17><SM31>			movea.l	a6,a1				;   save return address for GetHardwareInfo in A1			<H17><SM31>			BSR6	GetCPUIDReg			;   get CPU ID register value (again)						<H17><SM31>			movea.l	a1,a6				;   restore return address									<H17><SM31>			movea.l	a3,a2				;   restore our place in the table							<H17><SM31>			bra.s	@MatchLoop			;   go look for another candidate to check					<H17><SM31>Matched									; END			bra.s	FoundMatch			; yea!!!										<SM7> rbUnknownCPU	bra.s	UnknownCPU			; Ack!	ENDIF								; hasCPUIDRegister									<SM24> rb <SM36> rb	HasNoCPUIDReg							; fall through to @MatchLoop			tst.b	d2					; check address decoder kind			beq.s	FindDecoder			; if unknown decoder, search for it.;	The ProductKind and DecoderKind are setup in D2, find the matching ProductInfo record.			biglea	ProductLookup-4,a0	; point before the first product to check for@MatchLoop	addq.w	#4,a0				; point to next product to check for			move.l	(a0),d0				; see if end of list reached			beq.s	FindDecoder			; if end, look start over, looking for decoder first			lea		(a0,d0.l),a1		; a1 := pointer to ProductInfo record			cmp.w	ProductKind(a1),d2	; see if product and decoder match			bne.s	@MatchLoop			; if not, keep searchingFoundMatch			movea.l	DecoderInfoPtr(a1),a0	; get offset to DecoderInfo record			adda.l	a1,a0				; make it absolute			move.l	BasesValid(a1),d0	; get the base address valid flags			beq.s	CheckBases			; we don't know for sure, so sniff around			bra		CheckOptionals		; check for optional features (FPU)			<8>FindDecoder			move.l	a6,d0				; save return address in D0 for now			biglea	DecoderLookup,a1	; point to first table entryCheckNextMap			movea.l	a1,a0				; get address of table entry			adda.l	(a1)+,a0			; a0 := pointer to DecoderInfo			movea.l	CheckForProc(a0),a2	; get offset to proc to check for this decoder			jmp		(a0,a2.l)			; check for a this decoderMapFound	movea.l	d0,a2				; now save return address in A2			move.l	DefaultBases(a0),d0	; d0 := default bases valid flags;	an address decoder was found, now get all of the VIA inputs, to check for;	a match when multiple products share an address decoder.			bsr6	GetVIAInputs		; read all of the VIA input lines			movea.l	a2,a6				; restore the return address to A6;	The VIA inputs have been read into D1, now look for a matching product.			move.b	AddrMap(a0),d2		; get the address map to search for			biglea	ProductLookup,a0	; point before the first product to check for@MatchLoop	move.l	(a0)+,d0			; see if end of list reached			beq.s	FindDecoder			; something is very wrong, and we don't have a clue			lea		-4(a0,d0.l),a1		; a1 := pointer to ProductInfo record			cmp.b	DecoderKind(a1),d2	; see if address decoders match			bne.s	@MatchLoop			; if not, keep searching			move.l	d1,d0				; get the VIA inputs			and.l	VIAIdMask(a1),d0	; mask them			cmp.l	VIAIdMatch(a1),d0	; see if they match			bne.s	@MatchLoop			; if not, try the next product			bra.s	FoundMatch			; if found, return the infoCheckBases			move.l	DefaultBases(a0),d0	; get the default base flags			movea.l	a6,a0				; save return address			btst.l	#RBVExists,d0		; see if RBV might be allowed			beq.s	@RBVDone			; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info			movea.l	RBVAddr(a1,a2.l),a2			lea		RvIER(a2),a2		; base address of RBV VIER register			bsr6	TestForRvIER		; see if RBV exists			beq.s	@RBVDone			; if found, has RBV and VDAC			bclr.l	#RBVExists,d0		; no RBV, clear the bit			bclr.l	#VDACExists,d0		; if no RBV, then assume no VDAC either@RBVDone			bclr.l	#VIA2Exists,d0		; see if VIA2 might be allowed			beq.s	@VIA2Done			; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info			movea.l	VIA2Addr(a1,a2.l),a2	; get VIA2 base address		IF hasPSC THEN							;									<SM36> rb			btst.l	#PSCExists, D0			; do we have PSC?					<SM4> rb, start  <SM26>			Beq.s	@noPSC					; no, do horror style VIA2 init		<SM26>						lea		PSCVIA2IER(a2),a2		; base address of PSC VIA2 VIER register			Bra.s	@gotVIA2@noPSC									;										<SM26>	ENDIF								;										<SM36> rb				lea		VIER(a2),a2			; base address of VIA2 VIER register@gotVIA2								;										<SM4> rb, end			bsr6	TestForVIER			; see if VIA2 exists			bne.s	@VIA2Done			; if not found, no VIA2			bset.l	#VIA2Exists,d0		; has VIA2, set the bit@VIA2Done	IF hasIopSwim THEN					;										<SM36> rb			bclr.l	#SWIMIOPExists,d0	; see if SWIMIOP might be allowed			beq.s	@SWIMIOPDone		; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info			movea.l	SWIMIOPAddr(a1,a2.l),a2			bsr6	TestForIOP			; see if SWIM IOP exists			bne.s	@SWIMIOPDone		; if not found, has regular IWM			bclr.l	#IWMExists,d0		; no regular IWM, clear the bit			bset.l	#SWIMIOPExists,d0	; has SWIMIOP, set the bit@SWIMIOPDone	ENDIF								;										<SM36> rb		IF hasIopScc THEN					;										<SM36> rb			bclr.l	#SCCIOPExists,d0	; see if SCCIOP might be allowed			beq.s	@SCCIOPDone			; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info			movea.l	SCCIOPAddr(a1,a2.l),a2			bsr6	TestForIOP			; see if SCC IOP exists			bne.s	@SCCIOPDone			; if not found, has regular SCC			bset.l	#SCCIOPExists,d0	; has SCCIOP, set the bit			bclr.l	#SCCrdExists,d0		; no regular SCC, clear the bit			bclr.l	#SCCwrExists,d0		; no regular SCC, clear the bit@SCCIOPDone	ENDIF								;										<SM36> rb				bclr.l	#SCSIDMAExists,d0	; see if SCSIDMA might be allowed			beq.s	@SCSIDMADone		; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info			movea.l	SCSIDMAAddr(a1,a2.l),a2			bsr6	TestForSCSIDMA		; see if SCSI DMA exists			bne.s	@SCSIDMADone		; if not found, has regular SCSI			bset.l	#SCSIDMAExists,d0	; has SCSI DMA, set the bit			bclr.l	#SCSIExists,d0		; no regular SCSI			bclr.l	#SCSIDackExists,d0	; no SCSI DACK either			bclr.l	#SCSIHskExists,d0	; no SCSI Hardware Handshake either@SCSIDMADone; <58> rb, from Terror SCSI96AndRPUPatch										<T9>	IF hasSCSI96 THEN							;											<SM36> rb			bclr.l	#SCSI96_1Exists, d0			; see if 1st SCSI96 chip might be allowed			beq.s	@SCSI96Done					; if not, don't test for one			movea.l	DecoderInfoPtr(a1), a2		; get offset to decoder info			movea.l	SCSI96Addr1(a1,a2.l), a2	; a2 <- SCSI96 base address			bsr6	TestForSCSI96				; see if SCSI96 exists			bne.s	@SCSI96Done					; if not found then some other SCSI hw						bset.l	#SCSI96_1Exists, d0			; has 1st SCSI96, set exists bit			bclr.l	#SCSIDMAExists,d0			; no SCSI DMA			bclr.l	#SCSIExists,d0				; no regular SCSI (5380)			bclr.l	#SCSIDackExists,d0			; no SCSI DACK			bclr.l	#SCSIHskExists,d0			; no SCSI Hardware Handshake															; Maybe we'll get lucky and fish another...			bclr.l	#SCSI96_2Exists, d0			; see if 2nd SCSI96 chip might be allowed			beq.s	@SCSI96Done					; if not, don't test for one			movea.l	DecoderInfoPtr(a1), a2		; get offset to decoder info			movea.l	SCSI96Addr2(a1,a2.l), a2	; a2 <- SCSI96 base address			bsr6	TestForSCSI96				; see if SCSI96 exists			bne.s	@SCSI96Done					; if not found then some other SCSI hw			bset.l	#SCSI96_2Exists, d0			; has 1st SCSI96, set exists bit@SCSI96Done	ENDIF										;											<SM36> rb				bclr.l	#RPUExists,d0		; see if RPU might be allowed			beq.s	@RPUDone			; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info			movea.l	RPUAddr(a1,a2.l),a2			bsr6	TestForRPU			; see if SCSI DMA exists			bne.s	@RPUDone			; if not found, no parity chip			bset.l	#RPUExists,d0		; has SCSI DMA, set the bit@RPUDone			movea.l	a0,a6						; restore return address			movea.l	a1,a0						; get product info pointer			adda.l	DecoderInfoPtr(a0),a0		; get decoder info pointer			CheckOptionals			move.l	HwCfgWord(a1),d2			; access hardware cfg flags						<8>			btst.l	#hwCbFPU+16,d2				; should FPU be installed									beq.s	FPUDone						; branch if it shouldn't be installed			<SM28>					movea.l	a6,a2						; save return address										bra		TestForFPU					; see if FPU installed							FPUReturn	movea.l	a2,a6						; restore return address						<SM28>			beq.s	FPUDone						; branch if FPU found										bclr.l	#hwCbFPU+16,d2				; otherwise,clear FPU installed flag			FPUDone				bset.l	#beok,d7					; allow bus errors						<H12><H11 begin>			movea.l	a7,a5						; mark the stack for bus error handler	<H12>			bclr.l	#SonicExists,d0				; see if Sonic might be allowed			beq.s	@SonicDone					; if not, don't test for one			move.l	a1,d1						; save a1								<H12>			move.l	SonicAddr(a0),a1			; get Sonic Base Address				<H12>			movea.l	a6,a2						; save return address				bsr6	TestForSonic				; see if Sonic exists			movea.l	a2,a6						; restore return address			move.l	d1,a1						; restore a1							<H12>			bne.s	@SonicDone					; if not found, no Sonic chip			bset.l	#SonicExists,d0				; has Sonic, set the bit					 <H11 end>@SonicDone			bclr.l	#PatchROMExists,d0			; see if PatchRom might be allowed		<H14>.start			beq.s	@PatchROMDone				; if not, don't test for one			move.l	a1,d1						; save a1								<H12>			move.l	PatchRomAddr(a0),a1			; get PatchRom Base Address				<H12>			movea.l	a6,a2						; save return address				bsr6	TestForPatchRom				; see if PatchRom exists			movea.l	a2,a6						; restore return address			move.l	d1,a1						; restore a1							<H12>			bne.s	@PatchRomDone				; if not found, no PatchRom chip			bset.l	#PatchRomExists,d0			; has PatchRom, set the bit				<H14>.end@PatchROMDone; External features checked after CheckOptionals so that d1 can be used as a scratch register CheckFeatures							;												<11>			move.l	ExtValid(a1),d1		; get the external features valid flags			<11>			bne.s	@allDone			; know features, check for optional features	<11> 			move.l	DefExtFeatures(a0),d1	; get the default external features flags	<11>@allDone			bclr.l	#beok,d7			; disallow bus errors							<1.7/8>			rts6						; all done										<8>;_______________________________________________________________________				<SM17>;;  Routine:		GetExtHardwareInfo;;  Inputs:		A0 - Pointer to DecoderInfo record for this machine;				A1 - Pointer to ProductInfo record for this machine;  				D2 - Bits 15..8, BoxFlag info (only if decoder kind <> 0);				D2 - Bits  7..0, Address Decoder Kind (zero if unknown);				A6 - return address;				A7, D7, VBR - setup for bus error handler;;  Outputs:		A0 - Pointer to DecoderInfo record for this machine;				A1 - Pointer to ProductInfo record for this machine;				D0 - Flags indicating which base addresses are valid #32-63;				D1 - Flags indicating which external features are valid #32-63;				D2 - Bits 31..16, hwCfgFlags info (possibly unknown);				D2 - Bits 15..8, BoxFlag info (possibly unknown);				D2 - Bits  7..0, Address Decoder Kind (zero if unknown);				D3 - Flags indicating which base addresses are valid #64-95;				D4 - Flags indicating which external features are valid #64-95;;  Destroys:	A2, A5;  Called by:	BSR6;;  Function:	Returns extended hardware information about the machine.;;	NOTE:	The 'beok' bit in D7 will always be cleared when this routine exits.;;_______________________________________________________________________GetExtHardwareInfo			bset.l	#beok,d7			; allow bus errors			movea.l	a7,a5				; mark the stack for bus error handler			move.l	BasesValid1(a1),d0		; get the base address valid flags for #32-63			bne.s	CheckExtOptionals1		; IF we don't know what bases are valid THENCheckExtBases1			move.l	DefaultBases1(a0),d0	; get the default base flags for #32-63			movea.l	a6,a0					; save return address;---------------; Call "TestFor…" routines here to verify devices for #32-63							<SM17>;---------------;																					begin <SM32> fau;  See if we have a Muni			btst.l	#MuniExists-32,d0			; see if MUNI might be allowed			beq.s	@MuniDone					; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2		; get offset to decoder info			movea.l	(MUNIAddr,a1,a2.l),a2		; get MUNI's base addresses			bsr6	TestForMUNI					; and go test for it			beq.s	@MUNIDone					; if found, has MUNI			bclr.l	#MUNIExists-32,d0			; no MUNI, clear the bit@MUNIDone;  See if we have a BART																<SM53>			btst.l	#BartExists-32,d0			; see if BART might be allowed			beq.s	@BartDone					; if not, don't test for one			movea.l	DecoderInfoPtr(a1),a2		; get offset to decoder info			movea.l	(BartAddr,a1,a2.l),a2		; get BART's base addresses			bsr6	TestForBART					; and go test for it			beq.s	@BartDone					; if found, has BART			bclr.l	#BartExists-32,d0			; no BART, clear the bit@BartDone;																					end <SM32> fau			movea.l	a0,a6					; restore return address			movea.l	a1,a0					; get product info pointer			adda.l	DecoderInfoPtr(a0),a0	; get decoder info pointerCheckExtOptionals1;---------------; Check for optional hardware devices for #32-63 here									<SM17>;---------------			move.l	BasesValid2(a1),d3		; get the base address valid flags for #64-95			bne.s	CheckExtOptionals2		; IF we don't know what bases are valid THENCheckExtBases2			move.l	DefaultBases2(a0),d3	; get the default base flags for #32-63			movea.l	a6,a0					; save return address;---------------; Call "TestFor…" routines here to verify devices for #64-95							<SM17>;---------------			movea.l	a0,a6					; restore return address			movea.l	a1,a0					; get product info pointer			adda.l	DecoderInfoPtr(a0),a0	; get decoder info pointerCheckExtOptionals2;---------------; Check for optional hardware devices for #64-95 here									<SM17>;---------------;----------------------------------------------------------------------------------------; Check external features;----------------------------------------------------------------------------------------CheckExtFeatures							;												<11>			move.l	ExtValid1(a1),d1		; get the external features valid flags			<11>			bne.s	@chkFeatures1			; know features, check for optional features	<11> 			move.l	DefExtFeatures1(a0),d1	; get the default external features flags	<11>@chkFeatures1;---------------; Check for external features here for #32-63											<SM17>;---------------			move.l	ExtValid2(a1),d4		; get the external features valid flags			<11>			bne.s	@chkFeatures2			; know features, check for optional features	<11> 			move.l	DefExtFeatures2(a0),d4	; get the default external features flags	<11>@chkFeatures2;---------------; Check for external features here for #64-95											<SM17>;---------------@allDone			bclr.l	#beok,d7			; disallow bus errors							<1.7/8>			rts6						; all done										<8>	IF hasGlue THEN						; <SM24> rb <SM36> rb	;_______________________________________________________________________;;  Routine:		CheckForGLUE;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound if GLUE is detected;				Jumps to CheckNextMap if not a GLUE Decoder;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	Checks to see a Mac II GLUE chip address decoder is present.;				A unique property of the GLUE chip is that it has a smaller;				I/O space, which repeats sooner than the other decoders in;				its class.  So we check for VIA1 in it's normal place, and;				at the location that it will only wrap around with a GLUE;				decoder.  If it is found in both places, then we assume that;				it is the GLUE chip decoder.;;_______________________________________________________________________			EXPORT	CheckForGLUE		;										<SM36> rbCheckForGLUE			movea.l	VIA1Addr(a0),a2			lea		vIER(a2),a2			move.l	#$00020000,d2		; GLUE chip wrap offset			bsr6	TestVIERWrap		; see if it is a VIA IER register			bne.w	CheckNextMap		; if not, keep searching			bra.w	MapFound			; it's a Mac II GLUE decoder	ENDIF								;										<SM36> rb		IF hasMDU THEN	 					;										<SM36> rb;_______________________________________________________________________;;  Routine:		CheckForMDU;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound if MDU is detected;				Jumps to CheckNextMap if not a MDU Decoder;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	Checks to see a MDU chip address decoder is present.;				We check to see that the VIA wraps at the correct place,;				and that it doesn't wrap earlier, where the GLUE chip would;				wrap.  We also check to see if the RBV and VDAC can be accessed;				without a bus error, since the MDU generates the DSACK for them;				and they shouldn't bus error, even if they don't exist.  An;				OSS decoder will bus error in MDUs RBV and VDAC address ranges.;;_______________________________________________________________________			EXPORT	CheckForMDU			;										<SM36> rbCheckForMDU			movea.l	VIA1Addr(a0),a2			lea		vIER(a2),a2			move.l	#$00040000,d2		; MDU chip wrap offset			bsr6	TestVIERWrap		; see if it is a VIA IER register			bne.w	CheckNextMap		; if not, keep searching			sub.l	#$00020000,d2		; MDU VIA does not wrap at $20000			bsr6	TestVIERWrap		; see if it is a VIA IER register			beq.w	CheckNextMap		; if so, keep searching			lea		CheckNextMap,a6		; if bus errors, not an MDU			movea.l	RBVAddr(a0),a2		eieioSTP			tst.b	(a2)				; RBV should never bus error			movea.l	VDACAddr(a0),a2		eieioSTP			tst.b	(a2)				; VDAC should never bus error		eieioSTP			bra.w	MapFound			; it's a MDU decoder	ENDIF								;										<SM36> rb		IF hasOss OR hasFMC THEN			;										<SM36> rb;_______________________________________________________________________;;  Routine:		CheckForOSSFMC;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound if OSS/FMC is detected;				Jumps to CheckNextMap if not a OSS/FMC Decoder;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	Checks to see a OSS/FMC address decoder is present.;				We check to see that the VIA wraps at the correct place,;				and that it doesn't wrap earlier, where the GLUE chip would;				wrap.  We also check to see if an OSS mask register exists,;				by trying to load it with priorities 1..6 (don't use 7, since;				if may cause a NMI to be generated).;;_______________________________________________________________________			EXPORT	CheckForOSSFMC		;										<SM36> rbCheckForOSSFMC			movea.l	VIA1Addr(a0),a2			lea		vIER(a2),a2			move.l	#$00040000,d2		; OSS chip wrap offset			bsr6	TestVIERWrap		; see if it is a VIA IER register			bne.w	CheckNextMap		; if not, keep searching			sub.l	#$00020000,d2		; OSS VIA does not wrap at $20000			bsr6	TestVIERWrap		; see if it is a VIA IER register			beq.w	CheckNextMap		; if so, keep searching			lea		CheckNextMap,a6		; if bus errors, not an OSS			movea.l	OSSAddr(a0),a2			move.b	OSSMskFirst(a2),d1	; save the old contents			lsl.w	#8,d1				; make room for temp use of low byte			moveq.l	#6,d2				; loop counter / data pattern@OssLoop	move.b	d2,OSSMskFirst(a2)	; store a value (don't allow NMI=7)			TST.L	AllOnes				; put $FFFFFFFF on the bus to scramble it	<2>			move.b	OSSMskFirst(a2),d1	; read it back			andi.b	#$07,d1				; expect low bits to change			cmp.b	d1,d2				; see if they did			dbne	d2,@OssLoop			; loop through all patterns@Done		lsr.w	#8,d1				; get saved value			move.b	d1,OSSMskFirst(a2)	; restore it			tst.w	d2					; see if all patterns compared			bpl.w	CheckNextMap		; if not, it's not an OSS chip			bra.w	MapFound			; otherwise it's an OSS decoderAllOnes		dc.l	$FFFFFFFF			;											<2>	ENDIF								; <SM24> rb		IF hasVISADecoder THEN				;											<SM36> rb;_______________________________________________________________________;;  Routine:		CheckForVISADecoder;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound if VISA decoder is detected;				Jumps to CheckNextMap if not a VISA Decoder;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	Checks to see if a VISA address decoder is present.;				First, we check for a VIA IER at the correct address.;				If it is there, we check that it does not appear again;				at an offset of $00040000 in order to eliminate GLUE, MDU,;				and OSS, all of which wrap at this offset.  We also check ;				to see if the VISA (RBV) and VDAC can be accessed;				without a bus error, since the VISA generates the DSACK for them;				and they shouldn't bus error, even if they don't exist.  An;				OSS decoder will bus error in VISAs RBV and VDAC address ranges.;;_______________________________________________________________________			EXPORT	CheckForVISADecoder	;											<SM36> rbCheckForVISADecoder			movea.l	VIA1Addr(a0),a2		; look for a VIA IER			lea		vIER(a2),a2			bsr6	TestForVIER						bne.w	CheckNextMap		; not found means can't be a VISA						move.l	#$00040000,d2		; other decoders wrap at this offset			bsr6	TestVIERWrap			beq.w	CheckNextMap		; if it wraps, it's not a VISA						lea		CheckNextMap,a6		; if bus errors, not an MDU			movea.l	RBVAddr(a0),a2		eieioSTP			tst.b	(a2)				; VISA should never bus error			movea.l	VDACAddr(a0),a2		eieioSTP			tst.b	(a2)				; VDAC should never bus error		eieioSTP			bra.w	MapFound			; if not, it's a VISA decoder	ENDIF								;											<SM36> rb	IF hasOrwell THEN					; <SM24> rb									<SM36> rb	;_______________________________________________________________________;;  Routine:		CheckForOrwell														<13>;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder					<13>;				A1 - Pointer to next entry in DecoderLookup table					<13>;				A5, A7, D7, VBR - setup for bus error handler						<13>;;  Outputs:		Jumps to MapFound if Orwell is detected								<13>;				Jumps to CheckNextMap if not an Orwell Decoder						<13>;;  Destroys:	D2, A2																<13>;  Called by:	BSR6																<13>;;  Function:	Checks to see an Orwell address decoder is present.  We check to see<13>;				if we get a bus error when trying to access Orwell's I/O control 	<13>;				register I/O space.  Orwell is the only decoder that doesn't bus	<13>;				error in that part of I/O space.									<13>;;_______________________________________________________________________			EXPORT	CheckForOrwell		;											<SM36> rbCheckForOrwell			lea		CheckNextMap,a6		; return to decoder search if we bus error	<19>			movea.l	DecoderAddr(a0),a2	; look for an Orwell						<SM17>			move.l	(a2),d2				; Orwell won't bus error					<13>			bra.w	MapFound			; otherwise it is an Orwell decoder			<13>	ENDIF								;											<SM36> rb		IF hasJaws THEN						;										<SM36> rb;_______________________________________________________________________		<SM4> rb, start;;  Routine:		CheckForJAWS;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound if JAWS is detected;				Jumps to CheckNextMap if not a JAWS Decoder;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	Checks to see a JAWS chip address decoder is present.;				By the time we get here we already know that the VIA does not;				wrap at $40000 or $20000, and that the RBV and VDAC addresses;				cause a bus error.  Just to be safe though, we do some of the;				same VIA checks that were done before.;;_______________________________________________________________________			EXPORT	CheckForJAWS		;											<SM36> rbCheckForJAWS			movea.l	VIA1Addr(a0),a2		; Look for VIA wrap a various places			lea		vIER(a2),a2			move.l	#$00100000,d2		; JAWS does wrap at $100000					<8> HJR			bsr6	TestVIERWrap		; see if it is a VIA IER register			<8> HJR			bne.w	CheckNextMap		; if so, keep searching						<8> HJR			lsr.l	#1,d2				; JAWS doesn't wrap at $80000				<8> HJR			bsr6	TestVIERWrap		; see if it is a VIA IER register			<8> HJR			beq.w	CheckNextMap		; if not, keep searching					<8> HJR			lsr.l	#1,d2				; JAWS doesn't wrap at $40000				<8> HJR			bsr6	TestVIERWrap		; see if it is a VIA IER register			<8> HJR			beq.w	CheckNextMap		; if so, keep searching						lea		CheckNextMap,a6		; now try the JAWS registers			movea.l	JAWSAddr(a0),a2			tst.b	(a2)				; JAWS should never bus error			bra.w	MapFound			; it's a JAWS decoder	ENDIF								;											<SM36> rb	IF hasNiagra THEN					;								<SM36> rb;_______________________________________________________________________ <H17> thru next;																				<H17>;  Routine:		CheckForNiagra;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound if Niagra is detected;				Jumps to CheckNextMap if not a Niagra Decoder;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	Checks to see a Niagra chip address decoder is present.;				By the time we get here we already know that the VIA does not;				wrap at $40000 or $20000, and that the RBV and VDAC addresses;				cause a bus error.  Just to be safe though, we do some of the;				same VIA checks that were done before.;;_______________________________________________________________________			Export	CheckForNiagraCheckForNiagra				movea.l	VIA1Addr(a0),a2		; Look for VIA wrap a various places			lea		vIER(a2),a2						move.l	#$FF200000,d2		; Niagra doesn't wrap at $50100000			bsr6	TestVIERWrap		; see if it is a VIA IER register			beq.w	CheckNextMap		; if not, keep searching						move.l	#$00080000,d2		; Niagra doesn't wrap at $00080000			bsr6	TestVIERWrap		; see if it is a VIA IER register			beq.w	CheckNextMap		; if not, keep searching			lsr.l	#1,d2				; Niagra doesn't wrap at $40000			bsr6	TestVIERWrap		; Niagra if it is a VIA IER register			beq.w	CheckNextMap		; if so, keep searching						lea		CheckNextMap,a6		; now try the Niagra registers			movea.l	JAWSAddr(a0),a2			tst.b	(a2)				; Niagra should never bus error			bra.w	MapFound			; it's a Niagra decoder										;								<H17> <SM4> rb,end	ENDIF								; <SM24> rb;_______________________________________________________________________;;  Routine:		CheckForUnknown;  Inputs:		A0 - Pointer to DecoderInfo record for this decoder;				A1 - Pointer to next entry in DecoderLookup table;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		Jumps to MapFound always.;;  Destroys:	D1, D2, A2, A6;  Called by:	BSR6;;  Function:	This is the last decoder on the list of decoders to search,;				so if we get here, we can't identify the address decoder.;				We return to MapFound to indicate that this unknown decoder;				exists, but if we get here, we are really dead, and can't;				figure out enough to even try to tell someone about it.;;_______________________________________________________________________CheckForUnknown			bra.w	MapFound;_______________________________________________________________________;;  Routine:		TestForVIER, TestVIERWrap;  Inputs:		A2 - Address of the VIER register to test;				D2 - offset of alternate address to check for (wrap around);					 Used by TestVIERWrap, set to zero for TestForVIER.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if not a valid VIER register, or bus error.;					  - 1 (beq) if valid VIER register found.;;  Destroys:	D1;  Called by:	BSR6;;  Function:	Checks to see if the specified I/O register is a VIA IER;				(interrupt enable) register, by first setting all bits of;				the register, and then clearing each bit individually.;				Also checks to see if the same register also exists at an;				alternate address in I/O space, to detect specific address;				wrap around characteristics of some address decoders.;;_______________________________________________________________________TestForVIER								; A2 := address of VIER register to test			moveq.l	#0,d2				; D2 := wrap offset to testTestVIERWrap							; A2 := address of VIER register to test		eieioSTP			tst.b	(a2,d2.l)			; make sure wrap address can be accessed		eieioSTP			move.b	(a2),d1				; save old VIER value		eieioSTP			rol.w	#8,d1				; save it in the next byte			st.b	d1					; test pattern := $FF			move.b	d1,(a2)				; set all bits of VIER		eieioSTP@loop		neg.b	d1					; pattern of bit to clear		eieioSTP			move.b	d1,(a2)				; clear the lowest order bit			add.b	d1,d1				; shift the test pattern			beq.s	@exit				; exit when all bits shifted out			neg.b	d1					; convert to mask of bits that should be set		eieioSTP			cmp.b	(a2,d2.l),d1		; see if they are set at the wrap address		eieioSTP			bne.s	@exit				; if not, exit			cmp.b	(a2),d1				; see if they are set at the standard address		eieioSTP			beq.s	@loop				; if so, keep testing@exit		ror.w	#8,d1				; get saved VIER value		eieioSTP			move.b	#$7F,(a2)			; prepare to restore (clear all bits)		eieioSTP			move.b	d1,(a2)				; restore original VIER value		eieioSTP			lsr.w	#8,d1				; 0 if VIER found			rts6;_______________________________________________________________________;;  Routine:		TestForRvIER;  Inputs:		A2 - Address of the RvIER register to test;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if not a valid RvIER register, or bus error.;					  - 1 (beq) if valid RvIER register found.;;  Destroys:	D1, D2;  Called by:	BSR6;;  Function:	Checks to see if the specified I/O register is a RBV IER;				(interrupt enable) register, by first setting all bits of;				the register, and then clearing each bit individually.;				There are some reserved bits in the RvIER register, which;				are ignored by this test.;;_______________________________________________________________________TestForRvIER							; A2 := address of RvIER register to test			move.b	(a2),d1				; save old RvIER value			rol.w	#8,d1				; save it in the next byte			st.b	d1					; test pattern := $FF		eieioSTP			move.b	d1,(a2)				; set all bits of RvIER@loop			neg.b	d1					; pattern of bit to clear		eieioSTP			move.b	d1,(a2)				; clear the lowest order bit			add.b	d1,d1				; shift the test pattern			beq.s	@exit				; exit when all bits shifted out			neg.b	d1					; convert to mask of bits that should be set		eieioSTP			move.b	(a2),d2				; get the RvIER value			eor.b	d1,d2				; compare them			andi.b	#$9F,d2				; ignore the reserved bits			beq.s	@loop				; if match found, keep testing@exit		ror.w	#8,d1				; get saved RvIER value		eieioSTP			move.b	#$7F,(a2)			; prepare to restore (clear all bits)		eieioSTP			move.b	d1,(a2)				; restore original RvIER value		eieioSTP			lsr.w	#8,d1				; 0 if RvIER found			rts6;_______________________________________________________________________;;  Routine:		TestForSCC;  Inputs:		A2 - Base write address of the SCC to test for.;				D2 - offset to SCC read base address from write base;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if SCC not found, or bus error.;					  - 1 (beq) if valid SCC found.;;  Destroys:	D1;  Called by:	BSR6;;  Function:	Checks to see if the specified I/O registers point to an;				SCC.  The read and write addresses may be specified separatly;				since some address decoders require this.  An SCC is detected;				by writing a two byte signature to the time constant register;				and reading it back.  The old value is saved and restored to;				make this test non-destructive.  In order to meet SCC timing;				requirements on systems like the Mac Plus that do not provide;				a hardware holdoff, extra delays are introduced between SCC;				accesses.;;_______________________________________________________________________TestForSCC								; A2 := address of SCCrd										; D2 := offset of SCCwr-SCCrd		eieioSTP			tst.b	bCtl(a2,d2.l)			; reset register pointer to reg 0			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#13,bCtl(a2)		; point to register 13, time const high			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	bCtl(a2,d2.l),d1	; save old time const high byte			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#12,bCtl(a2)		; point to register 12, time const low			lsl.l	#8,d1				; make room for low byte, kill time		eieioSTP			move.b	bCtl(a2,d2.l),d1	; save old time const low byte			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#13,bCtl(a2)		; point to register 13, time const high			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#'G',bCtl(a2)		; load in signature high byte			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#12,bCtl(a2)		; point to register 12, time const low			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#'D',bCtl(a2)		; load in signature low byte			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#13,bCtl(a2)		; point to register 13, time const high			lsl.l	#8,d1				; make room for byte, kill time		eieioSTP			move.b	bCtl(a2,d2.l),d1	; read back signature high byte			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#12,bCtl(a2)		; point to register 12, time const low			lsl.l	#8,d1				; make room for byte, kill time		eieioSTP			move.b	bCtl(a2,d2.l),d1	; read back signature low byte			subi.w	#'GD',d1			; see if signature matched			ror.l	#8,d1				; setup to restore, kill some time		eieioSTP			move.b	#12,bCtl(a2)		; point to register 12, time const low			ror.l	#8,d1				; position saved low byte of time const		eieioSTP			move.b	d1,bCtl(a2)			; restore original time const low byte			ror.b	#8,d1				; kill some time, non-destructive		eieioSTP			move.b	#13,bCtl(a2)		; point to register 13, time const high			lsr.l	#8,d1				; get the high byte		eieioSTP			move.b	d1,bCtl(a2)			; restore original time const high byte			lsr.l	#8,d1				; test signature for match			rts6						; all done;_______________________________________________________________________;;  Routine:		TestForIOP;  Inputs:		A2 - Base address of IOP to test for.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if IOP not found, or bus error.;					  - 1 (beq) if valid IOP found.;;  Destroys:	D1, D2;  Called by:	BSR6;;  Function:	Checks to see if the specified I/O registers point to an;				IOP.  Since the IOP chip generates it's own DSACK, a Bus;				Error may occur if it doesn't exist, which would cause this;				routine to return through the bus error handler, indicating;				that an IOP doesn't exist.  If no bus errors occur, we;				verify that a long word read from the IOPRamData register;				causes the IOPRamAddr register to incement by 4.  All of the;				IOP registers used are saved and restored, making this test;				non-destructive.;;_______________________________________________________________________TestForIOP								; A2 := Base address of IOP to test		eieioSTP			move.b	iopStatCtl(a2),d1	; save status/ctl register value			moveq.l	#(1<<iopIncEnable)+(1<<iopRun),d2	; mask for bits to save			and.b	d1,d2				; get those bits			swap	d1					; save old status ctl reg		eieioSTP			move.w	iopRamAddr(a2),d1	; save Ram Address register value			ori.b	#(1<<iopIncEnable),d2	; enable increment								<2.5>		eieioSTP			move.b	d2,iopStatCtl(a2)	; enable register pointer incrementing		eieioSTP			tst.l	iopRamData(a2)		; read and ignore 4 bytes of Ram		eieioSTP			move.w	iopRamAddr(a2),d2	; save updated Ram Address register value		eieioSTP			move.w	d1,iopRamAddr(a2)	; restore Ram Address register value			subq.w	#4,d2				; back off the 4 byte increment			sub.w	d1,d2				; check for increment			swap	d1					; get status ctl reg			andi.b	#-1-(1<<iopInt0Active)-(1<<iopInt1Active),d1		eieioSTP			move.b	d1,iopStatCtl(a2)	; restore status/ctl register			tst.w	d2					; d2 = 0 if IOP found		eieioSTP			rts6;_______________________________________________________________________;;  Routine:		TestForSCSIDMA;  Inputs:		A2 - Base address of SCSI DMA to test for.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if SCSI DMA not found, or bus error.;					  - 1 (beq) if valid SCSI DMA found.;;  Destroys:	none;  Called by:	BSR6;;  Function:	Checks to see if the specified I/O registers point to a;				SCSI DMA chip.  Since the SCSI DMA chip generates it's own;				DSACK, a Bus Error may occur if it doesn't exist, which would;				cause this routine to return through the bus error handler,;				indicating that it doesn't exist.  For now we just simply test;				to see if we can read the control register without getting;				a bus error.  If we are successful, we assume that the chip;				exists.  This test may need to be improved in the future.;;_______________________________________________________________________TestForSCSIDMA							; A2 := Base address of SCSI DMA to test		eieioSTP			tst.l	$80(a2)				; try to read the control register		eieioSTP			cmp.b	d1,d1				; if no bus error, assume that it exists			rts6; <58> rb, from Terror...;_______________________________________________________________________  thru matching <T8>;;  Routine:		TestForSCSI96;  Inputs:		A2 - Base address of SCSI Port to test.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if SCSI 5380 not found, or bus error.;					  - 1 (beq) if SCSI 5396 found.;;  Destroys:	none;  Called by:	BSR6;;  Function:	Checks to see if we have a SCSI 5380 chip or the more advance;				SCSI 5394/5396 controller.  The test is to access a register;				the 5394/5396 has that the 53c80 does not.  An access to a non-existent;				address would cause us to BusError.  Unfortunately, there is a possibility	<T14>;				that a non-existent address is decoded by HW anyway so if we pass bus-err	<T14>;				test we verify the contents of the regr with expected value for safety.		<T14>		;;_______________________________________________________________________;	the CMPI will be .NE. if the address we write to does not bus error, but is in		<T14>;	reality, not there.  So the CMPI above actually checks to see if the data stuck.	<T14>TestForSCSI96							; A2 = Base address of SCSI port to test		eieioSTP			tst.b	$c0(a2)				; try to read configuration #3 register (r/w)		eieioSTP			cmpi.b	#$04, $c0(a2)		; ...verify data written in config. regr 3		<T14>		eieioSTP			rts6;_______________________________________________________________________;;  Routine:		TestForRPU;  Inputs:		A2 - Base address of RPU to test for.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if RPU not found, or bus error.;					  - 1 (beq) if valid RPU found.;;  Destroys:	D1,D2;  Called by:	BSR6;;  Function:	Checks to see if the RPU (Ram Parity Unit) is present by writing;				to the WWP bit of the chip (the only r/w bit) and reading back,;				making sure bus capacitance doesn't make it look valid.;;_______________________________________________________________________TestForRPU								;		eieioSTP			tst.b	(a2)				; x 	First 4 reads are unique		eieioSTP			tst.b	(a2)				; x 			eieioSTP			tst.b	(a2)				; PDCA	Read out the parity daisy chain bits		eieioSTP			tst.b	(a2)				; PDCB	and toss them (no where to save them)		eieioSTP			st.b	rpuReset(a2)		;reset the RPU serial pointer		eieioSTP			move.b	(a2),d2				;save the WWP bit		eieioSTP			st.b	rpuReset(a2)		;reset the RPU serial pointer		eieioSTP			st.b	(a2)				;set the WWP bit		eieioSTP			clr.b	rpuReset(a2)		;force bus low, reset pointer			moveq	#1,d1				;check bit 0		eieioSTP			and.b	(a2),d1				;read WWP bit			seq.b	d1					;d1=FF if WWP bit was 0			beq.s	@exit				;exit if WWP bit=0		eieioSTP			st.b	rpuReset(a2)		;reset the RPU serial pointer			clr.b	(a2)				;clear the WWP bit		eieioSTP			st.b	rpuReset(a2)		;force bus high, reset pointer			moveq	#1,d1				;check bit 0		eieioSTP			and.b	(a2),d1				;read WWP bit@exit		eieioSTP			st.b	rpuReset(a2)		;reset pointer for exit			move.b	d2,(a2)				;restore WWP bit			tst.b	d1					;test result		eieioSTP			rts6;_______________________________________________________________________			<SM32>;;  Routine:		TestForMUNI;  Inputs:		A2 - Address of the MUNI Control register to test;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if not a valid MUNI Control register, or bus error.;					  - 1 (beq) if valid MUNI Control register found.;;  Destroys:	D1, D2;  Called by:	BSR6;;  Function:	Checks to see if the specified MUNI Control register;				exists by writing to it and seeing if we get a bus error.;  				If we do, then we have no MUNI.;				Since the MUNI chip generates it's own;				DSACK, a Bus Error may occur if it doesn't exist, which would;				cause this routine to return through the bus error handler,;				indicating that it doesn't exist.  For now we just simply test;				to see if we can read the control register without getting;				a bus error.  If we are successful, we assume that the chip;				exists.  This test may need to be improved in the future.;;;_______________________________________________________________________TestForMUNI									; A2 := address of MUNI register to test		eieioSTP			tst.l	MUNI_Control(a2)		; try to read the control register		eieioSTP			cmp.b	d1,d1					; if no bus error, assume that it exists			rts6;_______________________________________________________________________			<SM53>;;  Routine:		TestForBart;  Inputs:		A2 - Address of BART;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if no BART, or bus error.;					  - 1 (beq) if BART found.;;  Destroys:	D1, D2;  Called by:	BSR6;;  Function:	Checks to see if  BART exists by accessing it and seeing if ;				we get a bus error.  If we do, then we don't have a BART.  This;				test should be extended in the future to check the version register;				in BART.;;;_______________________________________________________________________TestForBart									; A2 := address of BART register to test		eieioSTP			tst.b	(a2)					; try to read BART			cmp.b	d1,d1					; if no bus error, assume that it exists		eieioSTP			rts6;																			<SM28> fau start;_______________________________________________________________________;;  Routine:		TestForFPU;  Inputs:		A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if FPU not found.;					  - 1 (beq) if FPU available.;;  Destroys:	A6, D1, sfc;  Called by:	BRA;;  Function:	Checks to see if an FPU is installed.;;	NOTE:	this routine is BRA'nched to, not BSR6'ed, so that A6 is				;			available for trashing in this routine.									;;	NOTE2:	this needed to be changed because with an 040LC you're					;			no longer guaranteed to have an on-board FPU.							;_______________________________________________________________________TestForFPU	IF ROMinRAM THEN					; 									<SM22> rb 			movec 	CACR,d1				; MacsBug does not like the fpu		<SM22> rb			cmp.b	d1,d1				; code when booting from RAM		<SM22> rb			bra		FPUReturn			;									<SM22> rb	ELSE								;									<SM22> rb	;	New, Improved method of on-the-fly checking for and FPU										movec	VBR,d1				;   retrieve VBR;	The idea is to move VBR DOWN the difference between the F-Line and;	BusError, so that if you were to execute an F-Line instruction and;	couldn't handle it, you would end up fetching the address of the;	BusErrVector and going thru the BusErrVector.  The BusErr handler;	expects A6 to contain the address of where it should return TO.			sub.l	#Line1111-BusErrVct,d1; temporarily move VBR down			movec	d1,VBR				;   shuffle VBR for F-Line test			moveq	#1,d1				;   non-zero value in D1 for later comparison			lea		@noFPU,a6			;   where to come back to if you dont have an FPU		eieioSTP			FNOP						;   execute suspect command		eieioSTP			clr.l	d1					;   if you got here, you have an FPU@noFPU		move.l	d1,a6				;   save D1			movec	VBR,d1				;   return VBR to it's old value			add.l	#Line1111-BusErrVct,d1			movec	d1,VBR				;   ... so everyone is happy			move.l	a6,d1				;   restore D1			tst.b	d1					;   return CCR.Z to CheckOptionals@exit		bra		FPUReturn			;   and return to CheckOptionals	<SM28> fau end	ENDIF								;									<SM22> rb;_______________________________________________________________________;;  Routine:		GetVIAInputs;  Inputs:		A0 - Pointer to Decoder Info record for this decoder;				D0 - DefaultBases flags for this decoder;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		D1 - Bits 31..24, inputs from VIA1, port A;				D1 - Bits 23..16, inputs from VIA1, port B;				D1 - Bits 15.. 8, inputs from VIA2, port A;				D1 - Bits  7.. 0, inputs from VIA2, port B;;  Destroys:	D2, A1;  Called by:	BSR6;;  Function:	Reads the input ports for VIA 1 and 2 if they are supported;				by the current address decoder (which does not imply that;				they actually exist).  If the are not supported, zeros will;				be returned, if they are supported, but do not exist, the results;				are unpredictable, but are most likely the value of a floating;				data bus.  The values of the data direction registers are saved;				and restored, which makes this non-destructive.;;_______________________________________________________________________GetVIAInputs			moveq.l	#0,d1				; initialize via info result			btst.l	#VIA1Exists,d0		; see if VIA1 exists			beq.s	@noVIA1				; if not, skip it			movea.l	VIA1Addr(a0),a1		; get the VIA1 base address		eieioSTP			move.b	vBufA(a1),d2		; save port A		eieioSTP			lsl.w	#8,d2				; make room for direction bits			move.b	vDirA(a1),d2		; save direction bits			move.b	d2,d1				; get prior direction bits		eieioSTP			and.b	AvoidVIA1A(a0),d1	; if we need to avoid any output, don't make them input		eieioSTP			move.b	d1,vDirA(a1)		; change bits to inputs		eieioSTP			move.b	vBufA(a1),d1		; get port A inputs		eieioSTP			move.b	d2,vDirA(a1)		; restore direction bits			lsr.w	#8,d2				; get saved port A		eieioSTP			move.b	d2,vBufA(a1)		; restore port A			lsl.w	#8,d1				; make room for port B bits		eieioSTP			move.b	vBufB(a1),d2		; save port B			lsl.w	#8,d2				; make room for direction bits		eieioSTP			move.b	vDirB(a1),d2		; save direction bits		eieioSTP			move.b	d2,d1				; get prior direction bits			and.b	AvoidVIA1B(a0),d1	; if we need to avoid any output, don't make them input		eieioSTP			move.b	d1,vDirB(a1)		; change bits to inputs		eieioSTP			move.b	vBufB(a1),d1		; get port B inputs		eieioSTP				move.b	d2,vDirB(a1)		; restore direction bits		eieioSTP			lsr.w	#8,d2				; get saved port B			move.b	d2,vBufB(a1)		; restore port B		eieioSTP@noVIA1			swap	d1					; VIA1 info to high word			btst.l	#VIA2Exists,d0		; see if VIA2 exists			beq.s	@noVIA2				; if not, skip it		eieioSTP			movea.l	VIA2Addr(a0),a1		; get the VIA2 base address		eieioSTP			move.b	vBufA(a1),d2		; save port A		eieioSTP			lsl.w	#8,d2				; make room for direction bits			move.b	vDirA(a1),d2		; save direction bits		eieioSTP			move.b	d2,d1				; get prior direction bits			and.b	AvoidVIA2A(a0),d1	; if we need to avoid any output, don't make them input		eieioSTP			move.b	d1,vDirA(a1)		; change bits to inputs		eieioSTP			move.b	vBufA(a1),d1		; get port A inputs		eieioSTP			move.b	d2,vDirA(a1)		; restore direction bits		eieioSTP			lsr.w	#8,d2				; get saved port A			move.b	d2,vBufA(a1)		; restore port A		eieioSTP			lsl.w	#8,d1				; make room for port B bits			move.b	vBufB(a1),d2		; save port B		eieioSTP			lsl.w	#8,d2				; make room for direction bits			move.b	vDirB(a1),d2		; save direction bits		eieioSTP			move.b	d2,d1				; get prior direction bits			and.b	AvoidVIA2B(a0),d1	; if we need to avoid any output, don't make them input		eieioSTP			move.b	d1,vDirB(a1)		; change bits to inputs		eieioSTP			move.b	vBufB(a1),d1		; get port B inputs		eieioSTP			move.b	d2,vDirB(a1)		; restore direction bits		eieioSTP			lsr.w	#8,d2				; get saved port B			move.b	d2,vBufB(a1)		; restore port B		eieioSTP@noVIA2			rts6						; all done;_______________________________________________________________________  ;;  Routine:		TestForSonic;  Inputs:		A1 - Base address of Sonic to test.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if Sonic not found, or bus error.;					  - 1 (beq) if Sonic found.;;  Destroys:	none;  Called by:	BSR6;;  Function:	Checks to see if we have a Sonic Ethernet chip.    An access to a non-existent;				address MUST cause us to BusError.  		;;_______________________________________________________________________TestForSonic							; A1 = Base address of Sonic Chip to test			<H12 begin>		eieioSTP			tst.b	(a1)				; try to read the Command Register				eieioSTP			bset	#7,(a1)				; send a SW Reset to Sonic							<H30><SM40>		eieioSTP					cmp		d1,d1				; set ccr.z because no bus error if we made it here							rts6						; return with flags set								;_______________________________________________________________________  ;;  Routine:		TestForPatchROM;  Inputs:		A1 - Base address of PatchROM to test.;				A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if PatchROM not found, or bus error.;					  - 1 (beq) if PatchROM found.;;  Destroys:	a1;  Called by:	BSR6;;  Function:	Checks to see if we have a PatchROM.    An access to a non-existent;				address MUST cause us to BusError.  		;;_______________________________________________________________________TestForPatchROM							; A1 = Base address of PatchROM to test			<H12 begin>		eieioSTP			tst.b	(a1)				; try to read the first byte			eieioSTP			movea.l	$4(a1),a1			; load signature into a1		eieioSTP			exg		a1,d1				; because we have no free registers			cmpi.l	#'romp',d1			; set ccr.z if signtures match			exg		a1,d1				; because we have no free registers			rts6						; return with flags set								;__________________________________________________________________________________________________;;  Routine:		GetCPUIDReg;;  Inputs:		A6 - return address;				A5, A7, D7, VBR - setup for bus error handler;;  Outputs:		ccr.z - 0 (bne) if CPUID reg not found or bus error.;					  - 1 (beq) if CPUID reg found.;				D0.w  -	CPUID   if CPUID reg found.;;  Destroys:	D0, D1, A2;;  Function:	Checks for the existance of a CPU ID register.  If one is found, it checks to see;				if the value in the register matches the expected value for the current decoder;				type.  The register is a long word located at $5FFFFFFC, and contains the following;				information.  ;;					bits 31-16:	signature $A55A;						 15-12:	design center;									0 = high volume;									1 = portables;									2 = high end Macintosh;									3 = RISC;							11:	extension;									0=complete ID appears in this register;									1=supplemental ID appears in VIA or equivalent;						 10- 0:	ID;__________________________________________________________________________________________________	IF hasCPUIDRegister THEN				; <SM24> rb <SM36> rb	GetCPUIDReg	IF ROMinRAM THEN						; 										<SM22> rb			move.l #$A55A2830,d0			; ••• HACK, force Cyclone, make your	<SM22> rb			cmp.w d0,d0						; ModifyReadOnly hack here. Cyclone		<SM22> rb			jmp (a6)						; needs this because the MMU is 		<SM22> rb	ENDIF									; hiding the CPUIDReg one we booted		<SM22> rb			IF forSmurf THEN				; Read the CPUID bits from the via register.  Orwells/djmemc both have			; via addrs at $50F0000 (but for smurfs, use $50000000)						movea.l	#$50000000,a2			; get the VIA1 base address						;now get the cpuid bits from the via register			move.b	vBufA(a2),d2			; save port A			lsl.w	#8,d2					; make room for direction bits			move.b	vDirA(a2),d2			; save direction bits			move.b	d2,d1					; get prior direction bits			move.b	#0,vDirA(a2)			; change bits to inputs			move.b	vBufA(a2),d1			; get port A inputs			move.b	d2,vDirA(a2)			; restore direction bits			lsr.w	#8,d2					; get saved port A			move.b	d2,vBufA(a2)			; restore port A						; d1.b  now contains the cpuid bits. so use $56 to mask out leaving us with the 			; cpuid bits PA6, PA4, PA2, PA1						andi.b #$56,d1					; d1.b now contains the cpu id bits from the via			; now find out if we are on a machine with a djmemc decoder or and orwell.			; djmec have a 12 bit register, bits 11..9 contain the version number for the djmemc...			; Game Plan: read from the 12 bit register.  if bits 11..9 = 010 then djmec			lea	#MEMCAddr,a2					; Orwell or djmec decoder addr.				move.l	MEMCIntleaveEnable(a2),d0	; read the 12 bit register at the base of DJMEMC/Orwell			andi.w	#$0E00,d0					; mask out all bits except version bits at bit 11..9						cmpi.w 	#$0200,d0					; the version number for djmec is 010 for bits 11..9						beq.s	@tryCentris610				; if equal than on djmec machine..via id bits will match												; those for wombat machines			@tryQ700			cmpi.b	#$40,d1						; is it a quadra700			bne.s	@tryQ900			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1235,D0					;	return emulator CPU ID			BRA		@success		@tryQ900			cmpi.b	#$50,d1						; is it a quadra900			bne.s	@tryQ950			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1236,D0					;	return emulator CPU ID			BRA		@success	@tryQ950	; if here it must be Q950			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1237,D0					;	return emulator CPU ID			BRA		@success	@tryCentris610				cmpi.b	#$40,d1						; is it a Centris610?			bne.s	@tryCentris650			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1204,D0					;	return emulator CPU ID			BRA		@success	@tryCentris650				cmpi.b	#$46,d1						; is it a Centris650?			bne.s	@tryQ800			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1200,D0					;	return emulator CPU ID			BRA		@success	@tryQ800				cmpi.b	#$12,d1						; is it a Quadra800?			bne.s	@tryQ610			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1201,D0					;	return emulator CPU ID			BRA		@success@tryQ610				cmpi.b	#$44,d1						; is it a Quadra610?			bne.s	@tryQ650			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1202,D0					;	return emulator CPU ID			BRA		@success@tryQ650	;if here assume Smurf card is in Q650			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center					$1203,D0					;	return emulator CPU ID			BRA		@success		ENDIF								; forSmurf			LEA		CPUIDReg,A2				; Get CPU ID reg address											; FIRST - try to read it as a LONG.   <SM43>,<SM44>			MOVE.L	(A2),D0					; read the register (bus err if it doesn't exist)			MOVEQ	#0,D1					; clear pattern register@FlipBits									; LOOP (to write different patterns in CPUID reg)			MOVE.L	D1,(A2)					;	write next pattern to CPUID register location			CMP.L	(A2),D0					;	does it read back the same as the first time?			BNE.S	@tryPDMIDReg			;	-> no.  try reading it the other way.			NOT.L	D1						;	flip the bits in the write pattern			BNE.S	@FlipBits				;	-> try the next write pattern			SWAP	D0						;	look at the signature			CMPI.W	#cpuIDSig,D0			;	is it a valid signature?			BNE.S	@tryPDMIDReg			;	-> no.  try reading it the other way.			SWAP	D0						;	look at the decoder-specific stuff			bra		@success				; yay, we're done.@tryPDMIDReg								; SECOND - see if it's a byte-wide only reg (like on PDM)			move.b	(a2), d0				; read high byte (bus err if it doesn't exist)			move.b	#$6a, (a2)				; write/read to be sure it's really there			cmp.b	(a2), d0				; match previous read?			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.			lsl.l	#8, d0					; shift high byte over						move.b	1(a2), d0				; read next byte			move.b	#$6f, 1(a2)				; write/read to be sure it's really there			cmp.b	1(a2), d0				; match previous read?			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.			lsl.l	#8, d0					; shift next byte over						move.b	2(a2), d0				; read next byte			move.b	#$65, 2(a2)				; write/read to be sure it's really there			cmp.b	2(a2), d0				; match previous read?			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.			lsl.l	#8, d0					; shift next byte over						move.b	3(a2), d0				; read last byte			move.b	#$20, 3(a2)				; write/read to be sure it's really there			cmp.b	3(a2), d0				; match previous read?			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.						swap	d0						; check the signature			cmpi.w	#cpuIDSig, d0			; is it valid?			bne		@noCPUIDReg				; nope, exit with Z cleared.			swap	d0						; yay!  we're probably a PDM!  (how cool if we are.)			cmpi.w	#$3010, d0				; could we be an EVT2 but don't know it? <SM45>			bne		@success				; nope						move.b	$50F32008, d1			; read SCSI DMA ctl reg			movea.w	d1, a2					; remember the original setting			ori.b	#$0C, d1				; poke the extra bits			move.b	d1, $50F32008			; save the updated value			nop			move.b	$50F32008, d1			; read SCSI DMA ctl reg again			andi.b	#$0C, d1				; did they stick?			beq.s	@success				; nope, don't dick with the CPUID			move.w	a2, d1					; restore the original setting			move.b	d1, $50F32008						nop@ck4FastSCSI			move.b	#$02, $50f11030			; do cResetChip cmd			nop			move.b	#$00, $50f11030			; cNOP required after HW or SW reset			move.b	#$40, $50f110b0			; turn on Features enable then,			move.b	#$80, $50f11030			; send a DMA NOP command then,			nop			cmp.b	#$A2, $50f110e0			; read the SCSI chip ID - an FC96?			beq.s	@isFastSCSI				; yes -> we have Fast SCSI (i.e. we're on a Cold Fusion)@noFastSCSI						move.b	#$02, $50f11030			; cResetChip again			nop			move.b	#$00, $50f11030			; cNOP required after HW or SW reset			move.b	#$11, d0				; we're an AMIC2 - change CPUID to $3011 			bra.s	@success				; @isFastSCSI			move.b	#$02, $50f11030			; cResetChip again			nop			move.b	#$00, $50f11030			; cNOP required after HW or SW reset			move.b	#$13, d0				; we're a Cold Fusion - change CPUID to $3013 @success			IF forSTP601 THEN			ori.w #(cpuIDRISC),d0		ENDIF			CMP.W	D0,D0					;	set ccr.z to indicate success@noCPUIDReg	JMP		(A6)					; END	ENDIF									; <SM24> rb			end