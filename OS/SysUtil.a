;__________________________________________________________________________________________________;;	File:		SysUtil.a;;	Contains:	This file contains system utility core routines: ReadParam, WriteParam,;				ReadDateTime, SetDateTime, InitUtil, Delay, CmpString;;	Written by:	Larry Kenyon;;	Copyright © 1982-1993 by Apple Computer, Inc.  All rights reserved.;;	Change History (most recent first):;;	  <SM10>	10/25/93	SAM		Roll in <MC2> from mc900ftjesus.;	   <MC2>	10/25/93	SAM		Changed InitUtil to explicitly set the memory manager PRAM;									location to a nonzero default (Figment on, 32 bit heaps).;									Changed the default mouse speed setting from 2 to 3.;	   <SM9>	 6/21/93	SAM		Changed the comparison in _Delay to be unsigned (ugh) and bumped;									the default disk cache size from 32 to 96k.;	   <SM8>	 6/14/93	kc		Roll in Ludwig.;	   <LW2>	 6/11/93	chp		Replace the Reliability Manager’s Time Manager task with a;									_DTInstall of the original task code. It is better to call;									_ReadXPram and _WriteXPram with interrupts enabled since;									interrupts are used to communicate with Egret/CUDA.;	   <SM7>	 1/29/93	RB		Made the Delay trap compatible with NuKernel by changing the way;									it uses the status register.;	   <SM6>	10/18/92	CCH		Added NoSound conditional for build-time zeroing of volume.;	   <SM5>	 9/28/92	RB		The old Sound Manager used to update the low mem global;									sdVolume, but the new one does not. So I chose the ReadPram and;									WritePRam routines to update sdVolume after the volume level is;									changed by the Control Panel, which writes PRAM. Removed the;									NoSound code used for Cyclone bringup.;	   <SM4>	 6/29/92	RB		Re-enable sound for the New New Sound Manager.;	   <SM3>	 5/28/92	kc		Roll in Horror Changes. Comments Follow:;		<P3>	 5/13/92	KW		(HJR,H7) Fix problem in InitCPHardware where it was calling a;									RAMless routine without having the return address in A6.;		<P2>	02/12/92	jmp		•••Temporarily set the default sound volume to zero to effectively•••;									disable sound on Cyclone.;		<H6>	11/12/91	jmp		Just went back and marked my previous change.;		<H5>	11/12/91	jmp		Changed the pRAM table to default to having the color desktop;									pattern enabled for CQD-capable CPUs.;		<H4>	 11/6/91	SWC		Re-wrote clock and PRAM routines to be table-driven so that;									future expansion should be really simple (and clean). Hardware;									dependent routines will now be found in ClockPRAMPrimitives.a.;		<H3>	10/18/91	SWC		Exported ReadTime so the ROM will link (changes in progress;									caused a little problem with sources out of sync).;		<H2>	  8/6/91	SWC		Modified ReadPRAM and WritePRAM so they use extended PRAM calls;									to get the original 20 PRAM bytes.;	   <SM2>	 5/21/92	kc		Append "Trap" to the names of;									SysEnvirons,WriteParam,ReadDateTime,SetDateTime,UprString and;									RelString to avoid name conflict with the glue.;		<10>	  9/9/91	JSM		Cleanup header, use SysEnvirons stuff defined in SysEqu.a;									instead of redefining it here.;		 <9>	 6/12/91	LN		Changed #include 'HardwareEqu.a' to 'HardwarePrivateEqu.a';		 <8>	 7/23/90	MSH		WriteParam did the read back verify all wrong.;		 <7>	 3/22/90	MSH		SysUtil and Clock rewritten to place all hardware dependent;									routines in clock and to remove redundant parameter RAM reading;									and writing routines. Also added Waimea versions of these;									routines.;		 <6>	 2/28/90	GMR		Made changes for Egret code to match new Egret equates.;		 <5>	 2/10/90	GMR		Put in temporary fix for Egret, using Wr6805Addr instead of;									WrPram.;		 <4>	  2/5/90	GMR		Added Egret clock support to ReadTime, WriteTime, and ReadPram,;									WritePram, making them universal.;		 <3>	  1/3/90	CCH		Changed Gestalt equate filename back to GestaltEqu.a.;		 <2>	  1/2/90	CCH		Changed name of Gestalt equate file.;	   <3.7>	11/13/89	MSH		Pmgr equates now in record format.;	   <3.6>	 8/28/89	PKE		Delete LwrString from this file and just use the one in the;									Script Manager file ScriptMgrPAtch.a (same code, no sense in;									duplicating it here; should have done this a long time ago).;									Also delete include of PackMacs.a, ScriptPriv.a.;	   <3.5>	 8/27/89	PKE		Deleted local newItl2Tables symbol (used for LwrString, was set;									to 1 here) and cleaned up conditionals based on it.;	   <3.4>	 8/24/89	PKE		FOR F-19, WE SHOULD DO CHANGE #2 HERE: Rolling in changes from;									patch files: (1) Change LwrString to save IntlForce flag then;									clear it before IUGetIntl call, restoring it afterward. This is;									so we get the itl2 tables for the correct script (instead of the;									tables for the system script). (2) Put UpperTab bug back in (was;									removed in 1.5) so file system sorting via RelString works on;									old volumes.;	   <3.3>	 8/22/89	SES		Removed references to nFiles. Changed EnvBadSel & EnvSelTooBig;									to EnvBadVers and EnvVersTooBig.;	   <3.2>	  8/9/89	CCH		Changed gestaltQuickdrawType to gestaltQuickdrawVersion.;	   <3.1>	 7/16/89	CCH		NEEDED FOR AURORA: Made SysEnvirons check Gestalt error codes.;	   <3.0>	  7/8/89	PKE		NEEDED FOR AURORA: Fixed error code returned by LwrString if;									'itl2' not found.;	   <2.9>	 6/20/89	SWC		Changed default mouse tracking from 0 (tablet) to 3;									(medium-slow) so the mouse won't move like a slug when parameter;									RAM gets reset. Also to make Ed Birss happy, I hear.;	   <2.8>	 6/14/89	SWC		Missed an '@' on a label. I know: "bad dog!";	   <2.7>	 6/14/89	SWC		Exported PRAMInit and PRAMInitTbl so they can be used by;									ValidatePRAM (Clock.a). Reformatted the PRAMInit table to make;									it more readable. Cleaned up code.;	   <2.6>	  6/5/89	PKE		In LwrString, add more error checking after IUGetIntl call and;									set error return if necessary.;	   <2.5>	 5/25/89	CCH		Revised again to deal with new Gestalt equates.;	   <2.4>	 5/25/89	rwh		added the aptly named Reliability Manager;	   <2.3>	 5/24/89	GGD		Converted to feature based conditionals.;	   <2.2>	 5/23/89	CCH		Added check of Gestalt return codes to detect unknown results.;	   <2.1>	 5/18/89	CCH		Updated SysEnvirons to use new Gestalt interface.;	   <2.0>	 4/16/89	CCH		Changed Gestalt equates to new prefix convention.;	   <1.9>	  4/7/89	PKE		Updated LwrString to use noMarkListOffset instead of;									lowerNoMarkListOffset.;	   <1.8>	 3/28/89	PKE		Use OS trap bits 9-10 to control function of LwrString;	   <1.7>	  3/6/89	CCH		Fix some minor bugs in SysEnvirons.;	   <1.6>	  3/3/89	CCH		Gutted SysEnvirons, and replaced it with calls to Gestalt.;	   <1.5>	  3/1/89	PKE		Save & restore a2 in LwrString; fixed err in UpperTab (UprString;									gave 'a' as the uppercase of '`').;	   <1.4>	 2/28/89	PKE		Revert UprString to version from Mac IIx ROMs, which doesn't;									move memory or depend on a5 world (the planned version could;									have done both).;	   <1.3>	 2/21/89	PKE		Fix LwrString/UprString to get char class & case conversion;									tables from itl2, not itlR (itlR is going away and these tables;									are being moved to a newly extended itl2). Note: changing;									UprString to get tables from any resource could break apps, so;									it will be reverted to to an old, non-International version as;									soon as I find the old source. All the Intl stuff will be done;									thru enhancements to LwrString.;	   <1.2>	 1/16/89	GGD		Added a scratch register parameter to the BigJSR macro calls;									since it will be needed when they change to use PC relative;									addressing.;	   <1.1>	11/10/88	CCH		Fixed Header.;	   <1.0>	 11/9/88	CCH		Adding to EASE.;	   <1.2>	10/27/88	PKE		modified by Carl Hewitt and Brian McGhie as part of the process;									of putting Script Manager in ROM;	  <•1.1>	 9/23/88	CCH		Got rid of inc.sum.d and empty nFiles;	   <1.0>	 2/10/88	BBM		Adding file for the first time into EASE…;	  <C982>	 12/2/87	JTC		Add SysEnvirons trap from patches as new PROC here.;	  <C914>	10/29/87	rwh		Port to Modern Victorian;	  <C919>	10/27/87	MSH		Bug fixes and added a retry to writetime.;	  <C881>	  9/3/87	MSH		Port to HcMac (Laguna). Also removed some leftover trash at the;									end of the file.;	  <C774>	  2/9/87	SHF		Changed parameter RAM initialization value for boot device: now;									defaults to SCSI ID 0 (internal).;	  <C551>	12/19/86	GWN		Extended PRAM init table.;	  <C518>	12/12/86	GWN		Replaced 'Bugs' with 'NuMc' to determine when PRAM is to be;									initialized with the data in PRAMInitTbl (instead of zeros).;	  <A368>	 11/7/86	bbm		added an async patch mech.;	  <C206>	 10/9/86	bbm		Modified to mpw aincludes.;				 2/19/86	BBM		Made some modifications to work under MPW;				10/30/85	LAK		Incorporated init of new parameter RAM into InitUtil. Set bit 5;									(13) of Hardware vector if parameter RAM was valid at boot.;				 10/3/85	BBM		added three new Defs for new clock.text;				 7/24/85	RDC		Deleted ClkRW routine (moved to new Clock.text) Changed BSR to;									JSR for ref's to ClkRW routine;				  6/7/85	JTC		Modified to return long to OS dispatcher. <07Jun85>;				 2/27/85	JTC		Add RelString to return -1,0,1 (<,=,>) rather than simply 0,1.;									Increase size, but speed, too. Marked... <27Feb85>;				 1/31/85	LAK		Removed false RTE. Exclude all ints when talking to clock chip.;				 1/23/85	LAK		Adapted for new equate files.;				  9/5/83	SC		Changed default volume control to 3; changed init.;				 8/22/83	LAK		Init port A parameter RAM to 9600 baud, etc.;				 8/21/83	SC		Fixed "" "".;				 8/20/83	LAK		Added new parameter ram stuff and changed init.;				 8/17/83	JTC		changed CmpString, UprString for international character sets.;				 8/17/83	LAK		initutil nolonger mucks with the time if param ram check byte is;									invalid. serial port a is no longer initialized to async.;				 5/25/83	LAK		changed CmpString, UprString to general-purpose string;									operators.;				 4/29/83	LAK		changed param ram cksum byte to $A6 to reset all machines.;				 4/27/83	LAK		corrected serial port init values for 2 stop bit (not 1 1/2);				 4/19/83	LAK		added UprString routine; put in SCC config values for default;									param mem init (9600 baud, 8 data, 2 stop, no parity: both;									ports).;				  4/4/83	AJH		changed initial value of misc2 param byte;				 3/10/83	LAK		Updated defaults for font, menu flash, volume control.;				  3/8/83	LAK		Fixed bug in Delay.;				  3/3/83	LAK		Updated documentation on CmpString.;				 2/17/83	LAK		ReadParam and WriteParam now preserve A2. InitUtil writes;									initial values to clock chip if it was not initialized. Added;									read verify to WriteParam. InitUtil is now a trap and observes;									Pascal regsave conventions.;				 2/10/83	LAK		moved clock chip r/w procs here from boot code.;				  2/4/83	LAK		put delay back in.;				 1/12/83	LAK		removed Alert, Delay, and CoreWakeUp.;				 6/10/82	LAK		SetDateTime now sets CLasTime to Ticks value.;				  6/9/82	ALO		added Alert proc;				  6/7/82	LAK		added an initialization routine which reads the clock.;				 5/27/82	LAK		changed ReadDateTime, SetDateTime to use keyboard driver to do;									the work; ReadParam, WriteParam, ReadDateTime, SetDateTime;									interfaces have all been changed.;				 5/26/82	LAK		changed ReadParam to read copy in memory instead of clock ram;									changed WriteParam to use keyboard driver to do the work;__________________________________________________________________________________________________			BLANKS		ON			STRING		ASIS			LOAD		'StandardEqu.d'			INCLUDE		'HardwarePrivateEqu.a'			INCLUDE		'InternalOnlyEqu.a'			INCLUDE		'GestaltEqu.a'			INCLUDE		'IOPrimitiveEqu.a'			INCLUDE		'ReliabilityEqu.a'			INCLUDE		'UniversalEqu.a'		IF &TYPE('NoSound') = 'UNDEFINED' THENNoSound		EQU	0									; If conditional isn't set, default to sound on	<SM6>		ENDIFSysUtil 	PROC		EXPORT				EXPORT		ReadParam,WriteParamTrap,ReadDateTimeTrap,SetDateTimeTrap			EXPORT		InitUtil,DelayTrap,CmpString,UprStringTrap,RelStringTrap			EXPORT		ASyncPatch			EXPORT		PRAMINITTBL,PRAMINIT,READTIME			PRINT		NOGEN;______________________________________________________________________;; Routine:		ASyncPatch; Arguments:	none; Function:		none;;______________________________________________________________________ASyncPatch											; <A368>				rts									; <A368>;______________________________________________________________________;; Routine:		  ReadParam;					A0 (input)	-- pointer to buffer which returns parameters;					D0 (input)	-- bits 0-19 indicate which of parameter bytes;									 0-19 to return in the buffer.	bytes are;									 returned in 0-19 order.; Arguments:		D0 (output) -- result code; Function: 	  This routine returns the requested bytes from the copy;				  of parameter ram kept in low memory (SysParam).;;______________________________________________________________________ReadParam	LEA 	SysParam,A1 		; ptr to parameter ram copy in memory			BSR.S	XferPRam			; return requested bytes			MOVEQ	#0,D0				; never any errors			RTSXferPRam	MOVEQ	#20-1,D2			; D2 is the loop counter (for 20 bytes . . .)XPLoop		LSR.L	#1,D0				; read a byte for each one set			BCC.S	@1					; skip if bit is not set			MOVE.B	(A1),(A0)+			; load the next byte in return buffer@1			ADDQ.L	#1,A1				; incr pointer into parameter ram			DBRA	D2,XPLoop			RTS;______________________________________________________________________;; Routine:		WriteParam; Input:		A0 (input) -- pointer to PRAM buffer; Arguments:	D0 (output) -- result code; Function: 	This routine writes the parameter ram copy in SysParam ;				to the clock chip and then reads it back to verify.;______________________________________________________________________WriteParamTrap			MOVEM.L	A0/A1,-(SP)			; save copy of original pointer			BSR 	WritePram			; write out SysParam to the chip		<30Oct85> LAK			LEA 	GetParam,A1 		; now read it back to verify			BSR 	ReadPram			; use our special scratch area			LEA 	SysParam,A0 		; point to original data			MOVEQ	#PRWrErr,D0 		; assume parameter ram write error			MOVEQ	#20/4-1,D2			; loop count for 5 longs@2			CMPM.L	(A0)+,(A1)+			BNE.S	@3					; exit on compare error			DBRA	D2,@2			MOVEQ	#0,D0				; no errors@3			MOVEM.L	(SP)+,A0/A1			; restore copy of original pointer			RTS;______________________________________________________________________;; Routine:		  ReadDateTime;					A0 (input)	-- pointer to buffer in which time is returned; Arguments:		D0 (output) -- result code; Function: 	  This routine updates Time in memory and then writes;				  it out to the clock chip.;;______________________________________________________________________ReadDateTimeTrap			BSR 	ReadTime			MOVE.L	Time,(A0)			; give it back to requester in buffer			RTS;______________________________________________________________________;; Routine:		  SetDateTime; Arguments:		D0 (input)	--	32-bit value to write to clock;					D0 (output) --	result code; Function: 	  This routine updates Time in memory and then writes;				  it out to the clock chip.;;______________________________________________________________________SetDateTimeTrap			MOVE.L	D0,Time 			; update the time variable in memory			BRA 	WriteTime			;;______________________________________________________________________;; Routine:		  Delay; Arguments:		A0 (input)	--	number of tick counts to delay;					D0 (output) --	value of Ticks after delay;					interrupt level 0 is set; Function: 	  Delay is a simple routine which just waits the;				  specified number of ticks (each tick is 1/60 second).;;______________________________________________________________________DelayTrap	ANDI.W 	#$F8FF,SR			; have to let interrupts in 			<SM7> rb			MOVE.L	Ticks,D0			ADD.L	A0,D0@1			CMP.L	Ticks,D0			; have enough ticks ticked?			BHI.S	@1					; -> No. Keep waiting.			<SM9> (now use unsigned comparison)			RTS;______________________________________________________________________;; Routine:		  UprString; Arguments:		D0.W (input)  --  string length;					A0.L (input)  --  pointer to string to canonize;					Opcode bit 10 --  0 - map to upper case; 1 - case sensitive;					Opcode bit	9 --  0 - diacritical sensitive; 1 - strip diacrits;					All registers are preserved.; Function: 	  UprString is a utility routine which, according to;				  a pair of input booleans, strips diacritical marks;				  and/or maps all characters to upper case.;; Reverted to this version from Mac IIx ROMs; removing .S on a BRA and BSR <02/28/89 pke>;______________________________________________________________________UprStringTrap;; Register usage:;		D0 = string length = loop index;		D1 = trap opcode, with booleans;		D2 = string input/output buffer;;		A0 = string 0 pointer;				BSR				EntString				; changed 				BRA.S			USLoopEntryUSLoopTop;; Get next character, canonize it, and replace it.;				MOVE.B			(A0),D2				BSR.S			Canonizer				MOVE.B			D2,(A0)+USLoopEntry				DBRA			D0,USLoopTop				MOVEQ			#0,D0					; don't risk interp of error				BRA				ExtString;______________________________________________________________________ 				<27Feb85>...;; Routine:		  CmpString, RelString; Arguments:		D0.L (input)  --  high-order word = string 0 length;									   low-order word = string 1 length;					A0.L (input)  --  pointer to string 0;					A1.L (input)  --  pointer to string 1;					D0.W (output) --;						CmpString --  result code = 0, 1 for equal, unequal.;						RelString --  result code = -1, 0, 1 according as string 0		<27Feb85>;										is <, =, > than string 1, respectively.;					Opcode bit 10 --  0 - map to upper case; 1 - case sensitive;					Opcode bit	9 --  0 - diacritical sensitive; 1 - strip diacrits;					Pascal register conventions are observed.;; Calling Sequence for Pascal strings:;					LEA 	  str0,A0;					LEA 	  str1,A1;					MOVEQ	  #0,D0;					MOVE.B	  (A0)+,D0;					SWAP	  D0;					MOVE.B	  (A1)+,D0;					_CmpString;; Function: 	  CmpString is a utility routine to compare two strings for;				  equality.  The strings are pointed to by A0 and A1;				  on entry; the result is returned in D0.;				  Two booleans determine the flavor of the compare:;					Marks --;						if set, all diacritical marks are ignored.;					Case --;						if set, all characters are mapped to upper case.;______________________________________________________________________;; To expedite CmpString, test for length differences first.  If they're the same,; use the absolute value of RelString's return.;CmpString				MOVE.W			D0,D2					; str 1 length				SWAP			D0						; str 0 length				CMP.W			D0,D2				BNE.S			CSQuickNE				SWAP			D0						; realign for fresh start in RelString				BSR.S			RelStringTrap			; count on CCR from last D0 store				BPL.S			@1				NEG.L			D0						; -1 ---> 1@1				RTSCSQuickNE				MOVEQ			#1,D0					; must differ since lengths do				RTS;; Register usage:;		D0 = shorter string length = loop index;		D1 = trap opcode, with embedded booleans;		D2 = string 0 input buffer;		D3 = string 1 input buffer;		D4 = -1, 0, 1 according to string lengths;;		A0 = string 0 pointer;		A1 = string 1 pointer;; Output:;		D0 = -1, 0, 1;		CCR reflects D0;		D1-D2/A0-A1 trash;RelStringTrap				BSR.S			EntString;; Prime D4 to be -1, 0, 1 according to string 0 being shorter, equal, longer than string 1.; Get shorter string length into D0.;				MOVEQ			#0,D4					; presume they're equal				MOVE.W			D0,D2					; str 1 length				SWAP			D0						; str 0 length				CMP.W			D0,D2					; str1len - str0len				BEQ.S			ICLoopEntry 			; D4 and D1 OK!				BHI.S			ICStr1Long				; str1len > str0len (unsigned, of course, Holmes)				MOVEQ			#1,D4					; str0 is longer				MOVE.W			D2,D0					; get shorter length				CMP.W			D4,D4					; set CCR to show EQ				BRA.S			ICLoopEntryICStr1Long				MOVEQ			#-1,D4				CMP.W			D4,D4					; set CCR to show EQ				BRA.S			ICLoopEntry;; Get next characters, canonize, and compare them.; *********** NOTE: Must enter loop at ICLoopEntry with CCR indicated EQ!!!! **********;ICLoopTop				MOVEQ			#0,D2					; clear hi bits for Canonizer				MOVE.B			(A0)+,D2				BSR.S			Canonizer				ADD.W			D2,D2					; need word index				MOVE.W			0(A3,D2.W),D3			; D3.W := canonical string 0 char				MOVEQ			#0,D2				MOVE.B			(A1)+,D2				BSR.S			Canonizer				ADD.W			D2,D2				CMP.W			0(A3,D2.W),D3			; string 0 char - string 1 charICLoopEntry				DBNE			D0,ICLoopTop			; fall through if NE or exhausted;; Falling through means chars found unequal above, or shorter string exhausted.; The DBNE leaves CCR untainted, so use it!;				BEQ.S			ICEqual 				; strings = to end; let D4 decide...				BHI.S			ICHigh				MOVEQ			#-1,D0					; str0 < str1				BRA.S			ICExitICHigh				MOVEQ			#1,D4					; str0 > str1, fall through...ICEqual				MOVE.L			D4,D0ICExit				BRA.S			ExtString;______________________________________________________________________;; Utility Canonizer looks at bits in D1.W (Dxxx xxxx Cxx1 010x); maps the character in D2.B to some canonical form.;; Input: D2.B = character to be mapped, with high bits of D2.W zero.; Output: D2.B;______________________________________________________________________Canonizer				TST.W			D1				; MI-strip PL-keep				BPL.S			dontStrip				MOVE.B			StripTab(D2.W),D2dontStrip				TST.B			D1				; PL-upper MI-keep				BMI.S			dontUpper				MOVE.B			0(A2,D2.W),D2	; UpperTab in A2dontUpper				RTS;______________________________________________________________________;; Utility EntString saves regs D3-D4/A2-A3, sets up opword for quick; test in Canonizer, and primes A2 with UpperTab and A3 with CmpTab.; D2 is cleared for use by Canonizer.;; Utility ExtString cleans up and returns, leaving CCR.  It is jumped to...;______________________________________________________________________EntString				MOVE.L			(SP)+,D2				; return address				MOVEM.L 		D2-D4/A2-A3,-(SP)		; return on top				LEA 			UpperTab,A2				LEA 			CmpTab,A3;; Opword = 1010 xCDx xxxx xxxx , where C=caseBit and D=diacBit.  Align to form;		   Dxxx xxxx Cxx1 010x to facilitate testing D and C.;				ROL.W			#6,D1					; Dxxx xxxx xx10 10xC				ROR.B			#1,D1					; Dxxx xxxx Cxx1 010x				MOVEQ			#0,D2					; clear hi bits for Canonizer				RTSExtString				MOVEM.L 		(SP)+,D3-D4/A2-A3				RTS;; Handy macro allows for ease in building big, regular tables.; ASSEMBLER WON'T ALLOW EIGHTH ARGUMENT ON SAME LINE!!!!!!!!!!!!!!;		MACRO				crow		DC.B	(&Syslst[1]),( &Syslst[1]+1),( &Syslst[1]+2),( &Syslst[1]+3),( &Syslst[1]+4),( &Syslst[1]+5),( &Syslst[1]+6)		DC.B	(&Syslst[1]+7)		ENDM		MACRO				dcrow		crow	&Syslst[1]		crow	&Syslst[1]+8		ENDM;_________________________________________________________________________________________________________;StripTab; No diacriticals in low ASCII.		dcrow	$00		dcrow	$10		dcrow	$20		dcrow	$30		dcrow	$40		dcrow	$50		dcrow	$60		dcrow	$70; Diacritical city.		DC.B	('A'),( 'A'),( 'C'),( 'E'),( 'N'),( 'O'),( 'U'),( 'a')		DC.B	('a'),( 'a'),( 'a'),( 'a'),( 'a'),( 'c'),( 'e'),( 'e')		DC.B	('e'),( 'e'),( 'i'),( 'i'),( 'i'),( 'i'),( 'n'),( 'o')		DC.B	('o'),( 'o'),( 'o'),( 'o'),( 'u'),( 'u'),( 'u'),( 'u'); O-slash at end.		crow	$A0		DC.B	$A8, $A9, $AA, $AB, $AC, $AD, $AE,( 'O'); a-under, o-under, and o-slash.		crow	$B0		DC.B	$B8, $B9, $BA,( 'a'),( 'o'), $BD, $BE,( 'o'); Diacrits at end.		crow	$C0		DC.B	$C8, $C9, $CA,( 'A'),( 'A'),( 'O'), $CE, $CF; Beware of y-umlaut, CHANGE  FROM MAC-1		crow	$D0		DC.B	('y'), $D9, $DA, $DB, $DC, $DD, $DE, $DF		dcrow	$E0		dcrow	$F0; End of StripTab;_________________________________________________________________________________________________________;_________________________________________________________________________________________________________;UpperTab; Special chars, punctuation, digits, upper-case letters.		dcrow	$00		dcrow	$10		dcrow	$20		dcrow	$30		dcrow	$40		dcrow	$50; Lower-case letters and some symbols.; fixed bug in which "`" is upper-cased as "a"								<02/29/89 pke>; restored above bug, so "`" ($60) goes to "a" ($61); needed for HFS.	<3.4><08/24/89 pke>		DC.B	$61,( 'A'),( 'B'),( 'C'),( 'D'),( 'E'),( 'F'),( 'G')		crow	$48		crow	$50		DC.B	('X'),( 'Y'),( 'Z'), $7B, $7C, $7D, $7E, $7F; Accented characters.		crow	$80		DC.B	$CB, $89, $80, $CC, $81, $82, $83, $8F		DC.B	$90, $91, $92, $93, $94, $95, $84, $97		DC.B	$98, $99, $85, $CD, $9C, $9D, $9E, $86; Symbols and upper-case AE and O-slash		dcrow	$A0; Symbols and ae, o-slash		crow	$B0		DC.B	$B8, $B9, $BA, $BB, $BC, $BD, $AE, $AF; Symbols, upper A-acute, A-tilde, O-tilde, OE, and oe		crow	$C0		DC.B	$C8, $C9, $CA, $CB, $CC, $CD, $CE, $CE; Symbols and undefineds.  y-umlaut cannot map up.		dcrow	$D0		dcrow	$E0		dcrow	$F0; End of UpperTab;_________________________________________________________________________________________________________;; Entries in the CmpTab are given as words, with the "root" char in the high byte, and; fine tuning in the low byte.;		MACRO				basec		DC.B	(&Syslst[1]),( $00)		ENDM		MACRO				modc		DC.B	(&Syslst[1]),( &Syslst[2])		ENDM;; Macro baserow sets up a sequence of 8 base characters, that is, with modifier=0.; It's handy for setting up the punctuation and alphabetic characters.; Macro dbaserow just does two rows.;		MACRO				baserow		basec	&Syslst[1]		basec	&Syslst[1]+1		basec	&Syslst[1]+2		basec	&Syslst[1]+3		basec	&Syslst[1]+4		basec	&Syslst[1]+5		basec	&Syslst[1]+6		basec	&Syslst[1]+7		ENDM		MACRO					dbaserow		baserow &Syslst[1]		baserow &Syslst[1]+8		ENDM;; Macro lower11 is a convenience for setting up two-byte entries for a sequence of 11 lower-case; characters.  There are two such sequences: 'a'-'k' and 'p'-'z'.;		MACRO				lower11		modc	&Syslst[1], $80		modc	&Syslst[1]+1, $80		modc	&Syslst[1]+2, $80		modc	&Syslst[1]+3, $80		modc	&Syslst[1]+4, $80		modc	&Syslst[1]+5, $80		modc	&Syslst[1]+6, $80		modc	&Syslst[1]+7, $80		modc	&Syslst[1]+8, $80		modc	&Syslst[1]+9, $80		modc	&Syslst[1]+$A, $80		ENDM;; Macro ldiac takes two args:  a lower case vanilla alphabetic and the name of a diacritical.; It sets up a two-byte table entry with the corresponding upper-case character and a low-order; modifier of the form $80+n where small n depends upon the diacritical in question.  They are ordered; plain < acute < grave < circumflex < umlaut < tilde < circle < slash < cedilla < under < ligature; in order to give as nearly the flavor of the international string comparisons as possible.;		MACRO				ldiac.*		DC.B	(&Syslst[1]-$20).*		IF		&Eval(&Syslst[2]) = 'acute' THEN			   DC.B    ($82)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'grave' THEN			   DC.B    ($84)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'circumflex' THEN			   DC.B    ($86)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'umlaut' THEN			   DC.B    ($88)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'tilde' THEN			   DC.B    ($8A)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'circle' THEN			   DC.B    ($8C)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'slash' THEN			   DC.B    ($8E)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'cedilla' THEN				DC.B   ($90)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'under' THEN			   DC.B    ($92)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'ligature' THEN			   DC.B    ($94)		ENDIF.*		ENDM;; Macro udiac takes two args:  an upper-case vanilla alphabetic and the name of a diacritical.; It sets up a two-byte table entry with the upper-case character and a low-order; modifier of the form n where small n depends upon the diacritical in question.  They are ordered; plain < acute < grave < circumflex < umlaut < tilde < circle < slash < under < ligature; in order to give as nearly the flavor of the international string comparisons as possible.;		MACRO				udiac.*		DC.B	(&Syslst[1]).*		IF		&Eval(&Syslst[2]) = 'acute' THEN			   DC.B    ($02)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'grave' THEN			   DC.B    ($04)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'circumflex' THEN			   DC.B    ($06)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'umlaut' THEN			   DC.B    ($08)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'tilde' THEN			   DC.B    ($0A)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'circle' THEN			   DC.B    ($0C)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'slash' THEN			   DC.B    ($0E)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'cedilla' THEN			   DC.B    ($10)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'under' THEN			   DC.B    ($12)		ENDIF.*		IF		&Eval(&Syslst[2]) = 'ligature' THEN			   DC.B    ($14)		ENDIF.*		ENDM;_________________________________________________________________________________________________________;CmpTab; The control characters are vanilla		dbaserow	$00		dbaserow	$10; Punctuation, digits, and upper case are all base chars		dbaserow	$20		dbaserow	$30		dbaserow	$40		dbaserow	$50; Map lower case up and use punctuation as base chars.		basec		$61		lower11 	$41		modc		$4C, $80		modc		$4D, $80		modc		$4E, $80		modc		$4F, $80		lower11 	$50		basec		$7B		basec		$7C		basec		$7D		basec		$7E		basec		$7F; Grotesque diacriticals!		udiac	'A', 'umlaut'		udiac	'A', 'circle'		udiac	'C', 'cedilla'		udiac	'E', 'acute'		udiac	'N', 'tilde'		udiac	'O', 'umlaut'		udiac	'U', 'umlaut'		ldiac	'a', 'acute'		ldiac	'a', 'grave'		ldiac	'a', 'circumflex'		ldiac	'a', 'umlaut'		ldiac	'a', 'tilde'		ldiac	'a', 'circle'		ldiac	'c', 'cedilla'		ldiac	'e', 'acute'		ldiac	'e', 'grave'		ldiac	'e', 'circumflex'		ldiac	'e', 'umlaut'		ldiac	'i', 'acute'		ldiac	'i', 'grave'		ldiac	'i', 'circumflex'		ldiac	'i', 'umlaut'		ldiac	'n', 'tilde'		ldiac	'o', 'acute'		ldiac	'o', 'grave'		ldiac	'o', 'circumflex'		ldiac	'o', 'umlaut'		ldiac	'o', 'tilde'		ldiac	'u', 'acute'		ldiac	'u', 'grave'		ldiac	'u', 'circumflex'		ldiac	'u', 'umlaut'; Column $A is cool up to s-zet; then up to AE and O-slash.		basec	$A0		basec	$A1		basec	$A2		basec	$A3		basec	$A4		basec	$A5		basec	$A6		modc	'S', $82		basec	$A8		basec	$A9		basec	$AA		basec	$AB		basec	$AC		basec	$AD		udiac	'A', 'ligature'		udiac	'O', 'slash'; Column $B is cool up to last five.		baserow $B0		basec	$B8		basec	$B9		basec	$BA		ldiac	'a', 'under'		ldiac	'o', 'under'		basec	$BD		ldiac	'a', 'ligature'		ldiac	'o', 'slash'; Column $C has quote special case, non-breaking space, and 5 diacs		basec	$C0		basec	$C1		basec	$C2		basec	$C3		basec	$C4		basec	$C5		basec	$C6		modc	'"', $06		modc	'"', $08		basec	$C9		basec	' ', $02		udiac	'A', 'grave'		udiac	'A', 'tilde'		udiac	'O', 'tilde'		udiac	'O', 'ligature'		ldiac	'o', 'ligature'; Column $D has quotes and y.		basec	$D0		basec	$D1		modc	'"', $02		modc	'"', $04		modc	$27, $02		modc	$27, $04		basec	$D6		basec	$D7		ldiac	'y', 'umlaut'		basec	$D9		basec	$DA		basec	$DB		basec	$DC		basec	$DD		basec	$DE		basec	$DF; Columns $E and $F are vanilla		dbaserow	$E0		dbaserow	$F0; End of CmpTab;_________________________________________________________________________________________________________; the following are lower-level routines which actually access the clock chip;_______________________________________________________________________;; Routine:		ReadPram;; Arguments:	A1 (input)  -- pointer to buffer where 20 bytes are placed;				all regs preserved;; Function: 	All 20 bytes clock pram are read into buffer.;; Notes:		Disables VIA interrupts for long periods of time (60 usec).;_______________________________________________________________________ReadPram	MOVE.L	A0,-(SP)				;												<H2>			MOVE.B	SPVolCtl,D0				; get the sound volume control					<SM5> rb			ANDI.B	#7,D0					; and mask out the sound res ID					<SM5> rb			MOVE.B	D0,sdVolume				; now store it low mem							<SM5> rb						MOVEA.L	A1,A0					;												<H2>			MOVE.L	#(16<<16)+(16<<0),D0	; first 16 bytes are at extended PRAM address 16<H2>			_ReadXPRAM						;												<H2>			LEA		16(A1),A0				;												<H2>			MOVE.L	#(4<<16)+(8<<0),D0		; last 4 bytes are at extended PRAM address 8	<H2>			_ReadXPRAM						;												<H2>			MOVEA.L	(SP)+,A0				;												<H2>			RTS								;												<H2>;_______________________________________________________________________;; Routine:		InitUtil;; Arguments:	D0 (output) -- result code (0 if clock was already initialized);; Function: 	The clock ram and time are read and stored in the low-memory;				buffer used by the clock utility routines.	If the clock ram;				validity bit is not $A8, the values in Time and SysParam are;				initialized.;_______________________________________________________________________InitUtil	CLR.W	-(SP)					; assume no reset of PRam values				<30Oct85> LAK			BSR 	InitCPHardware			; initialize the hardware, if necessary			<H4>			LEA 	SysParam,A1 			; where parameter ram is read to			BSR.S	ReadPram				; read parameter ram and			BSR		ReadTime				; time into SysParam and Time					<C518>			MOVEQ	#0,D0					; assume valid clock data			CMP.B	#$A8,(A1)				; is the clock data valid?			BEQ.S	CkNewPram				; branch if so			MOVE.W	#PRInitErr,(SP) 		; report non-zero result						<30Oct85> LAK			MOVEQ	#4,D1			LEA 	PramInit,A0 			; point to initial values@1			MOVE.L	(A0)+,(A1)+ 			; set parameter ram to initial values			DBRA	D1,@1			BSR 	WritePram				; and put initial values into clk chipCkNewPram	BTST	#6,HWCfgFlags			; new clock chip present?						<30oct85> BBM			BEQ.S	ClkXit					; exit if not									<30oct85> BBM			LEA 	GetParam,A0 			; get pointer to useful buffer					<30oct85> BBM			MOVE.L	#$4000C,D0				; Command to read 4 bytes at addr C 			<30oct85> BBM			_ReadXPRam						;												<30oct85> BBM			MOVE.L	#'NuMc',D1				; put validity bytes into D1					<C518>			CMP.L	(A0),D1 				; is the extra parameter ram valid? 			<30oct85> BBM			BEQ.S	ClkXit					; exit if so									<30oct85> BBM			MOVE.W	#PRInitErr,(SP) 		; report non-zero result						<30Oct85> LAK			MOVE.L	D1,(A0) 				; store out true validity bytes 				<30oct85> BBM			MOVE.L	#$4000C,D0				; Command to write 4 bytes at addr C			<30oct85> BBM			_WriteXPRam 					;												<30oct85> BBM			MOVEQ	#32,D1					; starting address to clear out XPRam			<30oct85> BBM@0			MOVEQ	#4,D0					; number of bytes to write			SWAP	D0						; finish the command byte						<30oct85> BBM			MOVE.W	D1,D0					; get the current address in XPRam				<30oct85> BBM			CLR.L	(A0)					; clear out the buffer							<30oct85> BBM			_WriteXPRam 					;			ADDQ.B	#4,D1					; get the next address to write to ...			<30oct85> BBM											; we want wrap at 256!!!!						<30oct85> BBM			CMP.B	#8,D1					; Check if we wrote the last address			<30oct85> BBM			BNE.S	@0						; if not loop back untill we are done			<30oct85> BBM			MOVEM.L	A1,-(SP)				;Save A1			LEA		PRAMInitTbl,A0			;Copy the data from the PRAMInit table.			<C518>			LEA		GetParam,A1				;  into the GetParam buffer.					<C518>			MOVEQ	#5-1,D0					;Loop 5 times  (20 bytes)						<C518><C779>@10			MOVE.L	(A0)+,(A1)+				;Copy 4 bytes									<C518>			DBRA	D0,@10					;Branch if not done.							<C518>			MOVE.L	#$00140076,D0			;Write 20 bytes beginning at PRAM address $76	<C518><C779>			LEA		GetParam,A0				;  from the buffer								<C518>			_WriteXPRam 					;  into the PRAM.								<C518>	; Write the default memory mgr flags to location $8A.  Since this is the only xpram whose default	; is non zero, we write it explicitly (as opposed to writing a default table full of zeros)			<MC2>			LEA		MMFlags,A0				; Point A0 at the Memory Manager flags lomem				<MC2>			MOVE.B	#MMFlagsDefault,(A0)	; Put the default MMFlags into MMFlags			MOVE.L	#MMPRAMloc,D0			; Write MMFlags to PRAM			_WriteXPRam 					; Store it.			MOVEM.L	(SP)+,A1				;Restore A1ClkXit		MOVE.W	(SP)+,D0				; pass back error code							<30oct85> LAK			BNE.S	@1						; br if we had to reset clock/pram				<30oct85> LAK			BSET	#5,HWCfgFlags			; note the good values							<30oct85> LAK@1			EXT.L	D0						; OS errors are long							<30oct85> LAK			RTS;  original 20-byte parameter RAM initialization valuesPRAMInit	DC.B	$A8						; old PRAM validity byte						<2.7>			DC.B	0						; AppleTalk node ID hint for modem port			<2.7>			DC.B	0						; AppleTalk node ID hint for printer port		<2.7>			DC.B	(0<<4)+(0<<0)			; serial port usage		= neither port in use	<2.7>											; port A config:								<2.7>			DC.W	(3<<14)+ \				; •	stop bits			= 2						<2.7>					(0<<12)+ \				; •	parity				= none					<2.7>					(3<<10)+ \				; •	data bits			= 8						<2.7>					(10<<0)					; •	baud				= 9600					<2.7>											; port B config:								<2.7>			DC.W	(3<<14)+ \				; •	stop bits			= 2						<2.7>					(0<<12)+ \				; •	parity				= none					<2.7>					(3<<10)+ \				; •	data bits			= 8						<2.7>					(10<<0)					; •	baud				= 9600					<2.7>			DC.L	0						; alarm time (midnight, January 1, 1904)		<2.7>			DC.W	Geneva-1				; application font number - 1					<2.7>			DC.B	((24/4)<<4)+ \			; •	auto-key threshold	= 24 ticks				<2.7>					(6/2)					; •	auto-key rate		= 6 ticks				<2.7>			DC.B	0						; •	printer connection	= 0 (printer port)		<2.7>	If NoSound Then							; Kill Sound if build-time conditional is set.	<SM6> cch			DC.B	(0<<7)+ \				; •	alarm enable		= 0 (disabled)					(2<<3)+ \				; •	mouse tracking		= 2	 (medium slow)					0						; •	speaker volume		= 0 (off!)	Else			DC.B	(0<<7)+ \				; •	alarm enable		= 0 (disabled)					(3<<3)+ \				; •	mouse tracking		= 3	 (medium slow)		<MC2>					3						; •	speaker volume		= 3 (medium)	Endif			DC.B	((32/4)<<4)+ \			; •	double-click time	= 32 ticks				<2.7>					(32/4)					; •	caret-blink time	= 32 ticks				<2.7>			DC.B	3						; ram cache size in 32K blocks (96k default)	<SM9>			DC.B	(1<<7)+ \				; •	color desk pattern	= 1 (use if CQD around)	<2.7><H5/6>					(1<<6)+ \				; •	mouse scaling		= 1 (on)				<2.7>					(0<<5)+ \				; • cache active		= 0 (not active)		<2.7>					(0<<4)+ \				; •	preferred boot disk	= 0 (internal drive)	<2.7>					(3<<2)					; •	menu blink			= 3						<2.7>											;Start Manager									<C518>PRAMInitTbl	DC.B	00						;  [$76]		Reserved.						<C518>			DC.B	01						;  [$77]		Default OS.						<C518>			DC.W	$FFFF,$FFDF				;  [$78-$7B]	Default boot.					<C774>														;Sound Manager?									<C518>			DC.W	0						;  [$7C-$7D]	Sound alert id					<C518>														;Menu Manager?									<C518>			DC.B	0						;  [$7E]		Hierar menu dsply				<C518>			DC.B	0						;  [$7F]		Hierar menu drag				<C518>														;Start Manager									<C518>			DC.W	0						;  [$80-$81]	Default video.					<C518>														;Quick Draw										<C518>			DC.W	0,0,0					;  [$82-$87]	Default Hilite Color (black)	<C802>											;Reserved										<C779>			DC.B	0,0						;  [$88-$89]									<C779>;________________________________________________________________________________________;; Routine:	ReadTime;; Inputs:	none;; Outputs:	D0	-	result code;			"Time" contains the 32-bit time value read from the clock;; Trashes:	8 bytes at "GetParam";; Function:	reads the time from the realtime clock;________________________________________________________________________________________ReadTime	MOVEM.L A0/A2-A3/D1-D2/D4-D5,-(SP)	;													<H4>			MOVEQ	#ClkRdErr,D0			; assume an error										<H4>			MOVEA.L	UnivInfoPtr,A0			; point to this machine's product info					<H4>			ADDA.L	ProductInfo.ClockPRAMPtr(A0),A0	;  and get the address of its clock/PRAM table	<H4>			MOVE.L	4*cpReadTime(A0),D1		; get the offset to the routine							<H4>			BEQ.S	@NoEntry				; -> this function is not supported						<H4>			ADDA.L	D1,A0					; calculate the routine's address						<H4>			JSR		(A0)					;  and call it											<H4>			MOVE.L	GetParam,Time			; save the time, good or bad							<H4>@NoEntry	MOVEM.L (SP)+,A0/A2-A3/D1-D2/D4-D5	;													<H4>			TST.W	D0						; set condition codes (for WriteTime)					<H4>			RTS								;														<H4>;________________________________________________________________________________________;; Routine:	WriteTime;; Inputs:	"Time" contains the 32-bit time value to write to the clock;; Outputs:	D0	-	result code:	 0 = no error;									-2 = clock read error;									-3 = time written did not verify;; Trashes:	8 bytes at "GetParam";; Function:	Writes the time to the realtime clock.  The clock is read after write for;			verification; if verification fails, a second attempt is made to read the clock.;________________________________________________________________________________________WriteTime	MOVEM.L A0/D1-D5,-(SP)			;														<H4>			MOVEQ	#ClkWrErr,D0			; assume an error										<H4>			MOVEA.L	UnivInfoPtr,A0			; point to this machine's product info					<H4>			ADDA.L	ProductInfo.ClockPRAMPtr(A0),A0	;  and get the address of its clock/PRAM table	<H4>			MOVE.L	4*cpWriteTime(A0),D1	; get the offset to the routine							<H4>			BEQ.S	@NoEntry				; -> this function is not supported						<H4>			ADDA.L	D1,A0					; calculate the routine's address						<H4>			JSR		(A0)					;  and call it											<H4>@NoEntry	MOVEM.L (SP)+,A0/D1-D5			;														<H4>			RTS								;														<H4>;________________________________________________________________________________________;; Routine:	InitCPHardware;; Inputs:	none;; Outputs:	none;; Trashes:	A0,A1,D0,D1,D2;; Function:	initializes the clock/PRAM hardware, if necessary;________________________________________________________________________________________InitCPHardware								;														<H4>			MOVEM.L A2/A5/A6,-(SP)			;														<H4>			MOVEA.L	UnivInfoPtr,A1			; point to this machine's product info					<H4>			MOVEA.L	A1,A0					;  and get the address of its clock/PRAM table			<H4>			ADDA.L	ProductInfo.ClockPRAMPtr(A0),A0	;												<H4>			MOVE.L	4*cpInitHardware(A0),D1	; get the offset to the routine							<H4>			BEQ.S	@NoEntry				; -> this function is not supported						<H4>			LEA		@NoEntry,A6				; set up return address									<H7>			ADDA.L	D1,A0					; calculate the routine's address						<H4>			JMP		(A0)					;  and call it											<H7>@NoEntry	MOVEM.L (SP)+,A2/A5/A6			;														<H4>			RTS								;														<H4>;_______________________________________________________________________;; Routine:		WritePram;; Arguments:	  SysParam contains the 20 bytes to write.;				  all regs preserved;; Function: 	Writes all 20 bytes of parameter ram from SysParam.;; Notes:		disables VIA interrupts for long periods of time (60 usec);				no verification of write data is done;_______________________________________________________________________WritePram	MOVE.L	A0,-(SP)				;														<H2>						MOVE.B	SPVolCtl,D0				; get the sound volume control							<SM5> rb			ANDI.B	#7,D0					; and mask out the sound res ID							<SM5> rb			MOVE.B	D0,sdVolume				; now store it low mem									<SM5> rb						LEA		SysParam,A0				;														<H2>			MOVE.L	#(16<<16)+(16<<0),D0	; first 16 bytes are at extended PRAM address 16		<H2>			_WriteXPRAM						;														<H2>			LEA		SysParam+16,A0			;														<H2>			MOVE.L	#(4<<16)+(8<<0),D0		; last 4 bytes are at extended PRAM address 8			<H2>			_WriteXPRAM						;														<H2>			MOVEA.L	(SP)+,A0				;														<H2>			RTS								;														<H2>			ENDPROC							;SysUtil						;-----------------------------------------------------------------------------; SysEnvirons call.;;					Fix File	Date	Patch#		Fix Routine(s)	Routine(s) Fixed;AppleSystemPatch 	PatchIIROM.a	28Mar87	#PABM150 	(SysEnvirons) 	(SysEnvirons);; SysEnvirons -- an environs call;; *** Note ***:	SysEnvirons now calls uses the Gestalt call to determine it's ;				information.  Previous versions still operate normally, however,;				the latest (and last) version is updated as Gestalt entries are updated.;;	Register Usage:;;	INPUT;		D0.W: Selector;		A0.L: Pointer to theWorld;;	USAGE;		D0: scratch;		D1: holds requested version number;		D2: holds EnvErr;		A0: scratch;		A2: hold pointer to theWorld!!! Don't touch this !;;	OUTPUT;		D0.W: error code;		A0.L: pointer to theWorld;-----------------------------------------------------------------------------;-----------------------------------------------------------------------------------------; FUNCTION SysEnvirons(VersionRequested: Integer; VAR theWorld: SysEnvRec): OSErr;	<PB302>SysEnvironsTrap	PROC 	EXPORT			;											<PB302>										; Proc header moved up to clear up dupl		<A/UX>										;   label problems.							<PB302>										;-----------------------------------------------------------------------------------------;		Equates;-----------------------------------------------------------------------------------------envTRUE			EQU	1	; IM V1 p.86: "Boolean value in bit 0" -- FALSE EQU 0TheVersion		EQU	2	; Current version of this callMAXINT			EQU	$7fffffff	; max numberSysWDProcID		EQU	'ERIK'	; for use with OpenWDTwoBitsClear	EQU	$3FFF	; for compare below (two high bits clear);-----------------------------------------------------------------------------------------;	The code starts here ;-----------------------------------------------------------------------------------------			WITH 	SysEnvRec			; <10>			MOVEM.L	A0/D2,-(SP)			; save regs			MOVE.L	A0,A2				; Pointer to theWorld;-----------------------------------------------------------------------------------------;   Check for negative selector, or for selector too high -- Selector is in D0 at this point;-----------------------------------------------------------------------------------------			MOVE.W	#EnvBadVers,D2		; assume error number in D2											<3.3>			TST.W	D0					; test the selector			BLE		EXIT				; if less than or equal to zero, then exit						MOVE.W	#noErr,D2			; error return, set to zero for now, MPW will generate CLR.W here			MOVE.W	D0,D1				; save requested version number in D1			CMP.W	#curSysEnvVers,D0	; test to see if requested version was bigger than current version	<10>			BLE.S	GetSize				; if not, then continue			MOVE.W	#EnvVersTooBig,D2	; put error here, but continue										<3.3>			MOVE.W	#SysEnvRec.size,D0	; change this as versions increase (which they won't)				<10>			BRA.S	ZeroWorld			; start filling in;-----------------------------------------------------------------------------------------;-> Since all the environment records for versions 1-2 are the same size, we can;   use the same size for all of them.;-----------------------------------------------------------------------------------------GetSize		MOVE.W	#SysEnvRec.size,D0	; for now, just do this												<10>;-----------------------------------------------------------------------------------------; ZeroWorld;   	routine to zero out bytes of record;;	On Input: 	D0 == bytes to zero;			D1 == requested version;		  	A0 == pointer to the world;		  	A2 == (copy of) pointer to the world;;	Register usage:;			A0 == copy of world pointer;-----------------------------------------------------------------------------------------ZeroWorld			ASR.W	#1,D0			;count by words			SUBQ	#1,D0			;adjust for DebraZeroLoop			CLR.W	(A0)+			;clear next word			DBRA	D0,ZeroLoop		;loop till done.			; now we've zeroed out the recordFillInWorld1			MOVE.W	D1,environsVersion(A2)		; put in version number										<10>;-----------------------------------------------------------------------------------------;   Get MachineType -- assumes 4.1 and later will not even run on 64K ROMs;	so we don't need to check for XLs or even 64K ROM Macs;		WARNING -- if run on old ROMS, this will return Env512KE!!;	this also assumes that future Macs will have 8(ROMBase) > 0 ;;->	Actually get this from _Gestalt.;-----------------------------------------------------------------------------------------GetMachineType				Move.l	#gestaltMachineType,D0		; ask for machine type			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			Beq.s	OkMach						; if not, return result			moveq	#envMachUnknown,A0			; oh well, use SysEnvs bad way of saying unknown			Bra.s	SaveMach			OkMach		Sub.w	#2,A0						; convert gestalt result to sysEnv resultSaveMach	Move.w	A0,machineType(A2)			; save the result in the record								<10>;-----------------------------------------------------------------------------------------;  SYSTEM VERSION code;-----------------------------------------------------------------------------------------			Move.l	#gestaltSystemVersion,D0	; ask for system version			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			Beq.s	@ok							; if not, return result			sub.l	a0,a0						; otherwise, return zero@ok			Move.w	A0,systemVersion(A2)		; no problem, dude..										<10>;-----------------------------------------------------------------------------------------;   Get Processor Stuff ;-----------------------------------------------------------------------------------------			Move.l	#gestaltProcessorType,D0	; ask for processor type			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			Beq.s	OkProc						; if not, return result			moveq	#envCPUUnknown,A0			; oh well, use SysEnvs bad way of saying unknownOkProc		Move.w	a0,processor(A2)			; save it													<10>;-----------------------------------------------------------------------------------------;   HasFPU;-----------------------------------------------------------------------------------------			Move.l	#gestaltFPUType,D0			; ask for fpu type			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			bne.s	NoFPU						; whoops			move.l	a0,d0						; this will be nonzero if an FPU exists, else zero			Beq.s	NoFPU						; oh well.. entry is already zero			Move.b	#envTRUE,hasFPU(A2)			; cool, we have one											<10>NoFPU		;-----------------------------------------------------------------------------------------;   Has ColorQD ;-----------------------------------------------------------------------------------------ColorQD		Move.l	#gestaltQuickdrawVersion,D0	; ask for QD version			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			bne.s	NoCQD						; whoops			move.l	a0,d0						; this will be nonzero if CQD exists, else zero			Beq.s	NoCQD						; oh well.. entry is already zero			MOVE.B	#envTRUE,hasColorQD(A2)		;															<10>NoCQD;-----------------------------------------------------------------------------------------;   Get Keyboard type ;-----------------------------------------------------------------------------------------			Move.l	#gestaltKeyboardType,D0		; ask for keyboard type			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			Beq.s	OkKeyBd						; whew..			moveq	#envUnknownKbd,A0			; oh well, use SysEnvs bad way of saying unknownOkKeyBd		MOVE.W	a0,keyBoardType(A2)			; move in the value and we're done							<10>		;-----------------------------------------------------------------------------------------;   Get AppleTalk Driver Version Number;-----------------------------------------------------------------------------------------			Move.l	#gestaltAppleTalkVersion,D0	; ask for ATalk driver version num			_Gestalt							; ask gestalt for the info			tst.w	d0							; any errors?			Beq.s	@ok							; if not, return result			sub.l	a0,a0						; otherwise, return zero@ok			Move.w	a0,atDrvrVersNum(A2)		; put version number in record								<10>	;-----------------------------------------------------------------------------------------;   Get SysVRef --  returns WDRefNum of directory that contains;			open system file in D0 -- if this call fails, returns 0;	We use GetFCBInfo here -- slower but smaller;;	NOTE -- 4.1 will patch BootDrive code so BootDrive is always accurate;		we still need to use this method because DAs or unscrupulous;		apps may change BootDrive.;;	Assumes system 4.1 and 128K or greater ROMs (HFS);-----------------------------------------------------------------------------------------getSysVRef		Clr.l	D0								; in case we get an error below							Move.w	#(ioHVQElSize/2)-1,D1			; this many CLR.Ws, minus one for the DBRA@1				Clr.w	-(SP)							; push zeros on stack, worse case 2 too many.				DBra	D1,@1							; branch if not done							Move.l	SP,A0							; A0 points to cleared param blk for HFS calls				Move.w  SysMap,ioRefNum(A0)				; get the fileRefNum of System File				_GetFCBInfo								; get info				Bne.s	FixStack						; oops, clean up stack and leave	; now we need to do a PBHGetVInfo call -- we've already established that we're running HFS					Move.w	ioFCBVRefNum(A0),ioVRefNum(A0)	; Thanks Bill B. -- no thanks Inside Mac				_HGetVInfo								; get VFndrInfo (blessed folder's dirID)				Bne.s	FixStack						; oops, clean up stack and leave	; we're OK so far, now we just do a OpenWD, the VRef is set up we just need to ; get the id of the blessed folder from ioVFndrInfo[1] and put it into the dirID; field of the parameter block, and away we go!	VInfoOK			Move.L	ioVFndrInfo(A0),ioWDDirID(A0)	; set up the "blessed folder"				Move.L	#SysWDProcID,ioWDProcID(A0)		; put 'ERIK' into WDProcID				_OpenWD									; open a working directory (probably already open?)				Bne.s	FixStack						; oops, clean up stack and leave				Move.w	ioVRefNum(A0),sysVRefNum(A2)	; put result in parameter block						<10>FixStack		Adda	#ioHVQelSize,SP					; clean up the stack, same count as above.		;-----------------------------------------------------------------------------------------;   End of FillInWorld1  - for future versions (>=2) put checking in here to see how; 				much more to fill in, based on selector passed in in D0;-----------------------------------------------------------------------------------------			ENDWITH		Exit	MOVE.W	D2,D0					; put error number in D0		MOVEM.L	(SP)+,A0/D2				; restore regs, including A0 (pointer to record)		RTS								; return to caller (Return address should be on stack)		ENDPROC							; SysEnvirons								<C982>;----- <2.4>;;	The Reliability Manager ;;	This new "manager" is responsible for monitoring the operation of the machine;	and recording pertinent information in parameter RAM.;;	Written by Bob Herold, May 24, 1989;;-----;-----;	InitReliability - sets time of 1st power on, and initializes the Usage Statistics time ;					  manager task;;	The time of 1st power on is kept as the number of 48 hour periods since Jan 1 1989.  To;	calculate this, we first get the number of seconds since Jan 1 1989.  On 020 and higher;	machines, we could divide by the number of seconds in 48 hours.  To work on 68000;	machines, we separate out factors of two to get the divisor into the 16 bit range:;;			# 48 hrs since Jan 1 1989	= (# secs since Jan 1 1989) / (# secs in 48 hours);										= (# secs) / (60 * 60 * 24 * 2);										= (# secs) / (2*2*15) * (2*2*15) * (2*2*2*3) * 2;										= (# secs) / (15 * 15 * 3) * 2^^8;										= ((# secs) / 2^^8) / (15 * 15 * 3);---						InitReliability	PROC	EXPORT			IMPORT		RelTimeTask, RelDeferredTimeTask						IF hasPowerMgr THEN			rts			ELSE;---;	Initialize the 'time of 1st power on';---			subq		#RelPram>>16,sp				; allocate buffer on stack			move.l		Time,d1						; get current # secs			sub.l		#Jan1st89,d1				; get # secs since Jan 1 1989			blo.s		@doneStart					; if earlier, clock chip set wrong!			movea.l		sp,a0						; get buffer ptr			move.l		#RelPram,d0					; get #, addr PRAM bytes			_ReadXPram								; read 'em and weep			move.l		(sp),d0						; get 'da bytes			and.l		#Rel1stMask,d0				; mask all except 1st powered on time			bne.s		@doneStart					; if already set, do nothing			lsr.l		#8,d1						; divide # secs by 2^^8			divu.w		#15*15*3,d1					; get # 48 hour periods (see comment above)			moveq		#Rel1stBit,d0				; get shift count			lsl.l		d0,d1						; shift our value into position			and.l		#Rel1stMask,d1				; mask unneeded high bits			and.l		#-1-Rel1stMask,(sp)			; zero our bits in result			or.l		d1,(sp)						; overlay our value into result			move.l		#RelPram,d0					; get #, addr PRAM bytes			_WriteXPram								; write out 1st power on time@doneStart	addq		#RelPram>>16,sp				; de-allocate buffer;---;	Set up time manager task for power on time measurement;---			WITH		RelGlobals						moveq		#rlRecSize,d0				; get size Reliability Mgr globals			move.b		d0,d1						; save for later			_NewPtr		,sys,clear					; allocate space for it			bne.s		@done						; don't bother if no room			move.l		ExpandMem,a1				; get ptr to low memory expansion			move.l		a0,ExpandMemRec.emReliability(a1) ; save ptr to Reliability globals there			move.b		d1,rlGlobalsSize(a0) 		; save size of globals			move.b		#rlRecVers,rlGlobalsVers(a0); save version number of globals			bclr		#usRelTaskRun,UnSwitchedFlags; signal we are timing; Initialize a deferred task queue element to schedule execution of the original Time Manager; task, now called RelDeferredTimeTask. Pass a pointer to the Time Manager task in dtParm so; that the original code still gets its expected parameter in A1.			move.w		#dtQType,rlDeferredTask.qType(a0)			lea			RelDeferredTimeTask,a1			move.l		a1,rlDeferredTask.dtAddr(a0)			lea			rlTimeBlock(a0),a1			move.l		a1,rlDeferredTask.dtParm(a0)						lea			rlTimeBlock(a0),a0			; point to time manager task block			lea			RelTimeTask,a1				; point to our time task			move.l		a1,tmAddr(a0)				; stuff it into task block			_InsXTime								; install our task			move.l		#RelMsCount,d0				; get # ms between calls			clr.l		tmWakeUp(a0)				; signal its the first time			_PrimeTime								; fire up time mgr task			@done		rts			ENDWITH									; {RelGlobals}			ENDIF			ENDPROC									; {InitReliability}			;-----;	RelTimeTask - the time manager task for doing all this reliability stuff;;	Called by the Time Manager;;	Entry;		a0 - points to this routine (not too useful, huh?);		a1 - points to task block (now there's something useful!);;;	RelDeferredTimeTask - the deferred Time Manager task for doing all this reliability stuff;;	Called by the Deferred Task Manager;;	Entry;		A1 - dtParm points to the originating Time Manager task block;---RelTimeTask	PROC	EXPORT; If PRAM is in Egret/CUDA, _ReadXPram and _WriteXPram require interrupts enabled; to execute efficiently. Therefore, the periodic Reliability task now uses the; Deferred Task Manager to be more interrupt-friendly.; This helps MIDI SysEx dumps and other interrupt tasks run more punctually.			lea			tmXQSize(a1),a0				; deferred task element follows TM task element			_DTInstall			rts						entry		RelDeferredTimeTaskRelDeferredTimeTask			subq		#RelPram>>16,sp				; allocate buffer on stack			movea.l		sp,a0						; get buffer ptr			move.l		#RelPram,d0					; get #, addr PRAM bytes			_ReadXPram								; read 'em and weep			move.l		(sp),d0						; get 'da bytes			move.l		d0,d1						; save a copy			and.l		#RelPwrMask,d0				; mask to get power on time			addq.l		#1,d0						; increment power on time			and.l		#RelPwrMask,d0				; mask again, in case of rollover			and.l		#-1-RelPwrMask,d1			; zero power on time bits			or.l		d0,d1						; replace the power on time bits			move.l		d1,(a0)						; put new PRAM value in buffer			move.l		#RelPram,d0					; get #, addr PRAM bytes			_WriteXPRAM								; write 'em back			addq		#RelPram>>16,sp				; deallocate buffer			move.l		a1,a0						; get ptr to task block			move.l		#RelMsCount,d0				; get # ms between calls			_PrimeTime								; re-fire up time mgr task			rts			ENDPROC									; {RelTimeTask}					END