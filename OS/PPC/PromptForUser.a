;
;	File:		PromptForUser.a
;
;	Copyright:	© 1986-1992 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	   <SM9>	 11/3/92	SWC		Fixed the change comment in <SM8>.
;	   <SM8>	 11/3/92	SWC		Changed ATalkEqu.a->AppleTalk.a.
;		<24>	 6/29/92	DTY		For ROM and System builds, access IKeyScriptDone through
;									ExpandMem.
;		<23>	 6/25/92	AC		When entering passwords, change KeyScript to Roman if RomanOnly
;									bit in resource is set. Re-sync selection with actual password
;									when entire password gets selected after you've mistyped it.
;									(This corrects bugs with two-byte passwords.)
;		<22>	  6/9/92	JSM		Nuke systemCentersWindow conditional, it’s always true.
;									Integrate changes from SuperMario: In ROM builds or in TheFuture
;									for System builds, use emPPCPromptForUserGlobals instead of
;									pGlobals.
;		<21>	  4/2/92	FM		#1020547 The password filter used to hardcode the bullet '•'
;									character which isn't internationally friendly. Now I set up the
;									bullet character using the itl4 table. The routines to lookup
;									the character are now in PromptForUser.c and were written by
;									Kevin MacDonell
;		<20>	 2/11/91	EMT		VC,82495: Fix bug that prevents backspacing after 8 characters
;									have been typed, Arrow keys now function properly in password,
;									Function keys are now ignored.
;		<19>	 1/14/91	EMT		<VC> Fix more bugs in PromptForUser
;		<18>	  1/4/91	EMT		<VC> Fixed bug that caused some items be be partially drawn when
;									they are supposed to be hidden. Also found and fixed cursor bug.
;									Wrote new efficeint routine MySetCursor.
;		<17>	12/13/90	EMT		<JSM> Support 0 Length String to mean DefaultPrompt in
;									StartSecureSession
;		<16>	 8/23/90	VC		Fixed the handling of "Command-G" in the filter proc. (It was
;									checking the wrong bit for whether trhe guest is disbaled.)
;		<15>	 8/21/90	VC		Disabled "Command-G" when guest is disabled.
;		<14>	 8/18/90	dba		get rid of centering, because Window Mgr. does it now; also, I
;									noticed a lot of stuff (at least two things) that is not
;									internationally friendly, and I marked it with ***; this code
;									desperately needs code review
;		<13>	 8/14/90	VC		Added the handling of Command-G and Command-R.
;		<12>	  8/9/90	S		Changed cmdKey  to cmdKeyMask (the cmdKey in SYSEQU.A seemd to
;									be wrong)
;		<11>	  8/9/90	VC		Implemented the "Command-." option to cancel.
;		<10>	 5/27/90	JSM		Use DCB.B again, now that LinkPatch supports it.
;		 <9>	 5/15/90	VC		In CopyPassword, set the string to NIL when the typed password
;									is Nil.
;		 <8>	  5/9/90	JSM		Don't use DCB.B for pGlobals until LinkPatch supports it.
;		 <7>	 4/26/90	VC		Select the proper field after the Callback routine returns.
;		 <6>	 3/26/90	S		Fixed the crash of the dialog when guset is selected after a
;									connection attemped is failed.
;		 <5>	 3/20/90	S		Fix the bug in StartSecureSession to return proper flag when
;									guest is selected.
;		 <4>	 2/27/90	S		Fix Guest Selection Bug.
;		 <3>	 1/30/90	S		Condional Compile for Init and Patch resource IDs.
;				 1/22/90	CVC		1.2 Combine PromptAndStart with PromptForUser
;	   <1.1>	11/28/89	CVC		Added PromptAndStart call.
;				11/22/89	CVC		1.1 Added PromptAndStart
;	   <1.0>	10/12/89	CVC		Adding Access Control for the first time.
;				10/11/89	RH		1.0d2 Save registers in the promptForUser routine
;				 9/18/89	RH		1.0d1 Added glue code
;				 9/15/89	RH		1.0d1 More fixes and changes to displaying code
;				  9/6/89	RH		1.0d1 Made changes in the PromptForUser routine to fix bugs when
;									entering a password
;				  9/3/89	RH		1.0d1 New Today
;

	TITLE	'Prompt For User'

;	Utility login window routine that can be called by any app to
;	bring up a 'standard' dialog that prompts for user name and password.
;
;	Ruth Hennigar  (code stolen from AppleShare Workstation)

			BLANKS ON
			STRING ASIS

			LOAD	'StandardEqu.d'
			INCLUDE	'AppleTalk.a'
			INCLUDE	'PromptForUserEqu.a'
			PRINT ON
			PRINT NOGEN

				if &trim(&type('INIT')) = 'UNDEFINED' then
pswdStrStart 	EQU	-16409	; password text string resource ID start
PrmtDlogID		EQU	-16409		; dialog resource ID

				else
pswdStrStart 	EQU	-930	; password text string resource ID start (Init)
PrmtDlogID		EQU	-930		; dialog resource ID

			    endif

PWDRmolyR		equ	'GNRL'	; Password Roman Only Resource
PWDRmolyID		equ	-16490	; Password Roman Only Resource ID


PrmtFUser PROC    EXPORT
	EXPORT  PromptForUser
	IMPORT	GetPasswordBullet
;________________________________________________________________________________
;
; Routine:      PromptForUser
;
; Function:	Glue code that calls the PromptUser routine that brings up a
;		dialog that asks for userName and Password
;
; Pascal interface:
; Function    PromptForUser	(PromptStr:  	^STR;
;			 IconHdl:		Handle;
;			 UserName:	^Str[32]
;			 Password:	^Str[8];
;			 SelectedItem:	INTEGER; {5=userName, 7=password}
;			 GuestOk:		BOOLEAN;
;		     VAR loginMethod:	INTEGER {1=guest, 2=Cleartext pswd, 3=RandNum Exchange pswd}
;			 int (*callBack)();
;			 startPb:		PPCStartParam)
;
;		       : INTEGER;
;________________________________________________________________________________
;
;
PromptForUser
	LINK    	A6,#0		; Set up A6 -> stack
	MOVEM.L	D2-D5/A2-A5,-(SP)	; save some registers

; At this point, the stack looks as follows:
;
;   (A6) --> Old A6
;  4(A6) --> Return address
;  8(A6) --> Start PB
; 12(A6) --> callBack proc
; 16(A6) --> login method
; 20(A6) --> guestOK
; 22(A6) --> selected item
; 24(A6) --> password
; 28(A6) --> username
; 32(A6) --> icon handle
; 36(A6) --> prompt string
; 40(A6) --> Return value
;
	MOVE.L	8(A6),D5		; Copy PB into D5
	MOVE.L	12(A6),D4		; Copy callBack proc into D4
	MOVE.L	16(A6),A4		; A4 -> address of login method
	MOVE.W	(A4),D1			; Copy login method into D1
	MOVE.B	20(A6),D3		; Copy guest ok? into D3
	MOVE.W	22(A6),D2		; Copy selected item into D2
	MOVE.L	24(A6),A3		; Copy password address into A3
	MOVE.L	28(A6),A2		; Copy user name address into A2
	MOVE.L	32(A6),A0		; Copy icon handle into A0
	MOVE.L	36(A6),A1		; Copy prompt string into A1
	BSR.S	PromptUser		; call routine
	MOVE.W	D0,40(A6)           ; Return final result
	MOVE.L	16(A6),A0		; A0 -> address of login method
	MOVE.W	D1,(A0)			; return method selected

	MOVEM.L	(SP)+,D2-D5/A2-A5	; restore registers
	UNLK	A6		; Pop off the call frame
	MOVE.L	(SP)+,A0		; Save the return address
	ADDA.W	#32,SP		; Pop off the incoming arguments
	JMP	(A0)		; And call it a day.

;___________________________________________________________________________
;
;   Routine: PromptUser
;
;	This routine brings up the 'same' window as the Chooser's file server
;	device package.  It's purpose is to allow the user to enter his/her
;	password and UAM (if this makes sense).
;
;	Note that since this dialog is just like the device pkg's, we use the
;	same DLOG and DITL resource.
;
;	Entry:	D1 = login method	(2=Cleartext pswd, 3=RandNum Exchange pswd)
;		D2 = selected item (user name=5 or password=7)
;		D3 = guest login okay? (0=no, 1=yes) (byte)
;		A0 -> icon handle
;		A1 -> prompting string
;		A2 -> user name string (optional)
;		A3 -> password string (optional)
;		D4 -> CallBack proc
;		D5 -> Start PB
;	Exit:	D0 = negative if error or Cancel occurred
;		D1 = login method (1=Guest, 2=Cleartext pswd, 3=RandNum Exchange pswd)
;		A2 -> user name string (blank if guest is selected)
;		A3 -> password character string (blank if guest is selected)
;
;	All registers preserved.
;

; Stack frame equates

pswType	 	EQU	-2		; item type used by Dialog Mgr calls (don't move this!)
pswIHandle 	EQU	pswType-4 	; handle to item (don't move this!)
pswBox	 	EQU	pswIHandle-8	; item rect (don't move this!)
pswSavePort  	EQU	pswBox-4		; saved grafport
pswDialogPtr 	EQU	pswSavePort-4	; PW dialog ptr
pswItemHit  	EQU	pswDialogPtr-2	; item selected from Modal dialog
pswUname		EQU	pswItemHit-4	; pointer to user name storage
pswPwdPtr		EQU	pswUname-4	; storage for passward chars pointer
pswIcon		EQU	pswPwdPtr-4	; storage for icon pointer
pswSelItem	EQU	pswIcon-2		; item to be selected
pswMethod		EQU	pswSelItem-2	; temporary storage for login method
pswPbPtr		EQU	pswMethod-4	; temporary storage for Pb
pswCallbackPtr	EQU	pswPbPtr-4	; temporary storage for Callback Proc
pswSize		EQU	pswCallbackPtr		; size of local variables

PromptUser
	LINK	A6,#pswSize	; stack frame
	MOVEM.L	D2-D5/A0-A4,-(SP)	; save registers
	MOVE.L	A4,pswIcon(A6)	; save the ptr to the icon
	MOVE.L	A2,pswUname(A6)	; save the ptr to the user name
	MOVE.L	A3,pswPwdPtr(A6)	; save the ptr to the password
	MOVE.W	D2,pswSelItem(A6)	; save the item to be selected
	MOVE.L	D5,pswPbPtr(A6)		; save the pb pointer
	MOVE.L	D4,pswCallbackPtr(A6)		; save the Callback pointer
	
	IF forROM or TheFuture THEN	; can’t have data inside code in ROM				<22>

	MOVE.L	ExpandMem,A4		; A4 -> Expanded Low Memory							<22>
	MOVE.L	ExpandMemRec.emPPCPromptForUserGlobals(A4),A4	; A4-> ptr to globals	<22> 

	ELSE						;													<22>

	LEA	pGlobals,A4	; A4 -> our globals
	
	ENDIF						; forROM or TheFuture								<22>

	MOVE	D1,pMethod(A4)	; save the login method
	MOVE	D1,pswMethod(A6)	; save the login method in temp storage
	MOVE.B	D3,pGuestAllowed(A4)	; save the guest boolean
	MOVE.L	A1,pPrompt(A4)	; save the prompt string
	MOVE.L	A0,pIconHdl(A4)	; save the icon handle
	PEA	pswSavePort(A6)	; save area for port
	_GetPort
;
; Bring up the dialog
;
@10	SUBQ	#4,SP		; room for result
	MOVE	#PrmtDlogID,-(SP)	; dialog ID
	CLR.L	-(SP)		; no storage
	MOVE.L	#-1,-(SP) 	; behind param
	_GetNewDialog		; initially invisible
	MOVE.L	(SP),A3		; copy dialog hdl into A3
	MOVE.L	A3,pswDialogPtr(A6) ; save it away
	_SetPort

;
; Set the prompt string in the dialog
;
	MOVE.L	pPrompt(A4),D0		; Set condition code
	BEQ.S	@12					; Don't set item text if NIL
	MOVE.L	D0,A2				; A2 -> prompt string
	MOVE	#fItemPromptText,D0 ; item number
	BSR		SetDIText 			; set item text
@12	MOVE	#sysFont,-(SP)		; set font to system (Chicago)
	_TextFont
;
; put icon in dialog
;
	MOVE.L	pIconHdl(A4),D0	; move handle into D0
	BEQ.S	@15		; it's NIL, don't plot it
	PEA	IconRect		; push the icon rect location
	MOVE.L	pIconHdl(A4),-(SP)	; push handle to icon
	_PlotIcon
;
; Put user name in dialog;
;
@15	MOVE	#fItemUNameEdit,D0	; item number
	MOVE.L	pswUname(A6),A2	; get the ptr to the user name
	BSR	SetDIText 	; set item text
;
; get a handle to the text edit item for later
;
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	#fItemUNameEdit,-(SP) ; item number
	PEA	pswType(A6)	; type storage
	PEA	pswIHandle(A6)	; item handle storage
	PEA	pswBox(A6)	; rect storage
	_GetDItem
	MOVE.L	pswIHandle(A6),pPWDlogUNameHdl(A4) ; save hdl to user name text
;
; Create a TERecord for the password characters
;
	SUBQ	#4,SP		; room for result
	PEA	OffScrRect	; dest rect
	PEA	OffScrRect	; view rect
	_TENew
	MOVE.L	(SP)+,pPwdTEHandle(A4) ; save TEHandle
	
;
; Set up the bullet character the international way… 				<21>
; 
	SUBQ	#2,SP					; room for return char '•'		<21>
	JSR		GetPasswordBullet		; go get it…					<21>
	MOVE.B	(SP)+,pBulletChar(A4)	; save the bullet for later		<21>
;
; If the password was passed, then put it in the edit records
;
	MOVE.L	pPwdTEHandle(A4),D2	; D2 -> TE handle
	MOVE.L	pswPwdPtr(A6),A2	; A2 -> callers string storage
	BSR	PutPswdInDlog	; insert the password if it was specified
; 
; If we're in the password edit text, switch to Roman script. - AMC/AKN 6/24/92
; This feature can be disabled with a bit in a resource.
;
	movem.l	d0-d2/a0-a2,-(sp)		; Save some reg's
	
	if (forROM or theFuture) then
		move.l	ExpandMem,a0									; <24>
		move.l	ExpandMemRec.emPPCPromptForUserGlobals(a0),a0	; <24> Pointer to PPC globals
		lea		PromptForUserGlobalsRec.IKeyScriptDone(a0),a0	; <24> Pointer to IKeyScriptDone
	else
		lea		IKeyScriptDone,a0	; IKeyScriptDone indicates already switched to Roman
	endif
	
	move.w	#0,(a0)					; Initialize the flag KeyScriptDone
	move	pswSelItem(a6),d0		; Get selected item
	cmp.w	#fItemPEdit,d0			; Is it Password Item?
	bnz		@17						; No, don't switch script to Roman

	subq	#4,sp					; Room for result
	move.l	#PWDRmolyR,-(sp)		; Push resource type
	move.w	#PWDRmolyID,-(sp)		; Push resouce ID
	_GetResource					; Fetch the resource
	move.l	(sp)+,a0				; Pop resource handle	
	cmpa.l	#0,a0					; Is there an address there?
	beq	@17							; No, don't switch script to Roman
	move.l	(a0),a1					; Otherwise, get pointer
	move.b	(a1),d0					; Get resource data
	cmpi.b	#1,d0					; If the switch is 1, call KeyScript
	bne	@17							; Otherwise don't switch to Roman
	move.w	#smRoman,-(sp)			; Set KeyScript Roman in Password EditText
	_KeyScript

	if (forROM or theFuture) then
		move.l	ExpandMem,a0									; <24>
		move.l	ExpandMemRec.emPPCPromptForUserGlobals(a0),a0	; <24> Pointer to PPC globals
		lea		PromptForUserGlobalsRec.IKeyScriptDone(a0),a0	; <24> Pointer to IKeyScriptDone
	else
		lea		IKeyScriptDone,a0		; IKeyScriptDone indicates already switched to Roman
	endif
	
	move.w	#1,(a0)					; Don't need to set KeyScript anymore
@17	movem.l	(sp)+,d0-d2/a0-a2		; Restore reg's
;
; select the text item specified
;
	MOVE	pswSelItem(A6),D0	; D0 = item number to be selected
	BSR	SelText		; select the text
;
; highlight the correct buttons in the dialog
;
	TST.B	D3		; is guest login allowed
	BNE.S	@20		; yep, branch
	MOVE	#fItemGuest,D0	; which one to dim
	MOVE	#255,D1		; control will be set to this (dim)
	BSR	HiliteItem	; dim the guest radio button
@20	MOVE	pMethod(A4),D1	; D1 = method (cleartext, scrambled..)
	BSR	SetPswdType	; set up the string for password type
	MOVE	#fItemRegistered,D0	; which one to hilite
	MOVE	#1,D1		; control set to 1
	BSR	SetCtlItem	; set control
	MOVE.L	A3,-(SP)		; push window ptr
	_ShowWindow
;
; This is the modal dialog loop
;
DialogLoop
	MOVE.L	pswDialogPtr(A6),A3 ; Restore the dialog pointer
	BSR	SetArrowCurs	; set the arrow cursor
	PEA	PSWFilter 	; set filter proc
	PEA	pswItemHit(A6)	; item hit variable
	_ModalDialog
; 
; If we're in the password edit text, switch to Roman script. - AMC/AKN 6/24/92
; This feature can be disabled with a bit in a resource.
;
	movem.l	d0-d2/a0-a2,-(sp)			; Save some reg's
	cmp		#fItemPEdit,pswItemHit(A6)	; Password EditText hit?
	bne.s	@189						; No, don't switch to Roman script
	subq	#4,sp						; Check resource switch
	move.l	#PWDRmolyR,-(sp)			; Push resource type
	move.w	#PWDRmolyID,-(sp)			; Push resource ID
	_GetResource						; Fetch the resource
	move.l	(sp)+,a0					; Pop resource handle
	cmpa.l	#0,a0						; Is there an address there?
	beq		@190						; No, don't switch to Roman script
	move.l	(a0),a1						; Otherwise, get pointer
	move.b	(a1),d0						; Get resource data
	cmpi.b	#1,d0						; If the switch is 1, call KeyScript
	bne		@190						; Otherwise don't switch to Roman

	if (forROM or theFuture) then
		move.l	ExpandMem,a0									; <24>
		move.l	ExpandMemRec.emPPCPromptForUserGlobals(a0),a0	; <24> Pointer to PPC globals
		lea		PromptForUserGlobalsRec.IKeyScriptDone(a0),a0	; <24> Pointer to IKeyScriptDone
	else
		lea		IKeyScriptDone,a0		; IKeyScriptDone indicates already switched to Roman
	endif
	
	move.w	(a0),d0						; Get its value
	bnz		@190						; Already set, we're done
	move.w	#1,(a0)						; Don't need to set KeyScript anymore

	move.w	#smRoman,-(sp)				; Set KeyScript Roman in Password EditText
	_KeyScript
	bra	@190							; We're done with Roman script switch

@189
	cmp		#fItemUNameEdit,pswItemHit(A6)	; User name EditText hit?
	bne.s	@190							; No, get out
	if (forROM or theFuture) then
		move.l	ExpandMem,a0									; <24>
		move.l	ExpandMemRec.emPPCPromptForUserGlobals(a0),a0	; <24> Pointer to PPC globals
		lea		PromptForUserGlobalsRec.IKeyScriptDone(a0),a0	; <24> Pointer to IKeyScriptDone
	else
		lea		IKeyScriptDone,a0			; IKeyScriptDone indicates already switched to Roman
	endif
	
	move.w	#0,(a0)							; May need to set KeyScript now
@190
	movem.l	(sp)+,d0-d2/a0-a2				; Restore reg's

	CMP	#fItemGuest,pswItemHit(A6) ; control hit?
	BNE.S	@200		; nope, branch
	BSR	ClearMethButtons	; zero out all buttons
	MOVE	#fItemGuest,D0	; D0 = button to set
	MOVE	#1,D1		; control set to 1
	BSR	SetCtlItem	; set it
	BSR	HideUName
	MOVE	#noUserAuth,pswMethod(A6)	; save guest as the method
	BRA.S	@250		; branch
@200	CMP	#fItemRegistered,pswItemHit(A6) ; button hit?
	BNE.S	@220		; nope, branch
	BSR	ClearMethButtons	 ; zero out all radio buttons
	MOVE	#fItemRegistered,D0  ; D0 = button to set
	MOVE	#1,D1		; control set to 1
	BSR	SetCtlItem	; set it
	BSR	RestoreUName
	MOVE	pMethod(A4),pswMethod(A6) ; save password method passed as the method
	BRA.S	@250		; branch
;
; Test to see if a button was hit
;
@220	CMP	#fItemOKButton,pswItemHit(A6) ; button hit?
	BLT.S	@250		; nope, branch (ignore it)
	BEQ.S	ButtonOK		; if OK was hit then branch
	CMP	#fItemCancelButton,pswItemHit(A6) ; cancel button hit?
	BEQ.S	ButtonCancel	; if it was then branch
@250	BRA.S	DialogLoop	; branch to loop place
;
; The OK button was hit.  Do the action.
;
ButtonOK
;
; Put user name and password chars into buffers
;
	MOVE.L	pswUName(A6),A2	; A2 -> string to be returned to caller
	MOVE	pswMethod(A6),D1	; D1 = login method chosen
	BSR	CopyUName		; copy the string in the dialog back to the caller
	MOVE.L	pPwdTEHandle(A4),A1
	MOVE.L	pswPwdPtr(A6),A3	; A3 -> callers string storage
	MOVE	pswMethod(A6),D1	; D1 = login method chosen
	BSR	CopyPassword	; copy password into the buffer the caller provided
	MOVEQ	#noErr,D0		; set no errors
	CMPI.L	#0,pswCallbackPtr(A6)
	BEQ.S	DialogDone
;
;  !!!!!!!!!!!!!!!!!!!!!!!!!!
;
	MOVE.L	pswPbPtr(A6),-(SP)
	MOVEQ	#0,D1
	MOVE.W	pswMethod(A6),D1
	EXT.L	D1
	MOVE.L	D1,-(SP)
	MOVE.L	pswUName(A6),-(SP)
	MOVE.L	pswPwdPtr(A6),-(SP)
	MOVE.L	pswCallbackPtr(A6),A0
	JSR		(A0)
;
; Upon return D0 should contain one of the following info:
;	0= if want to close the dialog.
;	5= select the userName
;   7= select the password
;
	TST.W	D0
	BEQ.S	DialogDone
	CMP	#fItemUNameEdit,D0
	BEQ	SelectItem
	CMP	#fItemPEdit,D0
	BEQ	SelectItem
	BRA	DialogLoop	; branch to loop place
SelectItem
	MOVE.L	pswDialogPtr(A6),A3 ; Restore the dialog pointer
	BSR	SelText		; select the text
	BRA	DialogLoop	; branch to loop place
;
; An error occurred somewhere...
;
ButtonCancel
	MOVEQ	#-1,D0		; set error code
;
; All done.  Close up the dialog.
;
DialogDone
	MOVE	D0,-(SP)		; save error code
	MOVE.L	pswDialogPtr(A6),-(SP) ; push the dialog pointer
	_DisposDialog		   ; get rid of it
	MOVE.L	pswSavePort(A6),-(SP)  ; get saved graf port
	_SetPort
	MOVE.L	pPwdTEHandle(A4),-(SP) ; password TERecord
	_TEDispose
	MOVE	(SP)+,D0		; restore error code
	MOVE	pswMethod(A6),D1	; D1 = login method chosen
	MOVEM.L	(SP)+,D2-D5/A0-A4	; save registers
	UNLK	A6		; no more stack frame
	RTS
;___________________________________________________________________________
;
;   Routine: PSWFilter
;
;	Filter procedure for the Password window.  It tests to see if a password
;	character is being typed in.	If so, it replaces it with a '•' char
;	and saves it away.
;
;	Note that this routine is called from the Dialog manager and not from
;	this device package.  That means that there are no local variables.  There
;	are, however, globals.
;

; Parameters

;fItemHit  .EQU	 8		 			; item hit var ptr
;fEventRec .EQU	 fItemHit+4			; event record ptr
;fDlogPtr  .EQU	 fEventRec+4		; dialog ptr
;fBoolean  .EQU	 fDlogPtr+4			; boolean result

pwFLclMouse EQU	-4					; space for mouse pt
pwFLclSize  EQU	pwFLclMouse			; size of locals

PSWFilter
	LINK	A6,#pwFLclSize			; set up stack frame
	MOVEM.L	D0-D4/A0-A4,-(SP)		; save registers
	MOVE.L	fEventRec(A6),A1		; A1 -> event record
	MOVE.L	fItemHit(A6),A2			; A2 -> item hit variable

	IF forROM or TheFuture THEN		; can’t have data inside code in ROM			<22>

	MOVE.L	ExpandMem,A4			; A4 -> Expanded Low Memory						<22>
	MOVE.L	ExpandMemRec.emPPCPromptForUserGlobals(A4),A4	; A4-> ptr to globals	<22> 

	ELSE							;												<22>

	LEA		pGlobals,A4				; A4 -> globals
	
	ENDIF							; forROM or TheFuture							<22>

	CLR		(A2)					; by default return itemHit as 0.
	CLR		fBoolean(A6)			; assume False
	
	
	MOVE.L	fDlogPtr(A6),A3			; dialog window to be updated?
	BSR		MySetCursor				; First things first, make our cursor the right one.
	MOVE	evtNum(A1),D0			; what is the event code?
	CMP		#keyDwnEvt,D0			; is it keydown?
	BEQ		@10						; yes, branch
	CMP		#autoKeyEvt,D0			; how about auto key?
	BEQ		@10						; yes, branch
	CMP		#updatEvt,D0			; what about an update?
	BEQ.S	@04						; yes, branch
	BRA		@90						; nothing more to do, just exit
;
; An update has occurred.   Redraw the misc information in the window.
;
@04	MOVE.L	evtMessage(A1),A3		; A3 -> window to be updated
	CMP.L	fDlogPtr(A6),A3			; dialog window to be updated?
	BNE	@90							; if not then just exit
;
; Continue updating screen: bold the OK button
;
	MOVE	#fItemOKButton,D0		; button item number
	BSR		BoldButton				; make the button bold
	MOVE.L	pIconHdl(A4),A0			; A0 -> icon handle
	BSR		DisplayIcon				; display the icon
	MOVE.L	fDlogPtr(A6),A3			; dialog window ptr
	BRA		@90						; pretend like I was never here.
;
; Process the key event
;
@10	MOVE.L	evtMessage(A1),D1		; D1 low byte = character
	AND		#$FF,D1					; clear out all except the low byte
	MOVE.W	evtMeta(A1),D0
	AND.W	#cmdKeyMask,D0
	BEQ		@15						; No Command Key
; Process the command key.	
	CLR		D0						; clear item number
	CMP		#rChar,D1				; Is it Command-R?
	BEQ		@DoCmdR
	CMP		#gChar,D1				; Is it Command-G?
	BEQ		@DoCmdG
	CMP		#periodChar,D1			; Is it Command-.?
	BEQ		@DoCmdStop

; Last of all handle the edit functions.
	CMP		#'x',D1					; Is it Command-X?
	BEQ		@IsEdit
	CMP		#'c',D1					; Is it Command-C?
	BEQ		@IsEdit
	CMP		#'v',D1					; Is it Command-V?
	BEQ		@IsEdit
	BRA		@BeepAndExit			; Ignore all other command keys.

; Handle Command-R
@DoCmdR
	MOVE #fItemRegistered,D0	; get the Guest button item
	BRA	@ExitCmdKey

; Handle Command-G
@DoCmdG
	TST.B	pGuestAllowed(A4)	; test the guest boolean
	BEQ		@ExitCmdKey			; no guest allowed, just blow off event.
	MOVE	#fItemGuest,D0		; get the Guest button item
	BRA		@ExitCmdKey			; 

; Handle Command-.
@DoCmdStop
	MOVE	#fItemCancelButton,D0	; get the Cancel button item
	BRA @ExitCmdKey

@IsEdit	
	MOVE.L	fDlogPtr(A6),A3			; A3 -> dialog
	MOVE	editField(A3),D0		; D0 = edit text item field minus 1
	ADDQ	#1,D0					; increment it
	CMP		#fItemPEdit,D0			; is it in the password box?
	BNE		@ExitFilter				; Let Dialog Manager handle it.

@BeepAndExit
	MOVE.W	#2,-(SP)			; Push the duration onto the stack
	_SysBeep
@ExitCmdKey
	MOVE	D0,(A2)				; set the item to be returned
	BRA		@80					; exit with TRUE.

; Process a normal key stroke
@15	MOVE.L	fDlogPtr(A6),A3		; A3 -> dialog
	MOVE	editField(A3),D0	; D0 = edit text item field minus 1
	ADDQ	#1,D0				; increment it
	CMP	#crChar,D1				; return key?
	BEQ	@70
	CMP	#enterChar,D1			; enter key?
	BEQ	@70
	CMP	#noUserAuth,pMethod(A4) ; is the method OK?
	BNE.S	@20					; if so then branch
	BRA	@80						; all done, exit with TRUE.
;
; A key has been pressed for an active text edit box
;
@20	CMP	#tabChar,D1					; tab key?
	BEQ	@90							; just ignore it if it was
	CMP	#clrChar,D1					; is it a clear key?
	BNE.S	@25						; no, branch
	MOVE	#bsChar,D1				; else set character to backspace key
	MOVE.L	D1,evtMessage(A1)		; set character to bsKey
@25	CMP		#fItemPEdit,D0			; is it the password box?
	BNE		@60						; if not then branch

; process char that was entered in the password box.
;
	MOVE.L	pPwdTEHandle(A4),A1 	; A1 = real char password handle
	BSR		TESelCopy				; copy the selection from the masked TE rec to the real one

	CMP.B	#funcKey,D1
	BEQ		@BeepAndExit
	CMP.B	#fwdDelete,D1			; If I had time, this would work.
	BEQ		@BeepAndExit
	CMP.B	#leftArrow,D1
	BEQ		@90						; Let Dialog Mangager handle it.
	CMP.B	#rightArrow,D1
	BEQ		@90
	CMP.B	#upArrow,D1
	BEQ		@90
	CMP.B	#downArrow,D1
	BEQ		@90
; Check for selection
	MOVE.L	teHandle(A3),A0			; A0 = handle to dialog text edit record
	MOVE.L	(A0),A0					; A0 -> text edit record
	MOVE	teSelEnd(A0),D2			; get selection end
	SUB		teSelStart(A0),D2		; any selection made
	BNE @35							; Don't check for max length if selection is made.
	MOVE	D0,(A2)					; return the item hit in the variable
	CMP.B	#bsChar,D1				; is it a backspace?
	BEQ		@35						; if so, don't bother checking for maximum length.
	MOVE	#maxUsrPwdLen,D0		; D0 = maximum password length
	BSR		ChkLength				; check the password length
	BNE		@80						; if error then branch
@35	MOVE	D1,-(SP)				; Save a copy for later.

; Re-Sync password TE and maskChar TE for 2 byte code 	6/20/92 AKN	
; If the entire bullet-char-TE is selected, select all of real password TE
	
	move.w	d1,-(sp)				; Save d1

	move.w	teSelStart(a0),d0		; Get start of selection
	bnz	@40							; Not all of TE selected, then don't re-sync

	move.w	teSelEnd(a0),d0			; Get end of selection
	cmp.w	teLength(a0),d0			; Make sure selection goes to end of string
	bnz	@40							; If it doesn't, don't re-sync

	move.l	#0,-(sp)				; Push SelStart
	move.l	#30000,-(sp)			; Push SelEnd
	move.l	pPwdTEHandle(A4),-(sp)	; Push actual password TE Handle
	_TESetSelect					; Select entire string

; If theChar is two byte char, call TEDelete.  This forces two byte password
; to start at beginning of actual password string.

	movea.l	sp,a0					; A0 -> theChar
	add.l	#1,a0					; Get low byte
	sub		#2,sp					; Room for result of CharByte
	move.l	a0,-(sp)				; Push address of theChar
	move.w	#0,-(sp)				; Push offset 0
	_CharByte						; What kind of Char?
	move.w	(sp)+,d0				; Get result
	cmp.w	#smFirstByte,d0			; Is it 1st byte of two byte char?
	bnz	@40							; No, don't do resync

	move.l	pPwdTEHandle(A4),-(sp)	; Push actual password TE Handle
	_TEDelete						; Clear actual password

@40	move.w	(sp)+,d1				; restore D1

	MOVE	D1,-(SP)				; normal character
	MOVE.L	pPwdTEHandle(A4),-(SP)	; push handle to actual password characters
	_TEKey							; update our hidden password.
	MOVE	(SP)+,D1				; restore D1.
	CMP		#bsChar,D1				; backspace key?
	BEQ.S	@90						; Let Dialog Mangager handle backspace.
	MOVE.L	fEventRec(A6),A1		; A1 -> event record
	MOVE.B	pBulletChar(A4),D1		; Set D1 to the maskChar. <21>
	MOVE.L	D1,evtMessage(A1)		; change the event record so it shows up as a maskchar.
	BRA.S	@90						; Have Dialog Manager handle the rest.
;
; A key was pressed for the user name edit box.  Make sure it's a maximum of 31 characters or else
; a beep is sounded.
;
@60	CMP.B	#bsChar,D1	; backspace character?
	BEQ.S	@90		; if so then exit (don't process it)
	MOVE	#uNameSize,D0	; maximum length of name
	BSR	ChkLength 	; calculate the text length
	BNE.S	@80		; if over limit then exit (eat the event)
	BRA.S	@90		; all done (let the dialog mgr take care of the event)
;
; A return or enter key was hit
;
@70	CLR	D0						; clear item number
	MOVE	#fItemOKButton,D0	; get the OK button item
	BSR	HiliteOKButton			; hilite the OK button for a short time
	MOVE	D0,(A2)				; set the item to be returned

; Return TRUE.
@80	MOVE	#$0100,fBoolean(A6) ; set function result to TRUE (eat the event)
;
; All done
;
@ExitFilter
@90	MOVEM.L	(SP)+,D0-D4/A0-A4	; restore registers
	UNLK	A6
	MOVE.L	(SP)+,A0		; get return address
	ADD.L	#fPSize,SP	; strip parameters
	JMP	(A0)		; and return

;_________________________________________________________
;
;    Routine : AbbreviateString
;
;	Given a string and a max string length, shorten the string until it
;	fits in the given space and append '...' to it if it is shortened.
;
;	Entry:	A0 -> source string
;		A1 -> dest string
;		D0 = max string length
;
AbbreviateString
	MOVEM.L	D0-D4/A0-A2,-(SP)	; save some registers
	SF	D4		; clear shrink flag
	MOVE	D0,D3		; save max str length
	MOVE.L	A1,D2		; save str ptr
	ADD	#1,D2		; D2 actually points to the text of the string
	CLR	D1
	MOVE.B	(A0),D1		; D1 = length of current string
	BSR	StrCopy		; copy string into A1
@10	MOVEM.L	D1-D2/A0-A1,-(SP)	; save registers
	SUBQ	#2,SP		; func result
	MOVE.L	D2,-(SP)		; push string text ptr
	CLR	-(SP)		; firstByte is always zero
	MOVE	D1,-(SP)		; push byteCount (string length)
	_TextWidth		; check string length
	MOVE	(SP)+,D0		; get string length
	MOVEM.L	(SP)+,D1-D2/A0-A1	; restore registers
	CMP	D0,D3		; how big is it currently?
	BGE.S	@20		; if within range then branch
	ST	D4		; set shrink flag
	SUB	#1,D1		; decrement string length
	BRA.S	@10		; and do it again
;
; First see if we shrunk the string down.  If we did then append the ... to the string
;
@20	TST.B	D4		; shrink flag set?
	BEQ.S	@90		; if cleared then branch
	MOVE.L	D2,A1		; A1 -> new string text area
	SUB	#1,A1		; A1 -> new string
	MOVE.B	D1,(A1)		; set new string length
	LEA	ThreeDotStr,A0	; A0 -> our three dot string
	BSR.S	AppendString	; append string onto end
@90	MOVEM.L	(SP)+,D0-D4/A0-A2	; restore registers
	RTS
;_________________________________________________________
;
;    Routine : AppendString
;
;	Append a string to the end of the string.
;
;	Entry:	A0 -> string to append
;		A1 -> dest string
;	Exit:	A1 -> new string
;
;	Called by: AbbrieviateString, MakePrompt
;
AppendString
	MOVEM.L	D0-D2/A0-A2,-(SP)	; save some registers
	MOVE.L	A1,A2		; save start of string in A2
	CLR	D1		; clear word
	MOVE.B	(A1),D1		; D1 = length of dest string
	BEQ.S	@10		; if zero length then branch
	LEA	0(A1,D1),A1	; point to end of string
@10	MOVE.B	(A1),D2		; save byte
	MOVE.L	A1,-(SP)		; save start of string
	BSR	StrCopy		; copy the string into temp storage
	MOVE.L	(SP)+,A1		; A1 -> place in new string where append string is
	TST.B	D1		; what's then length of the string
	BEQ.S	@20		; if zero length then branch
	MOVE.B	(A0),D1		; get length of appended string
	ADD.B	D1,(A2)		; fix length of new string
	MOVE.B	D2,(A1)		; restore byte saved earlier
@20	MOVEM.L	(SP)+,D0-D2/A0-A2	; restore registers
	RTS
;___________________________________________________________________________
;
;   Routine: BoldButton
;
;	This code outlines a button to be the default selection.  This code is
;	taken directly from ROM sources.  Note that the button will not be
;	bolded if the related button is in the dimmed mode.
;
;	Entry:	D0 = button item number in dialog
;		A3 -> dialog
;
;	All registers preserved.
;
bbType	EQU	-2		; item type used by Dialog Mgr calls
bbIHandle EQU	bbType-4		; handle to item
bbBox	EQU	bbIHandle-8	; item rect
BBSize	EQU	bbBox		; size of local variables

BoldButton
	LINK	A6,#BBSize	; set up stack frame
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D0,-(SP)		; item number
	PEA	bbType(A6)	; type storage
	PEA	bbIHandle(A6)	; item handle storage
	PEA	bbBox(A6) 	; rect storage
	_GetDItem
	MOVE.L	bbIHandle(A6),A0	; A0 = handle to control
	MOVE.L	(A0),A0		; A0 -> control record
	CMP.B	#$FE,contrlHilite(A0) ; test control hilite state
	BLT.S	@90		; if inactive then branch
	LEA	bbBox(A6),A0	; A0 -> OK button rect
	MOVEQ	#3,D0
	MOVEQ	#16,D1
	MOVEQ	#4,D2
	MOVE.L	A0,-(SP)		; rect
	MOVE	D2,-(SP)		; size for re-insetting
	MOVE	D2,-(SP)
	MOVE.L	A0,-(SP)		; rect
	MOVE	D1,-(SP)		; roundness
	MOVE	D1,-(SP)
	MOVE.L	A0,-(SP)		; rect
	NEG	D2
	MOVE	D2,-(SP)		; push size
	MOVE	D2,-(SP)		; push size
	MOVE	D0,-(SP)		; pensize
	MOVE	D0,-(SP)
	_PenSize
	_InsetRect
	_FrameRoundRect
	_InsetRect
	_PenNormal		; back to the way it was
@90	MOVEM.L	(SP)+,A0-A2/D0-D3	; restore registers
	UNLK	A6
	RTS

;___________________________________________________________________________
;
;   Routine: CheckForCursKey
;
;	Check to see if the key passed in D1 was a cursor key.  If it was then
;	clear the returned flag.
;
;	Entry:	D1.B = key hit
;	Exit:	D0 = status of key hit:  (ccr's set)
;			zero = cursor key hit
;			non-zero = no cursor key hit
;
;	Called by: PWFilter, VPFilter
;
CheckForCursKey
	MOVEQ	#-1,D0		; assume no cursor key hit
	CMP.B	#$1C,D1		; cursor key range?
	BLT.S	@10		; if less then branch
	CMP.B	#$1F,D1		; check upper range
	BGT.S	@10		; if out of bounds then branch
	MOVEQ	#0,D0		; clear flag indicating cursor key hit
@10	RTS

;___________________________________________________________________________
;
;   Routine: ChkLength
;
;	Check to make sure the text is within the required length.	Beep if
;	it isn't
;
;	Entry:	A3 -> dialog record ptr
;		D0 = maximum length of text
;	Exit:	CCR's set (z-bit set if no errors)
;
ChkLength
	MOVEM.L	A0-A4/D0-D2,-(SP)	; save registers
	MOVE.L	teHandle(A3),A0	; A0 -> te Handle
	MOVE.L	(A0),A0		; A0 -> te record
	MOVE	teLength(A0),D2	; D2 = length of text
	CMP	D0,D2		; is it within range?
	BLT.S	@05		; yes, branch
;
; Password already 8 chars long, but if there's a selection then OK it
;
	MOVE	teSelEnd(A0),D1	; D1 = selection start range
	SUB	teSelStart(A0),D1	; D1 = number of bytes in selection
	BLE.S	@10		; if there's no selection then branch
@05	CLR	D2		; set ccr's (no error)
	BRA.S	@20
@10	MOVE	#beepLen,-(SP)	; length of beep
	_SysBeep
	MOVEQ	#-1,D2		; set ccr's
@20	MOVEM.L	(SP)+,A0-A4/D0-D2	; save registers
	RTS

;___________________________________________________________________________
;
;   Routine: ClearMethButtons
;
;	Clear all active user authentication buttons to zero.
;
;	Entry:	A3 -> PSW dialog
;
;	Called by : PromptUser
;
ClearMethButtons
	MOVEM.L	D0-D1,-(SP)	; save registers
	MOVE	#fItemGuest,D0	; initial button number
	CLR	D1		; hilite value = no
	BSR	SetCtlItem	; set control to zero
	MOVE	#fItemRegistered,D0  ; initial button number
	CLR	D1		; hilite value = no
	BSR	SetCtlItem	; set control to zero
	MOVEM.L	(SP)+,D0-D1	; restore registers
	RTS
;___________________________________________________________________________
;
;   Routine: CopyPassword
;
;	Entry:	A1 -> TE Handle
;		A3 -> buffer to copy password into
;		D1 = login method chosen
;	Exit:	A3 -> buffer filled with password
;
;	Called by : PromptUser
;
CopyPassword
	CMP	#noUserAuth,D1	; guest?
	BNE.S	@05		; nope.. branch
	MOVE.B	#0,(A3)		; return NIL string
	BRA.S	@40		; return
@05	MOVEM.L	A0/A1/A3/D0/D3,-(SP)	; save registers
	MOVE.L	(A1),A0		; A0 -> te rec ptr
	MOVE	teLength(A0),D3	; D3 = length of text
	BNE.S	@06
	MOVE.B	#0,(A3)
	BEQ.S	@20		; if nothing there then branch
@06	SUBQ	#4,SP		; make space
	MOVE.L	A1,-(SP)		; push te handle
	_TEGetText
	MOVE.L	(SP)+,A0		; A0 -> te char ptr
	MOVE.L	(A0),A0		; A0 -> characters
	CLR.L	D0		; clear D0 long word
	MOVE	D3,D0		; set length of data
	MOVE.L	A3,A1		; get back ptr to storage
	MOVE.B	D3,(A1)+		; set length into the string
	_BlockMove
@20	MOVEM.L	(SP)+,A0/A1/A3/D0/D3	; restore registers
@40	RTS

;___________________________________________________________________________
;
;   Routine: CopyUName
;
;	Copies user name from dialog into a string buffer.  If the user name
;	is greater than uNameSize, then truncate it.
;
;	Entry:	A4 -> globals
;		A2 -> buffer to copy name into
;		D1 = login method chosen
;
;	Called by : PromptUser
;
cunStr	EQU	-256		; string
cunSize	EQU	cunStr		; size of locals

CopyUName
	CMP	#noUserAuth,D1	; guest?
	BNE.S	@05		; nope.. branch
	MOVE.B	#0,(A2)		; return NIL string
	BRA.S	@40		; return
@05	LINK	A6,#cunSize	; allocate locals
	MOVEM.L	D0-D3/A0-A2,-(SP)	; save some registers
	MOVE.L	pPWDlogUNameHdl(A4),-(SP) ; A0 = handle to user name Dlog text record
	PEA	cunStr(A6)	; push ptr to space
	_GetIText 		; get that text!
	LEA	cunStr(A6),A0	; A0 -> name string user typed in
	MOVEQ	#0,D0		; clear length
	CMP.B	#uNameSize,(A0)	; get length byte
	BLE.S	@10		; if less or equal then branch
	MOVE.B	#uNameSize,(A0)	; else set uName size
@10	MOVE.L	A2,A1		; A1 -> dest buffer
	BSR	StrCopy		; copy user name into buffer
	MOVEM.L	(SP)+,D0-D3/A0-A2	; restore registers
	UNLK	A6
@40	RTS
;___________________________________________________________________________
;
;   Routine: MySetCursor
;
;	Setup the cursor as appropriate 
;
;	Entry:	A3 -> dialog ptr
;
;	All registers preserved
;
MySetCursor
	MOVEM.L	A0-A3/D0-D4,-(SP)	; save registers
	LINK A6,#-4					; set up stack frame.
	PEA	-4(A6)					; VAR mouseLoc : Point
	_GetMouse					; get mouse local coordinates.
	MOVE.L	A3,-(SP)			; Push Dialog Pointer
	MOVE.L	-4(A6),-(SP)		; mouseLoc moved onto stack.
	_FindDItem					; Which item is the point over.
	MOVE.W	(SP)+,D0			; Pop the item into D0.
	CMP #fItemUNameEdit-1,D0	; is mouse over user name edit box?
	BEQ @25						; yes it is.
	CMP #fItemPEdit-1,D0		; is mouse over password edit box?
	BEQ @25
	_InitCursor					; set cursor to arrow
	BRA.S	@26					; branch to sub exit pt
@25	SUBQ	#4,SP				; make room for curs handle
	MOVE	#iBeamCursor,-(SP)	; set cursor ID
	_GetCursor
	MOVE.L	(SP)+,A0			; A0 = curs handle
	MOVE.L	(A0),A0				; A0 -> cursor
	MOVE.L	A0,-(SP)			; push cursor
	_SetCursor					; set cursor to i-beam
@26	UNLK	A6					; restore stack frame
	MOVEM.L	(SP)+,A0-A3/D0-D4	; restore registers
	RTS
	
;___________________________________________________________________________
;
;   Routine: DisplayIcon
;
;	Display an icon in the top left corner of the current grafport
;
;	Entry:	A0 -> icon handle
;
;	All registers preserved
;

DisplayIcon
	MOVEM.L	A0-A3/D0-D4,-(SP)	; save registers
	PEA	IconRect		; push the icon rect location
	MOVE.L	A0,-(SP)		; push handle to icon
	_PlotIcon
	MOVEM.L	(SP)+,A0-A3/D0-D4	; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: HideControlItem
;
;	Hide the control item.
;
;	Entry:	D0 = control item number
;		A3 -> dialog
;		A6 -> local storage for item information
;
;	Called by : PromptUser
;
HideControlItem
	MOVEM.L	A0-A1/D0-D3,-(SP)	; save registers
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D0,-(SP)		; item number
	PEA	pswType(A6)	; type storage
	PEA	pswIHandle(A6)	; item handle storage
	PEA	pswBox(A6)	; rect storage
	_GetDItem
	MOVE.L	pswIHandle(A6),-(SP) ; push handle to control
	_HideControl
	MOVEM.L	(SP)+,A0-A1/D0-D3	; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: HideUName
;
;	Entry:	A3 -> PSW dialog record
;
;	Called by : PromptUser, PSWFilter
;
HideUName
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers

	MOVE.L	A3,-(SP)
	MOVE	#fItemUserTextLine,-(SP)	; hide the static string "Name".
	_HideDItem

	MOVE.L	A3,-(SP)
	MOVE	#fItemUNameEdit,-(SP)		; hide the edit field for user name.
	_HideDItem
	
	MOVE.L	A3,-(SP)
	MOVE	#fItemPTextLine,-(SP)		; hide the static string "Password".
	_HideDItem
	
	MOVE.L	A3,-(SP)
	MOVE	#fItemPEdit,-(SP)			; hide edit field for password.
	_HideDItem
	
	MOVEM.L	(SP)+,A0-A2/D0-D3			; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: HiliteItem
;
;	Highlight the control.  This can be used to dim an item.
;
;	Entry:	D0 = item number
;		D1 = value
;		A3 -> dialog
;		A6 -> local storage for item information
;
HiliteItem
	MOVEM.L	A0-A1/D0-D3,-(SP)	; save registers
	MOVE	D1,D3		; save value in D3
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D0,-(SP)		; item number
	PEA	pswType(A6)	; type storage
	PEA	pswIHandle(A6)	; item handle storage
	PEA	pswBox(A6)	; rect storage
	_GetDItem
	MOVE.L	pswIHandle(A6),-(SP) ; push handle to control
	MOVE	D3,-(SP)		; make inactive
	_HiliteControl
	MOVEM.L	(SP)+,A0-A1/D0-D3	; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: HiliteOKButton
;
;	Hilite the OK button in the dialog box.  This is used when the user
;	types the Return or Enter key and the application wants to make it
;	appear as though the mouse was pressed in the button.
;
;	Entry:	D0 = item number
;		A3 -> dialog
;
hOKType	EQU	-2		; item type used by Dialog Mgr calls
hOKIHandle EQU	hOKType-4 	; handle to item
hOKBox	EQU	hOKIHandle-8	; item rect
hOKSize	EQU	hOKBox		; size of locals

HiliteOKButton
	LINK	A6,#hOKSize	; make some space
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D0,-(SP)		; item number
	PEA	hOKType(A6)	; type storage
	PEA	hOKIHandle(A6)	; item handle storage
	PEA	hOKBox(A6)	; rect storage
	_GetDItem
	MOVE.L	hOKIHandle(A6),-(SP) ; push handle to control
	MOVE	#1,-(SP)		; set on
	_HiliteControl
	MOVE.L	#5,A0		; delay time
	_Delay			; short delay
	MOVE.L	hOKIHandle(A6),-(SP) ; push handle to control
	MOVE	#0,-(SP)		; set off
	_HiliteControl
	MOVEM.L	(SP)+,A0-A2/D0-D3	; restore registers
	UNLK	A6
	RTS

;___________________________________________________________________________
;
;   Routine: PutPswdInDlog
;
;  	This routine puts the  password in dialog if there is one
;
;	Entry:	D2 = TE handle
;		A2 -> password string
;
;	Called by: PromptUser
;
PutPswdInDlog
	MOVEM.L	D0/D3,-(SP)	; save registers
	CLR.L	D3		; clear out D3
	MOVE.B	(A2)+,D3		; get length of string
	BEQ.S	@20		; if nothing there then branch
;
; Insert the password into the actual TE record
;
	MOVE.L	A2,-(SP)		; push ptr to text chars
	MOVE.L	D3,-(SP)		; push length
	MOVE.L	D2,-(SP)		; push TE handle
	_TESetText		; put password chars into text edit record
;
; Change the password characters and pad them with maskChars
;
@05	SUBQ	#1,D3		; set index value
@10	MOVE.B	pBulletChar(A4),0(A2,D3)	; set password string with maskChars <21>
	DBRA	D3,@10		; loop if necessary
	SUBQ	#1,A2		; A2 -> masked password char string
	MOVE	#fItemPEdit,D0	; item number
	BSR	SetDIText 	; set password into dialog edit record
@20	MOVEM.L	(SP)+,D0/D3	; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: RestoreUName
;
;	Set the password editable text edit box to be the one activated and
;	cause a redraw of the name and password fields.
;
;	Entry:	A3 -> Dialog record
;		A6 -> Dialog locals
;
;	Called by : PromptUser
;
RestoreUName
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers

	MOVE.L	A3,-(SP)
	MOVE	#fItemUserTextLine,-(SP)	; show the static string "Name".
	_ShowDItem

	MOVE.L	A3,-(SP)
	MOVE	#fItemUNameEdit,-(SP)		; show the edit field for user name.
	_ShowDItem
	
	MOVE.L	A3,-(SP)
	MOVE	#fItemPTextLine,-(SP)		; show the static string "Password".
	_ShowDItem
	
	MOVE.L	A3,-(SP)
	MOVE	#fItemPEdit,-(SP)			; show edit field for password.
	_ShowDItem
	
	MOVE.L	A3,-(SP)
	MOVE	#fItemPEdit,-(SP)			; Highlite user name.
	CLR	-(SP)
	MOVE	#1000,-(SP)
	_SelIText

	MOVEM.L	(SP)+,A0-A2/D0-D3			; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: SelText
;
;	Select the entire dialog text edit record.
;
;	Entry:	A3 -> Dialog Ptr
;		A6 -> local storage for item information
;		D0 = edit text item number
;
SelText
	MOVEM.L	D0-D3/A0-A2,-(SP)	; save registers
	MOVE	D0,D3		; save item number in D2
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D3,-(SP)		; item number (user name edit rect)
	PEA	pswType(A6)	; type storage
	PEA	pswIHandle(A6)	; item handle storage
	PEA	pswBox(A6)	; rect storage
	_GetDItem
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D3,-(SP)		; item number
	CLR	-(SP)		; sel start = 0
	MOVE	#1000,-(SP)	; some large number for sel end
	_SelIText
	MOVEM.L	(SP)+,D0-D3/A0-A2	; restore registers
	RTS

;_________________________________________________________
;
;    Routine : SetArrowCurs
;
;	Set the cursor back to an arrow.  We are doing this in a subroutine
;	just to ensure that all our registers don't get munged.
;
;	Called by : PromptUser
;
SetArrowCurs
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers
	_InitCursor
	MOVEM.L	(SP)+,A0-A2/D0-D3	; save registers
	RTS

;___________________________________________________________________________
;
;   Routine: SetCtlItem
;
;	Set the value of the requested control.  This can be used to either
;	dim an item or just to turn an item on or off.
;
;	Entry:	D0 = item number
;		D1 = value
;		A3 -> dialog
;		A6 -> local storage for item information
;	Exit:	locals modified
;
;	Called by : PromptUser, ClearMethButtons
;
SetCtlItem
	MOVEM.L	A0-A1/D0-D3,-(SP)	; save registers
	MOVE	D1,D3		; save value in D3
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D0,-(SP)		; item number
	PEA	pswType(A6)	; type storage
	PEA	pswIHandle(A6)	; item handle storage
	PEA	pswBox(A6)	; rect storage
	_GetDItem
	MOVE.L	pswIHandle(A6),-(SP) ; push handle to control
	MOVE	D3,-(SP)		; value to set
	_SetCtlValue
	MOVEM.L	(SP)+,A0-A1/D0-D3	; restore registers
	RTS

;___________________________________________________________________________
;
;   Routine: SetDIText
;
;	Entry:	A3 -> dialog record
;		A2 -> text string to enter
;		D0 = item number
;		A6 -> local storage for item information
;
;	All registers preserved.
;
;	Called by : PromptUser, PutPswdInDlog, SetPswdType
;
SetDIText
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers
	MOVE.L	A3,-(SP)		; dialog ptr
	MOVE	D0,-(SP)		; item number
	PEA	pswType(A6)	; type storage
	PEA	pswIHandle(A6)	; item handle storage
	PEA	pswBox(A6)	; rect storage
	_GetDItem
	MOVE.L	pswIHandle(A6),-(SP) ; push item handle
	MOVE.L	A2,-(SP)		; string ptr
	_SetIText
	MOVEM.L	(SP)+,A0-A2/D0-D3	; save registers
	RTS

;___________________________________________________________________________
;
;   Routine: SetPswdType
;
;	Set the dialog stat text item to the appropriate password UAM.
;
;	Entry:	A3 -> dialog
;		D1 = which UAM to set string to
;		A6 -> local storage for item information
;
;	All registers preserved.
;
;	Called by : PromptUser
;
SetPswdType
	MOVEM.L	A0-A2/D0-D3,-(SP)	; save registers
	SUBQ	#4,SP		; space for result
	NEG	D1		; make D1 negative so the next add does the right thing 	{RH}
	ADD	#pswdStrStart,D1	; compute rsrc ID of string             {RH}
	MOVE	D1,-(SP)		; ID of password type string
	_GetString
	MOVE.L	(SP),A0		; get handle
	TST.L	(SP)+		; is it valid?
	BEQ.S	@10		; if not then branch
	_HLock			; lock the string down
	MOVE.L	(A0),A2		; A2 -> text string
	MOVE	#fItemPwdType,D0	; item number
	BSR.S	SetDIText 	; set the dialog text
	_HUnlock			; unlock the string
@10	MOVEM.L	(SP)+,A0-A2/D0-D3	; save registers
	RTS

;_________________________________________________________
;
;    Routine : StrCopy
;
;	Copy a string.  We have to special case for NIL source strings.
;
;	Entry:	A0 -> source string (incl length byte)
;		A1 -> dest buffer
;	Exit:	A1 -> past buffer where string was copied
;
StrCopy
	MOVEM.L	A0/A2-A3/D0-D1,-(SP)  ; save registers
	MOVE.L	A0,D0		; is the string NIL?
	BNE.S	@10		; if not then branch
	MOVE.B	#0,(A1)+		; stuff a null pathname
	BRA.S	@30		; and jump to completion
@10	CLR.L	D0		; clear out D0 longword
	MOVE.B	(A0),D0		; length of string in D0
	ADDQ	#1,D0		; includes the length byte too
	MOVE.L	A1,A3		; save A1
	ADD	D0,A3		; A3 -> after dest string
	_BlockMove		; copy string to buffer
	EXG	A3,A1		; on exit: A1 -> past copied string; A3 -> start of string
@30	MOVEM.L	(SP)+,A0/A2-A3/D0-D1  ; restore registers
	RTS			; go home

;___________________________________________________________________________
;
;   Routine: TESelCopy
;
;	Set the selection range of the actual password character TE record the same
;	as the masked dialog TE password character record.  This routine does not
;	copy the data, only the selection range.
;
;	Entry:	A1 = real Char TE handle
;		A3 -> dialog record
;		A4 -> globals
;
;	Called by PSWFilter
;
TESelCopy
	MOVEM.L	D0-D3/A0-A2,-(SP)	; save registers
	MOVE.L	teHandle(A3),A2		; A2 = handle to dialog text edit record
	MOVE.L	(A2),A2				; A2 -> text edit record
	MOVE	teSelStart(A2),D0	; get selection start
	EXT.L	D0
	MOVE.L	D0,-(SP)			; push selection start pt of masked TERecord
	MOVE	teSelEnd(A2),D0		; get selection end pt of masked TERecord
	EXT.L	D0
	MOVE.L	D0,-(SP)			; push selection end pt of masked TERecord
	MOVE.L	A1,-(SP)			; push handle to real password chars
	_TESetSelect				; set the selection range of the real pswd chars
	MOVEM.L	(SP)+,D0-D3/A0-A2	; save registers
	RTS

;___________________________________________________________________________
;
; Our Globals and other constants
;

	IF NOT (forROM or TheFuture) THEN					; can’t use data inside code in ROM		<22>
pGlobals	DCB.B	pGlobSize,0	; our block of globals

IKeyScriptDone	ds.w	1
	
	ENDIF

	ALIGN	2

OffScrRect   DC.W	$1000,$1000,$1100,$1100 ; rect or the offscreen password box
IconRect	   DC.W	$0005,$0005,$0025,$0025 ; rect in the psw dialog box for icon

	STRING	PASCAL
ThreeDotStr
	DC.B	'...'		; three dot string *** NOT INTERNATIONAL FRIENDLY
	ALIGN	2

	END
