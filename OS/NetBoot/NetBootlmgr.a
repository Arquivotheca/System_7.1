;;	File:		NetBootlmgr.a;;	Written by:	Pat Dyson;;	Copyright:	й 1989-1992 by Apple Computer, Inc.  All rights reserved.;;	Change History (most recent first):;;	   <SM2>	10/28/92	SWC		Changed the INCLUDEs to a LOAD of StandardEqu.d. Changed;									ATalkEqu.a->AppleTalk.a and ShutdownEqu.a->Shutdown.a.;		 <9>	10/14/91	JSM		Remove unneeded include of ATalkEqu2.a, add comment about things;									we need to do.;		 <7>	 6/12/91	LN		removed include 'HardwareEqu.a';		 <6>	 6/12/91	LN		removed INCLUDE 'rtmpdefs.a';		 <5>	 5/21/91	gbm		Nail a couple of warnings;		 <4>	 1/19/91	mbs		Include ATalkPrivateEQU.a to get some non-public equates that;									were moved out of ATalkEQU.a;		 <3>	 2/20/90	PWD		Removed Include dependency for XO build.;		 <2>	12/19/89	PD		Adding to bbs.;	   <1.2>	12/12/89	PWD		Added support for self-authenticating images;	   <1.1>	 11/1/89	PWD		Fixed bug on Elsie with old AppleTalk.;	   <1.8>	10/27/89	PWD		Changed to be included in the ATBoot Driver, work with net;									Booting;	To Do:;;		This file uses includes copied from the AppleTalk sources into :OS:NetBoot:ATIncludes.;		We need a better place to keep these files, preferably getting them from the AppleTalk;		source tree itself. (JSM 10/14/91); COPIED FROM APPLETALK SOURCES 10/27/1989;	lmgr.a;	This file creates the LAP Manager initialization resource 'lmgr', located in the;	AppleTalk file. It is loaded by INIT (18) and executed. It initializes the LAP manager,;	and loads .MPP and .ATP via DrvrInstall.			INCLUDE		'mppflags2.a'			PRINT		OFF			LOAD		'StandardEqu.d'			INCLUDE		'ShutDown.a'			INCLUDE		'802Equ.a'			INCLUDE		'AppleTalk.a'					; AppleTalk equates			INCLUDE		'ATalkPrivateEqu.a'				; non-public AppleTalk equates			INCLUDE		'ENETEqu.a'						; Ethernet driver equates			INCLUDE		'AARPEqu.a'						; AARP equates			INCLUDE 	'vardefs2.a'    				; Definitions of MPP local variables			INCLUDE 	'LapVars2.a'			PRINT		ON, NOGEN			INCLUDE		'LAPMgrEqu.a'					; LAP manager equatesDoOpenLap		PROC		EXPORT;еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;	The following pieces are loaded at startup for AppleTalk:;	INIT18 gets loaded by the system INIT processing. That process inserts the ROM resource;	map and performs a _GetResource. Thus looking both in ROM and the System File. To over-;	ride INIT18 then, one only needs to place a ROVR for it and its replacement resource in;	the System file.;	LMGR (this code) gets loaded by whatever technique INIT18 uses. It may be loaded out of;	ROM or the AppleTalk file depending on the INIT18. As a general rule, if INIT18 is in ROM,;	LMGR is loaded from ROM, and if INIT18 is in the system file, LMGR is loaded from the;	AppleTalk file.;	.MPP/.ATP drivers are loaded from ROM or the AppleTalk file. For each one, the ROM resource;	map is inserted and a _Get1Resource is performed. If that finds the driver AND it's version;	is acceptable, it is used from ROM, otherwise a _Get1Resource is performed on the AppleTalk;	file and another version check is made. If neither yields a driver resource, an initial-;	zation error is assumed.;	Built-in ATLK is searched for in ROM and the system file by inserting the ROM resource map;	and using _GetResource. To overide it, one needs to provide a ROVR and replacement resource; 	in the System File. A file version of the code is NEVER used.;	ALL other ATLK files are searched for first in ROM then in an ADEV file in the System folder.;	Any alternate ROM ATLK is overidden in the same manner as the Built-in ATLK.;_____________________________________________________________;; The actual INIT code - this code allocates our variables and;	installs us in the LAPWrite hook.	The LAP manager code;	starts at the address pointed to by the hook, plus 2.;_____________________________________________________________InitCode			BSR			InstallDRVRs					; install .MPP and .ATP (don't _Open)			BNE			InitRTS							; could not do it			BSR			ReadPRAM						; D1 = logical AppleTalk info			MOVEQ		#1,D2							; Assume just one port			MOVEQ		#PESize,D0						; size for ONE port entry@3			ADD			#PETblStart,D0					; Add in room for rest of variables			_NewPtr		,SYS,CLEAR						; A0 -> our variables			BNE			InitRTS							; If can't get, go away			MOVE		D2,NumPorts(A0)					; Set number of ports we support			MOVEA.L		ExpandMem,A1					; A1 -> expanded memory			LEA			ExpandMemRec.emLMgrGlobals(A1),A1 ; A1 -> our variable pointer			MOVE.L		A0,(A1)							; Save it			MOVE.L		D1,-(SP)						; Save D1 (PRAM value); <1.8>			BSR			LoadSTRs						; load strings for alerts			MOVEA.L		ExpandMem,A0					; A0 -> expanded memory			MOVEA.L		ExpandMemRec.emLMgrGlobals(A0),A0 ; A0 -> our variables			LEA			ATalkHk2,A1						; A1 -> LAP write hook			MOVEA.L		UTableBase,A2					; A2->unit table			MOVEQ		#MPPUnitNum*4,D1				; D1=offset to .MPP DCE			MOVEA.L		(A2,D1.W),A2					; A2=MPP DCE handle			MOVEA.L		(A2),A2							; deref			MOVEA.L		dCtlDriver(A2),A2				; A2=.MPP pointer			MOVE.W		drvrOpen(A2),D1					; D1=offset to .MPP open code			MOVE.W		-2(A2,D1.W),D1					; D1=offset to LAP Manager code			LEA			(A2,D1.W),A3					; A3 -> the LAP mgr code			MOVE.L		A3,D0			_StripAddress								; get real address			MOVE.L		D0,(A1)							; Set in LAPWrite hook			MOVEQ		#LInit,D0						; init run time			JSR			LAPMgrCall(A3)			MOVEA.L		ExpandMem,A3					; A3 -> expanded memory			MOVEA.L		ExpandMemRec.emLMgrGlobals(A3),A3 ; A3 -> our variables; <1.8>;			PEA			BrdgName(A3)					; Push where to put name;			MOVE		#BridgeSTR,-(SP)				; Push STR# resource ID;			MOVE		#BridgeNameSTR,-(SP)			; Push index for file name;			JSR			GetIndString					; Get it (nil if not found); <1.8>			MOVE.L		(SP)+,D1						; Restore D1			TST.B		D1								; Printer port AppleTalk?			BNE.S		DoAltATlk						; no, this is alternate atlk			BSR			InstallPrintAtlk				; Go get proper Printer Port AppleTalk			BRA.S		FinishUpDoAltATlk			BSR			ATlkInit						; Otherwise initialize the alternateFinishUp			LEA			PETblStart(A3),A3				; A3->port rec			TST.L		PEpRAM(A3)						; using built-in?			BNE.S		@useAtlk						; no			BSET		#LWSrvrWks,PEOurFlags(A3)		; localtalk honors server/wks addresses@useAtlkInitRTS			RTS											; That's it;_____________________________________________;; ATlkInit - not built-in AppleTalk.	Install alternate.;;	<1.8> If an error occurs, default to the built in and reopen;;	D1 = pRAM value;	A3 -> our variables;_____________________________________________ATlkInit	MOVE.L		D4,-(SP)						; Save some registers;			CMP.B		#BridgeAtlk,D1					; Are we configured for a bridge?;			BEQ.S		BridgeInit						; If so, do different initialization			MOVEQ		#-1,D4							; Indicate install is for non-bridge			BSR			InstallADEV						; Install AppleTalk indicated by D1			MOVE.L		D1,PETblStart+PEpRAM(A3)		; Save our pRAM value@5			TST			D0								; Installed ok?			BEQ.S		ATlkIDone						; <1.8>			BSR			InstallE						; <1.8> process error - reset to built-in														; <1.8> and reopenATlkIDone	MOVE.L		(SP)+,D4						; Restore registers			RTS											; And return;_____________________________________________;; InstallE - process an installation error;;	Uses:;	D0-D1,A3;_____________________________________________InstallE			MOVEQ		#0,D1							; Set pRAM back to zero			BSR			WritePRAM						; Write it			BSR			InstallPrintAtlk				; Go install proper Printer Port AppleTalk			MOVEA.L		ExpandMem,A3					; A3 -> expanded memory			MOVEA.L		ExpandMemRec.emLMgrGlobals(A3),A3 ; A3 -> our variables			CLR.L		PETblStart+PEpRAM(A3)			; Set port 0 pRAM value			MOVE		#1,NumPorts(A3)					; We can only support one port			RTS											; Return;__________________________________________________________;; InstallADEV - perform alternate AppleTalk installation;;	Call:;	A3 -> our variables;	D1 (long) = pRAM value (low byte is atlk resource ID);	D4 (word) = port number to install on (-1 for non-bridge);;	Return:;	D0 = error code;	D1 = new pRAM value (if bridge, must be same as old one);	D2 = 0 if couldn't find adev file; otherwise error was from AInstall;	Uses D3,A0-A2;; NOTE: trashes the application heap;__________________________________________________________InstallPrintAtlk			move.w		#LAPPrinter,d0					; Printer atlk ID			bsr.s		GetRomAtlk						; get ROM atlk resource handle			move.l		a0,d0							; is there a ROM atlk?			beq.s		@Xit							; no, leave it to Builtin@useRomPrinter			move.l		#'SC  ',d1						; set up printer port atlk special value in d1			move.w		#$101,d1						; includes LAPPrinter value in low byte			move.w		#-1,d4							; Builtin => non-Router			bsr.s		InstallTheAtlk					; go install atlk@Xit			rts;__________________________________________________________________;; GetRomAtlk - try to load ROM 'atlk' resource;;    Call:;	D0 (word) = atlk resource ID;;    Return:;	A0 (long) = handle returned by GetResource;__________________________________________________________________GetRomAtlk			move.l		d2,-(sp)						; save d2			move.w		#mapTrue,RomMapInsert			; map ROM into Resource Chain			subq		#4,sp							; Make room for handle			move.l		#'atlk',-(sp)					; Push resource type			move.w		d0,-(sp)						; Push resource ID			_GetResource								; get atlk from ROM or from System file			move.l		(sp)+,a0						; get result			move.l		(sp)+,d2						; restore d2			rts;__________________________________________________________________;; InstallTheAtlk - make install call to atlk;;    Call:;	a0 (long) = handle to atlk;	d1 (long) = value from parameter RAM with Resource ID in low byte;	d4 (word) = port number to install on (-1 for non-bridge);;    Return:;	d0 (word) = result;		noErr => atlk installed successfully;		negative => error;	condition codes reflect result in D0;__________________________________________________________________InstallTheAtlk			movem.l		a0/a2/a3/d2-d4,-(sp)			; Save registers			movea.l		a0,a3							; Pass handle in a3			move.l		(a0),a0							; A0 -> atlk code			tst.w		d4								; is this a router?			bpl.s		@installIt						; yes, d4 is proper port			moveq		#0,d4							; no, indicate port 0@InstallIt			moveq		#AInstall,d0					; Set code to do installation			jsr			atlkCall(a0)					; Call it (returns D1 = pRAM value)			movem.l		(sp)+,a0/a2/a3/d2-d4			; Restore registers			tst.w		d0								; Set Condition Codes			rts;__________________________________________________________;; InstallADEV - perform alternate AppleTalk installation;;	Call:;	A3 -> our variables;	D1 (long) = pRAM value (low byte is atlk resource ID);	D4 (word) = port number to install on (-1 for non-bridge);;	Return:;	D0 = error code;	D1 = new pRAM value (if bridge, must be same as old one);	D2 = 0 if couldn't find adev file; otherwise error was from AInstall;	Uses D3,A0-A2;; NOTE: trashes the application heap;__________________________________________________________InstallADEV			MOVEQ		#0,D2							; init part of return code			CLR.W		D0								; Prepare word for atlk Resource ID			MOVE.B		D1,D0							; Resource ID of atlk is low byte of PRAM			BSR.S		GetRomAtlk						; Try to get from ROM			MOVE.L		A0,D0							; Did we get it?			BEQ.S		@done							; <1.8> no, punt			MOVE.L		D1,D3							; D3 = current pRAM value			BSR.S		InstallTheAtlk					; an atlk was in ROM, use it			BEQ.S		@checkRomAtlk					; installation was successful@installFailed			MOVE.W		D0,D2							; indicate installation failed			BRA.S		@done							; and exit@checkRomAtlk			BSR.S		CheckPramVal					; go check pRam value			BNE.S		@installFailed					; pRam changed when it shouldn't have been			CMP.L		D1,D3							; Changed pRAM value?			BEQ.S		@okRomAtlk						; Branch if not			BSR			WritePRAM						; Write it out@okRomAtlk			MOVEQ		#0,D0							; Indicate no error@done			TST.W		D0								; Set condition codes			RTS											; That's it;______________________________________________________________________;; CheckPramVal - If running Router don't allow atlk to change PRAM value;;	Call:;		D1 = value returned by atlk install;		D3 = current PRAM value;		D4 = port number to install (-1 for non-bridge);;	Return:;		D0 = error code;		Condition codes set for value in D0;;______________________________________________________________________CheckPramVal			MOVEQ		#0,D0							; Assume successful completion code			MOVE.B		D3,D1							; Low pRAM byte must be resource ID			TST			D4								; For a non-bridge?			BMI.S		@letsRts						; If so no need to check			CMP.L		D1,D3							; Did atlk change pRAM?			BEQ.S		@letsRts						; Branch if not			MOVE.L		(A0),A0							; A0 -> atlk code again			BSR			DoAShutdown						; Shut it down			MOVEQ		#ChangedPRAMErr,D0				; Set error code@letsRts			TST.W		D0								; Set condition codes			RTS											; And return result;; DoAShutdown - issue a shutdown call.	A0 -> atlk code.;DoAShutdown MOVEM.L		A0-A3/D0-D3,-(SP)				; Save registers			MOVEQ		#AShutdown,D0					; D0 = code for shutdown			JSR			atlkCall(A0)					; Make the shutdown call			MOVEM.L		(SP)+,A0-A3/D0-D3				; Restore registers			RTS											; And return			; EJECT;______________________________________________________________________;	Load and lock .MPP and .ATP drivers and setup DCE entries.InstallDRVRs			MOVEQ		#-(ATPUnitNum+1),D3			BSR.S		@LoadAndLock					; load .ATP			BNE.S		@BadInstall			MOVEQ		#-(MPPUnitNum+1),D3				; D3=refnum			BSR.S		@LoadAndLock					; load .MPP			BNE.S		@BadInstall						; failed			MOVEQ		#0,D0			RTS											; good install@BadInstall; <1.8>			BSR			CloseAppleTalk					; close down AppleTalk@IError			MOVEQ		#-1,D0			RTS@LoadAndLock											; D3=refnum			MOVE.W		#mapTrue,RomMapInsert			; map ROM into Resource Chain			SUBQ		#4,SP							; Make room for handle			MOVE.L		#'DRVR',-(SP)					; Push resource type			MOVE.W		D3,-(SP)						; Push resource ID			NOT.W		(SP)							; id			_GetResource								; get atlk only from ROM			MOVE.L		(SP)+,A0						; get result			MOVE.L		A0,-(SP)						; Keep on stack			MOVE.L		A0,D0							; Did we get ROM resource?			BEQ.S		@IError							; no, check file load			MOVE.W		D3,D0			DC.W		$A43D							; _DrvrInstall,LOCK - make a DCE			MOVEA.L		UTableBase,A0					; A0->unit table			NOT.W		D3								; convert D3 to unit number			LSL.W		#2,D3							; convert to offset			MOVEA.L		(A0,D3.W),A0					; A0=DCE handle			MOVEA.L		(A0),A0							; A0->DCE			MOVE.L		(SP)+,A1						; A1 is handle to driver resource;	Set a pointer and keep ram bit clear even if we are in RAM due to unlocking of MPP by IOcore.			MOVE.L		(A1),dCtlDriver(A0)				; set POINTER to DRVR in DCE			MOVEA.L		dCtlDriver(A0),A1				;A1->driver code			MOVE.B		drvrFlags(A1),dCtlFlags(A0)		; copy flag byte from driver			BCLR		#dRAMBased,dCtlFlags+1(A0)		; simulate being in ROM			MOVEQ		#0,D0							; good return			RTS;__________________________________________________________________;; ReadPRAM - read from our PRAM;;	D1 = value of PRAM;	Uses A0, D0;__________________________________________________________________ReadPRAM			CLR.L		-(SP)							; Allocate room for read			BTST		#14,HWCfgFlags					; New clock chip?			BEQ.S		@10								; Assume built-in if not			MOVE.L		SP,A0							; A0 -> where to read PRAM			MOVE.L		#4*256*256+ATalkPRAM,D0			; D0 = read length and offset			_ReadXPRam									; Do the read@10			MOVE.L		(SP)+,D1						; D1 = value from parameter RAM			RTS;__________________________________________________________________;; WritePRAM - write to our PRAM;;	D1 = value to write;	Uses D0;__________________________________________________________________WritePRAM	MOVE.L		A0,-(SP)						; Save A0			MOVE.L		D1,-(SP)						; Set value on stack			MOVE.L		SP,A0							; A0 -> where to write from			MOVE.L		#4*256*256+ATalkPRAM,D0			; D0 = count and offset			_WriteXPRam									; Write to PRAM			ADDQ		#4,SP							; Pop word written			MOVE.L		(SP)+,A0						; Restore A0@10			RTS											; That's it			ENDP			END