;__________________________________________________________________________________________________
;
;	File:		StartInit.a
;
;	Contains:	This code must be placed at the very beginning of the ROM. It contains the hardware
;				start vectors and low level hardware initialization code.  It is entered through the
;				reset vector on a hardware reset or cold start.
;
;	Originally written			by Larry Kenyon				February 1983
;	Substantially rewritten		by Wayne R. Loofbourrow		June 1986
;	Hopelessly scrambled		by Jerome T. Coonen			mid-September 1986
;	Mercilessly hacked			by everyone but the Pope	throughout 1989 and beyond
;	Unscrupulously kludged		by TERRORists				first year, last decade, 20th century
;	Totally messed up			by SuperMario players		Nov 1991-Jan 92
;	Released upon the world		by Pandorists (Not!)		MCMXCII
;	Scrambled again				by SuperMario World			May 92 - Dec 92
;	Repaired					by PDM guys					1993
;	Spell-Checked				by TNT guys					shortly thereafter
;
;	Copyright:	© 1983-1994 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	 <SM163>	  2/2/94	DCB		Added call to INITSCSIBOOT so that it gets called after Slot
;									Interrupts and ADB are initialized.  It used to be called from
;									SCSIMgrInit but that was too early and screwed up third party
;									SIMs.
;	 <SM161>	 1/28/94	chp		For TNT: allow most everything except the .Sound driver.
;	 <SM160>	  1/4/94	LB		For TNT: allow floppy driver installation.
;	 <SM159>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
;									machines.
;	 <SM158>	 12/2/93	chp		For TNT: allow serial driver installation.
;	 <SM157>	11/10/93	chp		For TNT: enable VIA interrupts for SetUpTimeK; install a
;									pseudo-slotVBL interrupt for PCI video cursor tracking; disable
;									several drivers.
;	 <SM156>	 11/9/93	KW		added some eieioSTP macros.  Only expands for CygnusX1 ROM
;	 <SM155>	 11/8/93	SAM		Roll in <MC7> from mc900ftjesus.
;	   <MC7>	 11/8/93	SAM		Removed some confusing, misleading, and commented out code to
;									adjust gestalt's lram size (following initgestalt).
;	 <SM154>	10/25/93	SAM		Roll in <MC6> from mc900ftjesus.
;	   <MC6>	10/25/93	SAM		Moved the call to CheckforResetPRAM a little earlier in the boot
;									(just following the Cuda/Egret init).
;	 <SM153>	10/15/93	SAM		Roll in <mc5> from mc900ftjesus.
;	   <MC5>	10/15/93	SAM		Deleted the NuBusReset code for Bart (leftover from the last
;									checkin).  Removed the code that created the bogus "heap"
;									gestalt selector.
;	 <SM152>	10/12/93	SAM		Roll in <MC4> from mc900ftjesus.
;	   <MC4>	10/12/93	SAM		Moved the Bart Nubus reset from here to USTStartup.  Made the
;									figment "heap" gestalt setup universal.
;	 <SM151>	 10/4/93	JDR		undo change SM150. it was already being done in SndPrimitives.a
;	 <SM150>	 10/1/93	KW		Installing tables for sound primitives. Allows Quadras/Wombats
;									to record, set volume level etc. Great if moved to SoundMgr
;									initialization code.
;	 <SM149>	 9/28/93	SAM		From mc900ftjesus.
;	   <MC3>	 9/26/93	pdw		Added NOT hasAsyncSCSI around call to InitSCSIHW since
;									InitSCSIMgr does the hardware init when AsyncSCSI is present.
;	   <MC2>	 9/25/93	SAM		Removed the build time conditional around the call to InitEgret.
;									Added a runtime check to EgretDFACandPDM.  Cleaned up the
;									intialization of SoundBase (again). Changed CheckForEgret to
;									CheckForEgretOrCuda. Removed PDM Evt1 support from NuBusReset &
;									DynamicBoxFlag
;	 <SM146>	 9/13/93	SAM		Updated the Gestalt heap install stuff.  Initialized the
;									HeapUtilities globals ptr .
;	 <SM145>	 9/12/93	pdw		Split up InitIOMgr into InitIOPStuff, InitDeviceMgr and
;									InitDrivers.
;	 <SM144>	  9/3/93	GMR		Changed bit used for BART slot disable from bit 0 to bit 7. Also
;									fixed a problem found by Fernando in RdVidParam that causes us
;									not to boot if we have a video card without on-board video
;									connected.
;	 <SM143>	 9/1/93		SKH		Finish SetupTimeK export.  (Forgot to add change history)
;	 <SM142>	 9/1/93		SKH		Export SetupTimeK because the portable dynamic speed stuff needs it
;	 <SM141>	 8/23/93	pdw		Added support for LimitPRAMClear, IgnoreCmdOptShDel,
;									LoadDefaultOnly - three options required for AIX security,
;									enabled by setting bits in PRAM $76.
;	 <SM140>	 8/20/93	BG		Modified DynamicBoxFlag to know about CarlSagans.
;	 <SM139>	 8/20/93	chp		Rather than calling InitPDMDMA explicitly from StartInit,
;									install that routine as an interrupt initialization postproc in
;									the AMIC interrupt primitives table. (See InterruptHandlers.a).
;									It is executed as part of the call to InitIntHandler.
;	 <SM138>	 8/16/93	RC		Made changes to CheckForResetPRAM routine.  I added support for
;									saving off some of the PRAM information which is needed for
;									security reasons (mostly needed by the AUX team)
;	 <SM137>	 8/12/93	SAM		Undid the last two changes (not needed).  Added code to
;									NuBusReset to disable Slot E IRQs for multiple slot PDM style
;									machines with a BART NuBus controller.
;	 <SM136>	 8/12/93	KW		adding two more smurf wombats
;	 <SM135>	 8/11/93	KW		added some branches based on new smurf boxes
;	 <SM134>	  8/4/93	JDR		Integrate sound manager 3.0 project.
;	 <SM133>	  8/3/93	GMR		Added code to issue a NuBus reset on PDM machines with BART.
;									Ideally, this should be before diagnostics....
;	 <SM132>	 7/20/93	SAM		Changed the name of the offset in the new ROM header that points
;									to the 7.0 toolbox init code to be "InitSys7ToolBoxOff" instead
;									of InstallMgr which wasn't very descriptive.  Added code to
;									create 768 master pointers in the System heap at its creation.
;									This will help keep the sys heap from becoming fragmented.
;	 <SM131>	  7/9/93	PN		Remove my last change
;	 <SM130>	  7/2/93	PN		Add conditional hasCPUIDregister
;	 <SM129>	  7/1/93	KW		Set SoundBase to ROM address 40800000 if ROM is in RAM.
;	 <SM128>	 6/29/93	SAM		Added code to install a "heap" gestalt selector if Figment is
;									around.
;	 <SM127>	 6/29/93	SAM		Commented out the code that added the Edisk size to the
;									*physical* RAM size!  All logical RAM size adjustments are made
;									from within Gestalt (as it was).
;	 <SM126>	 6/24/93	SAM		Updated PDM's dynamic boxflag code to include a new set of
;									"boxes" (fridge).
;	 <SM125>	 6/22/93	kc		Setuo parameter to FROVideo before calling it.
;	 <SM124>	 6/21/93	kc		Fix InitIOMgr so that it doesn't trash a0 (and the UnitTable).
;	 <SM123>	 6/17/93	rab		Moved initialization of expandmem to before InitIntHandler.
;									Fixes some boot problems caused by the Ludwig roll-back.
;	 <SM122>	 6/14/93	kc		Roll in Ludwig.
;	  <LW17>	 4/14/93	fau		Made the CheckForTV use CivicExists, instead of BoxFlags.
;	  <LW15>	 4/11/93	chp		Rewrite serial driver installation code in InitIOMgr. Use
;									ProductInfo to select the correct 'SERD' resource.
;	  <LW14>	  4/9/93	fau		Changed the EdiskDriver to use the InstallDrvr routine so that
;									it doesn't stomp on a previously installed driver.
;	  <LW13>	  4/8/93	fau		Changed the open of the netboot driver to use the InstallDrvr
;									routine, so it uses the lowest refnum above -47, instead of the
;									resource id.  This is much more friendly.
;	   <LW7>	 2/16/93	ejb		move initialization of realtime mgr, rt drvr, and dsp std snd to
;									gibbly so that strings and icons can be localized.
;	   <LW6>	 2/11/93	PW		Removing IMPORT of SCSILoad (it's not used in this file).
;	 <SM121>	  6/3/93	SAM		Chas.  I thought we had an agreement here...  Added dynamic
;									boxflag hack for HMC machines.
;	 <SM120>	  6/1/93	CSS		Touch this file so Universal ROM version can be updated (v $02).
;	 <SM119>	 5/18/93	CSS		Touch this file so Universal ROM version can be updated (v $01).
;	 <SM118>	  5/9/93	SAM		Removed bogus soundmgr init code that was writing an
;									uninitialized value into the sound mgr globals.
;	 <SM117>	  5/7/93	joe		& CCH.  Bumped MinSysExtra constant to compensate for all the
;									new stuff being thrown in.  It's previous size was causing
;									booting problems on PDMs and Smurfs.
;	 <SM116>	  5/6/93	SAM		Removed some _SwapMMUMode calls.  Fixed ConfigureRAM to not
;									write past the top of RAM if the RAM size is not a multiple of
;									64k.  Changed another one of those nasty SIGNED address
;									comparisons.
;	 <SM115>	  5/5/93	CSS		Touch this file so Universal ROM version can be updated (v $00).
;	 <SM114>	 4/20/93	CSS		Touch this file so Universal ROM version can be updated.
;	 <SM113>	 4/11/93	chp		Rewrite serial driver installation code in InitIOMgr. Use
;									ProductInfo to select the correct 'SERD' resource.
;	 <SM112>	  4/8/93	SAM		Added calls to "INSTALLBASSCOMMON" and "FORCEINITFONTSCALL" to
;									initalize Bass before the first call to _InitGraf (which calles
;									_InitFonts).
;	 <SM111>	  4/1/93	GMR		Moved PDM's DMA stuff to InterruptHandlers.a.
;	 <SM110>	 3/31/93	GMR		Fixed a bug in PDM's DMA handler when dealing with bits 8,9.
;									Optimized the handler. This stuff belongs in InterruptHandlers.a, 
;									and will be moved there soon.
;	 <SM109>	 3/31/93	chp		Remove support for Cyclone EVT3 (limited changes from Ludwig).
;	 <SM108>	 3/25/93	RB		In order for interrupt handlers to run from RAM when running a
;									virtual ROM, the InfoRecord needs to be adjusted so it points to
;									its RAM copy.
;	 <SM107>	 3/11/93	SAM		Indirection, indirection.  Why use one instruction when you can
;									use two.  Lvl5IrqHandler.
;	 <SM106>	 3/11/93	SAM		Added a check before the adjustment to total ram size before
;									InitGestalt that wont adjust anything if the EDisk was not
;									stolen from the 68k mmu tables.  Added a refCon to the DMA irq
;									handler.
;	 <SM105>	  3/4/93	RC		Added check of AMIC to determine if we need to load the SERD 1
;									resource or not.  One line is currently commented out to keep it
;									from loading until we have fixed hardware
;	 <SM104>	 2/25/93	RB		When running from RAM, the hard coded offsets used for ROM
;									vectors need to be adjusted after calling InitROMVectors.
;	 <SM103>	 2/23/93	RC		Bug fix to the Level 5 Interrupt Handler for PDM/AMIC
;	 <SM102>	 2/22/93	RC		Use a Gestalt check around GoNative.
;	 <SM101>	 2/20/93	SAM		Ok, here goes...Added a InitDMA routine that sets up a structure
;									in expandmem for dealing with multiple DMA interrupt sources.
;									Rearranged several calls after BootRetry to 1) make more sense,
;									and 2) necessitate creating expandmem much earlier than it
;									previously was.  Moved the installation of the 040BlockMove
;									routine much earlier.  Put several Supports24Bit's round things.
;									Changed many *signed* comparisons - everyone needs to stop
;									making singed Address comparisions!  Made the GoNative install
;									universal.
;	 <SM100>	 2/12/93	PN		Change BEQ.S to BEQ.W to fix the build
;	  <SM99>	 2/10/93	RB		Reviewed by CS. Added code to copy ROM code into RAM for
;									performance. Removed some of the NOT LC930 stuff, since it is
;									obsolete after the test code Steve added.
;	  <SM98>	  2/5/93	GMR		Added check for SWIM3 in InitIOMgr, to support SonyDriver on
;									PDM. Extended SetupHWBases to deal with all 96 basesValid bits.
;									Setup IWM in SetupHWBases if SWIM3Exists.
;	  <SM97>	  2/5/93	RC		GoNative is needer for both PDM and Smurf
;	  <SM96>	  2/5/93	SAM		Temporarily conditionalize assembly of the GoNative installation.
;	  <SM95>	 1/15/93	RC		Took out the Auto Launch of RAM Disk on PDM
;	  <SM94>	 1/10/93	RC		Added more nops for Smurf
;	  <SM93>	12/23/92	RC		GoNative turned back on
;	  <SM92>	12/21/92	SWC		Pulled InstallPrivTrap out of the has040MMU conditional since it
;									installs the correct routine into the trap for both an Ô881 and
;									an Ô040 style FPU.
;	  <SM91>	12/17/92	RB		Removed some of the LC930 conditionals now that Steve added a
;									bunch hasPwrControls conditionals. Changed some of the other
;									LC930 conditionals to use has2MegROMOrMore. Others were changed
;									to has040. Re-enabled some 24 bit mode code with the conditional
;									Supports24Bit.
;	  <SM90>	12/11/92	RC		Temporarily comment out the Branch to GoNative until the
;									GoNative code is a little more ready for the ROM
;	  <SM89>	12/11/92	SWC		Rearranged stuff at BootRetry so that machine/feature specific
;									support can be setup earlier so there's not a gray region where
;									the world is kinda set up.
;	  <SM88>	12/10/92	JDB		ejb: Fix my ENDIF
;	  <SM87>	12/10/92	ejb		remove code for installing RTSndIn Driver- as this is not
;									needed.  The SoundMgr will take care of this.
;	  <SM86>	 12/8/92	RC		Installing GoNative as soon as Resource manager and memory
;									manager are up and alive
;	  <SM85>	 12/8/92	SWC		Fixed an LC930 gotcha from <SM84>.
;	  <SM84>	 12/8/92	SWC		Moved LCDScreenChk->PowerMgr.a. Cleaned up the backlight, DSP
;									driver loading since some pieces of code were duplicated 3
;									times. Did some general cleanup and removed unused code.
;     <SM83>	12/06/92	HY		Remove space in .Sound and .EDisk definitions as a result of 
;									change in <SM82> which preceded strings with STRING PASCAL directive.
;									This caused the EDisk and Sound drivers from being loaded.
;	  <SM82>	 12/5/92	SWC		Moved InitSndHW, InitSndNoRAM to SndPrimitives.a. Removed the
;									ASC test before the call to InitSndHW since that routine will
;									now do what's appropriate for each machine. Cleaned up the
;									initial low mem setup. Removed the PowerBook 140 boxFlag patch.
;	  <SM81>	 12/4/92	SWC		Moved InitMemMgr->MemoryMgr.a, InitRsrcMgr->ResourceMgr.a,
;									InitDTQueue->DeferredTaskMgr.a, SwitchMMU->MMU.a.
;	  <SM80>	 12/3/92	PN		Back out the change in SM72 since a better fix is implemented in
;									Startboot.a
;	  <SM79>	12/02/92	HY		Zeroed out memory on stack before calling InitEgretAlt. This could 
;									potentially cause sporadic crashes on RESTART. Also changed 
;									InitHiMemGlobals to use BaseOfROM to decide where BufPtr should
;									be set to in 24-bit mode (LC based machines are at $00A00000).
;									Bracketed call to EnableSwimIOPInts in InitIOMgr with "IF hasIopSwim".
;	  <SM78>	 12/2/92	SWC		Moved PortableCheck to PowerManager.a.
;	  <SM77>	 12/2/92	ejb		move installation of RTSnd beforeRTDrvr since driver now calls
;									StdSndSignInCPUDevice
;	  <SM76>	 12/1/92	SWC		Removed the call to EnableParityInts since it was only used on
;									the IIfx (and has gone away).
;	  <SM75>	11/25/92	PW		Changed minSysExtra value from 16K to 64K to attempt to (and
;									apparently did) fix the many drivers-not-loading bugs (NewPtr
;									failed).
;	  <SM74>	11/24/92	RB		In the SetApp_Base routine, put support for 24 bit mode.
;	  <SM73>	11/20/92	fau		Put a test around InitSndHw so we don't call it if an ASC doesn
;									not exist.  Enabled MUNI Interrupts on Cyclone.
;	  <SM72>	11/19/92	PN		Radar #1050264 the SetAppBase patch needs to be rolled in
;									correctly. At the early init time, the patch to the _SetAppBase
;									is not needed. Yet we roll the patch into SetApplBase routine so
;									we have to replace _SetAppBase with JSR SetApp_Base so that the
;									_InitApplZone is not called.
;	  <SM71>	11/14/92	kc		Export MyROM.
;	  <SM70>	11/11/92	RB		The code that sets MemTop should be executed before Gestalt is
;									initialized. Moved the code to earlier in the boot process. Put
;									back the old Sound Manager (7.1) for the LC930, since Sadism is
;									not ready.
;	  <SM69>	11/11/92	GD		Made a change to support Romulator for PowerBooks.
;	  <SM68>	 11/7/92	rab		Roll in Horror changes. Comments follow: ¥ÊFrom StartInit.a ¥
;		<H11>	 8/25/92	BG		Modified SetupTimeK so that the VIATime loop is unaligned. This
;									'fixes' a problem with the floppy driver doing a wait loop that
;									is unaligned and taking too long, causing MFM writes to occur
;									too late.
;		<H10>	 7/21/92	NJV		Removed hasSonora1 conditionalized code (no longer needed)
;		<H9>	 7/13/92	GMR		Now initialize ExpandMem before InitADB so we can initialize the
;									CrsrDev stuff when InitADB is called.
;									¥ÊFrom StartInitPatch.a ¥
;		<H19>	 9/13/92	NJV		Added initialization of DJMEMC's new diagnostic register on a
;									warm start (the Sound Block Configuration Register).
;		<H16>	07-01-92	jmp		Made the change in <H13> only take effect on warm-starts.
;		<H13>	06-26-92	jmp		Added some code to InitSoundHW that checks for the presence of a
;									djMEMC.  If a djMEMC exists, this code then shuts off the
;									djMEMCÕs (DAFBÕs) sync control so that video is off BEFORE the
;									boot beep occurs.
;		<H12>	 6/24/92	ag		Added Dartanian to the list of cpu's which must use the sound
;									pan registers for volume control. Allow Zero volume which will
;									mute the boot beep. Zero volume is only achived if the user set
;									it to zero, invalid pram will default to level 5.
;	  <SM67>	11-04-92	jmp		Cleaned up the enable cache code to be a little more
;									maintainable.
;	  <SM66>	 11/4/92	mal		Put back enable cache code that was erroneously removed in rev
;									64.   Removed 2nd StartInit.a from end of file that was
;									erroneously added in rev 64.
;	  <SM65>	 11/3/92	RB		Changed the use of LC930 in the 24 bit mode support test to
;									Supports24Bit. Change the include of SCSIEqu.a to SCSI.a,
;									VideoEqu.a to Video.a and ATalkEqu.a to AppleTalk.a
;	  <SM64>	 11/3/92	fau		Together with Mlaw:  Loaded a new SoundBase that points to the
;									start of the MarioBootSound in ROM, instead of the middle of
;									ROM.  Also, chaned the gestalt in <SM59> to use a TestFor macro,
;									as it is much faster.
;	  <SM63>	 11/2/92	fau		Added a check on Cyclone/Tempest to determine if the user has
;									Cmd-opt-T-V held down (if so, it will allow for booting off
;									without a monitor, directing output to the composite video
;									port).
;	  <SM62>	10/30/92	RB		On the LC930, do not force 32 bit mode, since it supports 24 bit
;									mode.
;	  <SM61>	10/29/92	RB		Removed the temporary ADBReinit call I added because it takes a
;									long time. Added a low ROM address for InitROMVectors since the
;									intl' OS guys need it.
;	  <SM60>	10/27/92	CSS		Changed some short branches to word branches.
;	  <SM59>	10/27/92	fau		Used gestaltSoundHardware to determine whether to install the
;									sound interrupt handlers for ASC machines.
;	  <SM58>	10/22/92	fau		Moved ADBReinit <SM56> to before grayscreen, so that the user
;									won't see a frozen mouse.  This call should just be temporary
;									and a fix to the Q950 should be found.  ADBReinit takes like 1
;									second to execute!
;	  <SM57>	10/22/92	fau		Got rid of all MMCExists by making them DSPExists or PSCExists.
;	  <SM56>	10/22/92	RB		Exclude any PowerManager calls from the LC930 build (1 Meg ROM).
;									Call ADBReInit at Startup to fix the mouse freeze bug in 950's.
;									Made the startup port be the one that Boot3 expects as defined
;									in the BootGlobals.
;	  <SM55>	10/18/92	CCH		Added a nop to flush pending writes and a RAM Disk on PDM.
;	  <SM54>	10/12/92	RB		Exclude 040 specific code from the LC930 1 Meg ROM build.
;	  <SM53>	 10/7/92	CSS		Fixed so only non-cyclone machines will load the SoundDriver which
;									is now back in ROM.  This is a hack to get the sound volume on Quadra to
;									work.
;	  <SM52>	 10/6/92	RB		Added the ROMinRAM conditional to avoid RESET when buidling a
;									ROM that will be copied to RAM in order to do testing. Killed
;									the register to use with some of the BIG macros, since the
;									macros have been updated for 68020's.
;	  <SM51>	 10/5/92	PN		Fix MacII si booting process with InitROMVector after InitMMU
;	  <SM50>	 10/2/92	PN		Set 32bit mode in PRAM
;	  <SM49>	 9/18/92	kc		Change InitVectors to InitRomVectors. Change short branches to
;									long branches.
;	  <SM48>	  9/8/92	chp		Install default primary SCC interrupt handlers as soon as the
;									PSC dispatch table is set up on Cyclone, and enable SCC
;									interrupts once and for all. InitSCC rewritten to remove
;									unnecessary code left over from pre-ADB Macs.
;	  <SM47>	 8/26/92	kc		Roll in Horror changes.
;		<H9>	 7/13/92	GMR		Now initialize ExpandMem before InitADB so we can initialize the
;									CrsrDev stuff when InitADB is called.
;		<H5>	 2/12/92	SWC		Added a call to InitCrsrDev in InitCrsrMgr so that the new mouse
;									acceleration stuff can be installed. Moved call to InitCrsrMgr
;									to just after ExpandMem is initialized since the CrsrDev stuff
;									keeps its globals there.
;	  <SM46>	 8/26/92	PN		Set SoundBase global to a safe location since it is no longer
;									valid.  Apps that write to this address will safely write to
;									ROM.
;	  <SM45>	 8/19/92	CSS		Update from Reality:
;									<72> 8/18/92 DTY	Change the name of BootGlobs to StartGlobals to avoid confusion
;														with BootGlobals, which is used by the boot code in Boot[1-3].a.
;	  <SM44>	 8/17/92	CCH		Extended universal support to 96-bits.
;	  <SM43>	08-11-92	jmp		Added ReAnimator support for Õ030 CPUs (taken straight from
;									HORROR).
;	  <SM42>	  8/9/92	CCH		Added conditional StartPC address for Smurf cards.
;	  <SM41>	 7/28/92	WS		Init DSP now use gestaltRealtimeMgr instead of checking the box
;									flags
;	  <SM40>	 7/27/92	RB		The ExpandMem record should be allocated just after we have a
;									System heap. When the resource Manager is called some of its
;									routines use the ExpandedMem record, which was being allocated
;									way after many things called the Resource Manager. Main bug
;									fixed was trashing SCCRd for the serial drivers.
;	  <SM39>	 7/24/92	RLM		move initGestalt before InitIOMgr, this allows lockmem calls
;									from initNewAge, note GetEDiskSize in initGestalt no longer
;									requires the drivers to be installed, also InitSCSIMgr comes
;									after InitIOMgr per Pauls request
;	  <SM38>	 7/15/92	JDB		Removed the code to install the SoundInput driver (it was
;									commented out and unnecessary).
;	  <SM37>	  7/9/92	RB		The Sound Manager was not working right on the Quadras because
;									the routine to enable the interrupts from the old Sound Manager
;									needed to be called and it wasnt.
;	  <SM36>	  7/7/92	RB		Added back a call to INITIALIZESOUNDMGRCOMMON from the sound
;									manager for sound input.
;	  <SM35>	  7/6/92	RB		Put back InitSndDispatch and InitMACEDispatch because Jim says
;									we need them after InitSoundMgr.
;	  <SM34>	 6/29/92	RB		Removed the old calls to initialize the sound manager and
;									replaced it with a new call, InitSoundMgr for the new new sound
;									manager.
;	  <SM33>	 6/25/92	kc		Do what I said I did last time.
;	  <SM32>	 6/25/92	kc		Disable the data cache on Cyclone until after InitSlots. This is
;									to work around a bug in MMC that will be fixed in EVT4. The
;									problem is caused when MUNI asserts TEA and another buss master
;									starts a transation befor MMC times out. The new MMC will watch
;									for TEA as well as TA for cycle termination.
;	  <SM31>	 6/25/92	PN		Put in init routine for WindowMgr to allocalte an extend memory
;									varialble
;	  <SM30>	 6/25/92	ejb		Add code to initialize RTSnd (DSP Standard Sound). Added and
;									disabled code to install RTSndIn (DSP Sound Input Driver).
;	  <SM29>	 6/24/92	chp		Use different SERD resource with PSC to enable DMA Serial
;									Driver.
;	  <SM28>	 6/22/92	kc		Added call to INITVECTORS.
;	  <SM27>	 6/22/92	ejb		Re-enabled DSPManager for EVT2 Cyclones.  Added branch to
;									DSPDriver initialization just before Sound Manager stuff.
;	  <SM26>	 6/20/92	ejb		Completely disabled RTMgr initialization for all EVTx units
;									until RTMgr rev'd to BOMII d12.
;	  <SM25>	 6/18/92	RB		Added a compile time conditional to ¥ temporarily not open the
;									DSP (RealTime Manager) on Cyclones other than EVT1 Cyclone.
;	  <SM24>	 6/15/92	RB		Caches should be disabled on Cyclone only during development.
;	  <SM23>	 6/12/92	PN		Roll in patchIIciROM.a. Check for PowerBook140 and set the
;									boxflag
;	  <SM22>	 6/10/92	JSM		PatchMDJGNEFILTER is now MDJGNEFILTER.
;	  <SM21>	  6/1/92	RB		¥ Temporary: Do not open the NewAge driver on Cyclone since it
;									frezzes the machine.
;	  <SM20>	 5/28/92	kc		Hack DrawBeepScreen.
;ÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ¥¥¥ÊWe need to Roll in the WindowMgrPatch file from Horror ¥¥¥
;	  <SM19>	 5/28/92	CS		Call to Open the video driver needs to be added.
;	  <SM18>	 5/28/92	kc		¥¥¥ Kill the caches for ROM bring up. ¥¥¥
;	  <SM17>	 5/27/92	CS		Fix problem with label @noMMC jumping backwards. Need to change
;									name as it exists in this scope.
;	  <SM16>	 5/24/92	RB		Making Cyclone changes...Updated some of the old comments which
;									seemed to have been cut-off by some tool. Call EgretDFACandPDM
;									from the Pandora roll-in instead of QuadraEgretChanges. Added
;									code that installs the DSP Manager at runtime after checking for
;									Cyclone. Initialize dbLite docking bar and scsi disk mode. Check
;									for LCD screens instead of PowerBook 170 boxflags. Added New Age
;									driver installation code. Deleted some old SE30 patch. 
;									¥¥¥ LCDScreenChk, SCSIDiskMode commented out temporarily.
;	  <SM15>	 5/23/92	RB		Changed a bsr to bsr.l, also made the SuperMario ROM release id
;									field a word, so I had to change its location.
;	  <SM14>	 5/22/92	FM		Turned off vectorization temporarily
;	  <SM13>	 5/21/92	RB		Defined the location for the SuperMario ROM version which will
;									be used to determine which vectors to load from disk.
;	  <SM12>	 5/21/92	kc		Append "Trap" to the name of DTInstall to avoid name conflict
;									with the glue.
;	  <SM11>	 5/16/92	kc		Roll in Horror changes. Comments Follow: ¥ÊFrom StartInit.a ¥
;		<H7>	  4/8/92	SWC		Modified InitHiMemGlobals to force BufPtr to be at least
;									"bufWorldSize" bytes (currently 8K) below the top of RAM so
;									Macsbug won't load into [DBLite's] sound buffer and get trashed
;									when a sound is played.
;		<H6>	 2/19/92	JC		Define PatchFlags in unused byte of ROM header ($0014).
;		<H5>	 2/12/92	SWC		Added a call to InitCrsrDev in InitCrsrMgr so that the new mouse
;									acceleration stuff can be installed. Moved call to InitCrsrMgr
;									to just after ExpandMem is initialized since the CrsrDev stuff
;									keeps its globals there.
;		<H2>	 9/10/91	CMP		Overpatched InitIWM to handle SWIM2 chip
;									¥ÊFrom PwrControlsPatches.a ¥
;	   <H14>	 4/24/92	HJR		Provided Econo-Mode support for Niagra.
;	   <H10>	 3/16/92	SWC		Added support for 33MHz MSC systems to CheckEconoMode.
;		<H9>	 2/21/92	HJR		Modified check sleep to use new ram locations instead of
;									obsolete VRam space.
;		<H8>	 2/10/92	HJR		Fix a bug where we are returning from a BSR6 without setting the
;									return address in A6.
;		<H7>	  2/7/92	SWC		Modified the CheckEconoMode code to lookup the correct base
;									Power Manager PRAM address from the primitives tables.
;		<H6>	 1/24/92	SWC		In CheckEconoMode, do both econo-mode setup and chip
;									configuration for the MSC case.
;		<H2>	  8/8/91	SWC		Added import of USTPMGRSendCommand and modified the econo mode
;									code to use it instead of sending the bytes discretely.
;									Universalized the ADB code so that it supports interrupts on CA2
;									and PMGR auto-polling for DB-Lite.  Fixed PortableCheck so it
;									handles the case when VRAM doesn't retain power across sleep
;									(state saved in PMgrGlobals).  Added EnableSCSIIntsPatch so we
;									won't enable SCSI interrupts on DB-Lite.
;									¥ÊFrom StartInitPatch.a ¥
;		<H7>	12/18/91	SWC		Modified InitSWIM2 to check for the existance of registers as
;									well as doing a bus error check since the final MSCs in DB-Lite
;									don't generate a bus error if the chip isn't there.
;		<H5>	10/30/91	SWC		Added a check to InitSWIM2 to first check if the chip is even
;									installed (bus error) to support DB-Lite where the SWIM chip is
;									on an external board that may or may not be connected at startup
;									time.
;		<H2>	 9/11/91	CMP		Added InitSWIM2 to support SWIM2 chip.
;	  <SM10>	 4/22/92	RB		Added a call to vector initialization routine of the Window
;									Manager, which is temporarily vector $2000. This is for
;									experimentation.
;	   <SM9>	 4/15/92	RB		The 040 BlockMove was fixed almost immediately after I broke it.
;									So I am re-enabling that code back. Removed the bullets in
;									comment in <SM3> so that we know it's been taken care of. Also
;									re-enabled 040 caches.
;	   <SM8>	 4/14/92	kc		Remove call to BTreeInstall.
;	   <SM7>	 3/24/92	PN		Add new soundmgr init into the existing soundmgr initialize
;									routine. Disable 040 caches.
;	   <SM6>	  3/4/92	kc		Remove the 7.0 manager initialization calls.
;	   <SM5>	  3/4/92	PN		Adding a vector for InstallMgr
;	   <SM4>	  3/4/92	kc		Add call to _InitFS and comment out call to the install TimeMgr
;									patch.
;	   <SM3>	  3/4/92	kc		Rearange the ordering to get around interdependencies. Added the
;									code from StartBoot.a that initializes the managers 
;									 We need to fix the 040 BlockMove 
;	   <SM2>	 2/12/92	RLM		Roll in PatchMDJGNEFILTER PatchProc. 
;									¥ Pre-SuperMario Comments Follow ¥
;		<71>	 1/30/92	KC		(Really JSM) Change low byte of ROMVersion to $7D just to be
;									really different from $067C.
;		<70>	 1/27/92	KC		Fix bug in cpu test (change blt.s to bne.s).
;		<69>	 1/27/92	KC		Remove call to InitNonMMU, and added runtime cpu check in
;									SwitchMMU.
;		<68>	 1/23/92	KC		Roll in Zydeco patches from StartInit.a and StartInitPatches.a
;									From StartInit.a and StartInitPatches.a
;		{30}	 5/31/91	djw		 (for SWC) Call InstallSonyDriverPatch (StartInitPatches.a) to
;									 check for the existence of either an IWM/SWIM or SWIM IOP before
;									 installing the floppy driver (for systems without floppy
;									 drives).
;									From Zydeco StartInitPatches.a: (original comments were missing)
;									 Added hasEDisk and forRomulator conditionals.
;									 Removed call to InitOverPatch and InitVidGlobals.
;									 Removed InitVidGlobals stub.
;									 Rolled in OpenNetBootPatch and EDiskPatch2 and ConfigureRAMPatch.
;									 Changed WhichCPU to use the data instead of instruction cache.
;									 Added code to check location of boot globals in InitHiMemGlobals.
;									 Added InitNonMMU and CheckForEgretOrCuda and call to
;									 InitEgretAlt which were deleted in last revision.
;									 Moved call to GetPRAM to before the call to InitMemMgr.
;									 Added call to InitMemoryDispatch, InstallPrivTrap, InstallFPSP and InitNonMMU.
;		<67>	 1/15/92	KC		Fix comment from last checkout.
;		<66>	 1/15/92	KC		Resolve BootGlobals name collision caused by moving the
;									BootGlobals record into BootEqu.a (changed BootGlobals to 
;									BootGlobalsSize & QDBootGlobals to QDBootGlobalsSize).
;		<65>	  1/3/92	RB		Install an optimized BlockMove for 68040 based CPUs.
;		<64>	12/31/91	RB		Use RAMConfigBase only on HcMac
;		<63>	12/30/91	RB		Need to export INITSNDNORAM since the new boot beep code calls
;									it.
;		<62>	12/29/91	RB		Removed the implementation of ElsieTranslate24to32 since it is
;									in a QuickDraw file too.
;		<61>	12/27/91	RB		Open backlight driver on machines with Power Mgr.
;		<60>	12/27/91	RB		Added Terror changes.
;		<59>	11/16/91	DTY		Replacing hard addresses with a record to make the equates Òmore
;									universalÓ is nice but useless if the code has no way of getting
;									to those addresses any more.  Add equates for VidRAMSleepFlag
;									and VidRAMWakeVect to this file to keep the ROM build building
;									until the hardware guys figure out what theyÕre trying to do.
;		<58>	10/17/91	JSM		Get rid of all the stupid conditionals.
;		<57>	 10/2/91	JSM		Use MemoryMgrPriv.a instead of HeapDefs.a.
;		<56>	 10/1/91	JSM		DonÕt use onMvMac conditional, Modern Victorian never existed.
;		<55>	 10/1/91	JSM		DonÕt use hasADB conditional, all future ROMs will support ADB.
;		<54>	 10/1/91	JSM		DonÕt use eclipseDebug.
;		<53>	 9/30/91	JSM		DonÕt use is32BitClean conditional, all future ROMs will be.
;		<52>	 9/27/91	JSM		DonÕt use hasCQD conditional, all future ROMs will have color
;									QuickDraw.
;		<51>	 9/16/91	JSM		Cleanup header.
;		<50>	 6/12/91	LN		Changed #include 'HardwareEqu.a' to 'HardwarePrivateEqu.a'
;		<49>	 5/21/91	gbm		Nail a couple of warnings
;		<48>	 12/7/90	dba		Institute dead-code stripping.
;		<47>	10/22/90	JJ		Rex V8: Change VISAChipBit to V8ChipBit.
;		<46>	 9/24/90	BG		Changed the code at the very very start of the ROM that
;									determines whether or not the CPU involved is an 040. The code
;									first used the 040 Data Cache Enable bit in the CACR <19>, but
;									that was switched when earlier versions of the 040 died
;									immediately upon turning on the data cache. However, the correct
;									bit to use is the data cache enable bit, and this mod. switches
;									back to using that. Also changed various ugly raw constant
;									references of bits set/tested/etc. in the CACR to symbolic
;									constants defined in HardwarePrivateEqu.a.
;		<45>	 9/19/90	BG		Removed various 040-related kludges. 040s are behaving more
;									reliably now.
;		<44>	 9/14/90	MSH		Put in a fancy new universal check for wake from sleep (ok, its
;									not really elegant, you got a better idea?).
;		<43>	  9/1/90	BG		Updated to handle Eclipse EVT1 board.  Specifically - Egret
;									lowmems were only initialized if the Universal tables say that
;									we have ADBEgret.  We also needed to initialize them if we have
;									ClockEgret.
;		<42>	  7/4/90	CCH		Added check to SetupHiMemGlobals to move bootglobs if its above
;									ROM (when ROM is in RAM) and added a check that skips SCC
;									initialization if running from RAM.
;		<41>	  7/3/90	BG		Turn off 040 caches if we*re running from RAM.
;		<40>	  7/2/90	jmp		Made no changes, accidently checked out file.
;		<39>	 6/28/90	BG		Rolled in changes for Eclipse/040.
;		<38>	 6/12/90	NC		Add the calls to init all the Sound I/O Manager stuff correctly.
;		<37>	  5/8/90	JJ		Added code to disable the MemoryDispatch trap if the machine has
;									no MMU or has an HMMU.
;		<36>	  5/3/90	GMR		ConfigureRAM now merges contiguous RAM chunks into a single
;									chunk.
;		<35>	  5/1/90	DAF		Removing ELSIE Huge Hack to BufPtr
;		<34>	 4/21/90	GMR		Moved ConfigureRAM functionality to SizeMem.a, to solve problems
;									with writing the chunk table before stitching occurs. Before,
;									pages within a bank might swap (depending on bank size/location)
;									after stitching, causing the chunk table to no longer be at the
;									end of the bank.
;		<33>	  4/4/90	MSH		Removed universal test around InitPmgrVars.
;		<32>	  4/4/90	JJ		Temporary hack to make "special" setting of BufPtr take place on
;									Elsie.
;		<31>	 3/29/90	MSH		Added universal test for Pmgr initialization.
;		<30>	 3/27/90	JJ		Fixed bugs in ConfigureRAM code for VISA II.
;		<29>	 3/23/90	JJ		Replaced VISA I code in ConfigureRAM with code for both VISA I
;									and VISA II.
;		<28>	 3/22/90	JJ		Change reset vector to begin execution in overlay ROM space
;									rather than actual ROM space.
;		<27>	 3/22/90	MSH		Changes to clock.a require small modifications to the PRAM
;									calls.
;		<26>	 3/21/90	SS		Removed the Egret initiatlization code.  I moved it into
;									USTStartUp.a after the RAM tests.
;		<25>	 3/13/90	GA		Added a call to Egret to Stop AutoPoll and one second interrupts
;									prior to running Diagnostics.
;		<24>	 2/28/90	JJ		Added code to install ElsieTranslate24To32 routine as the
;									Translate24To32 trap on machines with VISA decoders.
;		<23>	 2/28/90	GMR		Changed Egret run time checks to use new equates.
;		<22>	 2/20/90	CCH		Updated some comments.
;		<21>	 2/20/90	CCH		Added routine to configure Orwell memory controller to
;									ConfigureRAM.
;		<20>	 2/19/90	NC		Put in initialization calls to the 7.0 Sound Manager if on a
;									machine with Egret. THIS WILL CHANGE WHEN A REAL FLAG IS
;									AVAILABLE!
;		<19>	 2/16/90	BG		Modified cache testing and enable/disable instructions not to
;									use the 040 data cache since it is non-functional in the current
;									rev. of the 040 silicon. Switched usage of DE to IE in places
;									where it matters.
;		<18>	 2/11/90	GA		Added endwith to with statements inside hasEgret conditionals
;		<17>	  2/9/90	BG		Added code to enable 040 caches.
;		<16>	  2/9/90	JJ		VIA CPU ID bits $1110 assigned to Elsie.  Modified InitSCC to
;									avoid addressing location 1 below SCC base address.  SCC reset
;									now done by sending $C0 command to SCC.  Add routine for VISA
;									decoder to ConfigureRAM.  Force result of CompBootStack to be
;									even.
;		<15>	  2/4/90	CV		HwCfgFlags gets read from d2, not from the universal tables.
;									With an optional FPU, the table may not have the correct value.
;		<14>	  2/4/90	GA		Added Calls to InitEgret and conditionals with Universal runtime
;									checks.
;		<13>	 1/15/90	BG		Corrected the enabling the of the instruction cache in WhichCPU.
;									Also modified comments in WhichCPU, SwitchMMU to reflect
;									reality.
;		<12>	 1/14/90	GGD		NEEDED FOR ZONE-5: Changing the order of reset/mmu disable at
;									start time to prevent possible double bus errors on machines
;									with overlay bits. Also fixed a few bugs in the 040 detection
;									code.
;		<11>	 1/11/90	CCH		Added include of ÒHardwarePrivateEqu.aÓ.
;		<10>	 1/10/90	BG		Updated WhichCPU to recognize 040s.
;		 <9>	  1/9/90	BG		Change StartBoot to be run-time detection of 040s instead of
;									assembly-time for universality.
;		 <8>	  1/8/90	BG		Changed the code at StartBoot so that it does the correct thing
;									for the 040.  Unfortunately, this is an assembly-time change
;									(for now) because the way you deal with the TC register is
;									radically different than on the 020/030, and the 040 CACR looks
;									and acts differently than the 020/030.
;		 <7>	  1/6/90	BG		Updating MMU- and Cache-related code to work correctly on the
;									040. This is assembly-time conditionalized for now but will be
;									changed to Runtime checking later (where possible).
;		 <6>	  1/4/90	BG		Adding MACHINE MC68040 directive into the SETMACHINE macro. This
;									will only be invoked if CPU = 040, a condition no one should be
;									seeing unless you do a -Mac040- build.
;		 <5>	12/27/89	SWC		Forgot to include a "WITH DecoderInfo" for the parity stuff.
;		 <4>	12/26/89	SWC		Replaced "#"s with ";"s for the following comment since the
;									AddChange script was messed up when this file got checked in.
;		 <3>	12/26/89	SWC		Setup FMC configuration to do the right thing for both parity
;									and non-parity systems.
;		 <2>	12/21/89	CCH		Fixed up comment header.
;	  <11.7>	11/28/89	SWC		Removed references to FMCRev2 since Zone 5 has the final version
;									of its memory controller.
;	  <11.6>	11/15/89	GMR		NEEDED FOR ZONE-5. Added call to EnableParityInts that sets the
;									OSS RPU's mask reg to level 7 if the RPU is present.
;	  <11.5>	11/10/89	MSH		Rolled in support for both black fill and white fill for hcmac
;									NTSCmode.
;	  <11.4>	10/31/89	PWD		Restore stack pointer after checking if the netBoot driver is
;									there before _Opening it.
;	  <11.3>	10/31/89	MSH		Took the conditional assembly of TEGlobalInit out, now always
;									assembles. Changed
;	  <11.2>	10/31/89	PWD		Added net booting. Just Opens the driver after the .Sony driver.
;	  <11.1>	 8/23/89	SES		Temporarily add MBProcHndl to this file until all nfile
;									references in all sources are removed. Once nFiles are removed,
;									MBProcHndl should be put into ToolEqu.a.
;	  <11.0>	 8/22/89	SES		Removed references to nFiles. Changed include DeclRomEqu.a to
;									RomEqu.a.
;	  <10.9>	 8/22/89	GMR		Removed RunDiags, always call universal StartTest diags now.
;									Prep A2 with VIA1 base before calling quasiPwrMgr when reading
;									RamDisk size, to work with universal RdXByte.
;	  <10.8>	 8/16/89	BBM		made EDisk open on feature ÒhasEDiskÓ, rather than the hack
;									onHcMac.
;	  <10.7>	 7/27/89	CCH		Fixed _real_ bug that was trashing a4 in configureRam, and
;									restored fixAddr.
;	  <10.6>	 7/27/89	CCH		Fixed bug in fixAddr that was using address of bank B as it's
;									size.
;	  <10.5>	 7/25/89	CCH		Modified configureRAM for glue chip and FMC based machines to
;									adjust universal info pointers and return address on stack if
;									their addresses change as a result of setting memory size bits
;									when forRomulator flag is set.
;	  <10.4>	 7/17/89	GGD		Fixed comment from last change, added call to InitOverPatch.
;	  <10.3>	 7/16/89	GGD		NEEDED FOR AURORA: Modified the Reset PRAM key sequence to
;									preserve the Reliability manager PRAM bytes, but invalidate all
;									others.
;	  <10.2>	 7/14/89	djw		NEEDED FOR AURORA: Removed getting warmstart in initslots - now
;									done in startsdeclmgr.
;	  <10.1>	 7/14/89	SWC		NEEDED FOR AURORA: Changed CACR setup so that bursting is
;									disabled only on F-19s with old FMCs.
;	  <10.0>	 7/13/89	GGD		Added check for Cmd-Opt-R-P keys at boot time to Reset PRAM, in
;									case PRAM contents prevents booting for some reason.
;	   <9.9>	  7/8/89	CCH		Modified to work with Romulator.
;	   <9.8>	  7/6/89	GGD		Un-Proc'd WriteSCC because code falls into it, and alignment
;									would screw it up. Changed the FMC rev 1 vs 2 code to produce
;									code that is the same size in both cases. Added some padding for
;									overpatching.
;	   <9.7>	  7/5/89	CCH		Added ROM build version to ROM Header.
;	   <9.6>	 6/30/89	rwh		handle memory sizes not supported by hardware on FMC, GLU
;									machines.
;	   <9.3>	 6/30/89	CSL		initialize new low mem LockMemCt to zero. Also removed
;									Dispatcher vector from Foreign OS vector table
;	   <9.2>	 6/30/89	smb		NEEDED FOR AURORA: Added call to TEGlobalInit for TE vectors
;									stored in ExpandMem.
;	   <9.5>	 6/30/89	DAF		Added additional error checking to gamma loading routines to
;									prevent allocation of garbage on cards w/o gamma directory
;	   <9.4>	 6/30/89	CSL		Fixed bug in SysHoleheap, field for cMoreMasters should be size
;									word, not size long. and put conditional around TEGlobalInit to
;									exclued HcMac.
;	  <¥9.5>	 6/30/89	DAF		Overriden again! There wasn't enough room on Reality to submit
;									before!
;	  <¥9.5>	 6/30/89	DAF		Override submission because of network problems
;	   <9.1>	 6/29/89	rwh		Needed for AURORA: handle Bank B size > bank A for glu chip
;									machines. Marked 9.0 changes.
;	   <9.0>	 6/28/89	rwh		NEEDED FOR AURORA: moved MMU switch code to Foreign OS table.
;									Cleaned up comments near start for the BootGlobals way.
;	   <8.9>	 6/27/89	rwh		NEEDED FOR AURORA: changes to get FMC rev 2 working. Removed
;									RoundUp of screen buffer sizes, since we wrap before AND after
;									video buffer now. Changed error codes in CheckSize, but still
;									need equate!
;	   <8.8>	 6/26/89	GMR		Exported StartTestFlags.
;	   <8.7>	 6/20/89	SWC		Replaced immediate constant with lomem variable for HcMac in
;									DrawBeepScreen.
;	   <8.6>	 6/16/89	SWC		Save and restore registers around ValidatePRAM call.
;	   <8.5>	 6/16/89	CSL		Moved ValidatePRAM to after StartTest.
;	   <8.4>	 6/15/89	SWC		Added a call to ValidatePRAM (Clock.a) to make sure PRAM's got
;									good stuff in it.
;	   <8.3>	 6/13/89	DAF		Moved routine which calculated dead macÕs top left corner inline
;									into StartFail.a
;	   <8.2>	 6/12/89	rwh		corrected comment in FixAddr. Fixed setting of Glu size bits in
;									ConfigureRam. Added register usage comments in ConfigureRam.
;									Fixed booting in 24 bit mode w/>8mb RAM. Made InitSlots switch
;									to 32 bit mode to access BootGlobs.
;	   <8.1>	 6/12/89	djw		Added universal slot zero pram support in GetRBVSize. GGD got
;									Mac SE Rom in Ram working again.
;	   <8.0>	 6/11/89	GGD		Updated to use new Video, hwCfgFlags, and ROM85 info from
;									Universal Rom tables.
;	   <7.9>	 6/11/89	GMR		Added call to universal StartTest diagnostics, in place of
;									'fake' diags.
;	   <7.8>	 6/11/89	GMR		Added some BIG Jmp/Jsr's to fix link errors. Fixed initNonMMU to
;									handle bad RAM disk size.
;	   <7.7>	 6/10/89	GGD		Updated box flag names.
;	  <¥7.6>	 6/10/89	SWC		Initialized screen dimension lomems for Mac Plus/SE so that they
;									can be used consistently on all machines. Fixed a bug in
;									SetupHWBases (wrong bit tested). Always include ColorEqu.a
;									(instead of conditional on hasCQD). Got rid of TestInRAM and
;									associated code at StartBoot. Initialize BootGlobPtr on all
;									machines so that the warmstart flag can be saved. Moved
;									InitPmgrVars to PoweResourceMgr.a. Fixed a bug in InitNonMMU: A6
;									was getting trashed. Bad dog, rwh!
;	   <7.4>	 5/31/89	rwh		removed some orphan code from ConfigureRam (sloppy!)
;	   <7.3>	 5/30/89	DAF		Updated InitDefGamma to use the card ROM's gamma directory if
;									present
;	   <7.2>	 5/30/89	rwh		made ConfigureRam set up 'offset to top of bank' field in boot
;									globals, and put stack halfway thru 1st bank of RAM. Change
;									InitNonMMU to get at RAM chunk table using a6 instead of sp.
;									Fixed conditional around import from change 7.1.
;	   <7.1>	 5/30/89	CSL		moved code to enable external cache to HWPriv.a and called the
;									routine. Changed RunDiags to not run Aurora diags on NuMac
;									machines.
;	   <7.0>	 5/29/89	GGD		Added runtime test to InitIWM to only call it if an IWM/SWIM
;									exists. Added the ROM version number for all 32 bit universal
;									roms. ($7C same as Aurora) Added check to see if StartTest
;									matches machine we are running on, and only run it if there is a
;									match. Added a fake StartTest for all other cases, which just
;									beeps and sizes memory for now. Converted to a few more feature
;									base conditionals. Removed the Alternate Diag Rom check for
;									020/030 machines, since it couldn't possibly work, and we were
;									just branching around it. Added temporary runtime check for F19,
;									to not enable bursting. Added call to SCCIOPHwInit in InitSCC
;									for IOP based machines. Added special case runtime test for the
;									SE30 only to undo the patching that the SE30 video driver Open
;									call installs to the Sony Driver ICON information.
;	   <6.9>	 5/26/89	rwh		oops! never added call to ConfigureRam!
;	   <6.8>	 5/26/89	rwh		added Reliability Manager. Moved ConfigureRam from MMU.a to
;									here, w/ggd's changes from version 2.3. Improved field names in
;									BootGlobs, replaced FixMeLater's w/ BootGlobPtr's. Changed
;									CompBootStack, SetUpSysAppZone to handle 'black hole' before
;									system heap. Fixed bug in InitHiMemGlobals's clip of memory at 8
;									meg for 24 bit mode.
;	   <6.7>	 5/26/89	GGD		Added some BIG Lea/Jsr to fix link errors.
;	   <6.6>	 5/22/89	GMR		Added InitNonMMU routine, to setup registers [a4-a6] so builds
;									will run on hcMac and MacPP again.
;	   <6.5>	 5/20/89	GGD		Changed SetupHWBases to initialize SCCrd/wr, and IWM, using
;									table info, since the IOP base addresses now point to the bypass
;									mode register base. Changed conditional on parity code to allow
;									IoMac to build again. Added universal support to the IOP manager
;									initialization routine.
;	   <6.4>	 5/16/89	rwh		fix GetRBVsize - coupla missing lines 'o code
;	   <6.3>	 5/16/89	rwh		Added code to enable external cache on MDU based systems (ggd).
;									Removed call to BootBeep, Start test does it now. New GetRBVSize
;									courtest dave fung. Changed many bsr's to BigJsr's to fix link
;									errors. Added save of parity enable state on via across call to
;									InitVias. Put stack in middle of 1st bank before calling
;									InitMMU. Deleted calls to RamTest, as all memory testing now
;									done in Start Test. Added MMU switch sky hook for Pink & A/UX.
;									Removed ALL Ramtest calls, Start Test tests all of RAM now. For
;									csl, when in 32 bit, change Translate24to32 to an rts.
;	   <6.2>	 5/15/89	GGD		Saved and restored A5 around call to BootBeep, to fix MacPP
;									builds. Removed the procedure InitADBVars, which is now done as
;									part of InitADB.
;	   <6.1>	 5/14/89	rwh		fixed bad MACHINE directives for 68000 builds
;	   <6.0>	 5/14/89	rwh		changes for universal MMU setup: call InitMMU instead of
;									MapAddress. With boot globals, can save & restore less
;									information around various RAM tests.
;	   <5.9>	 5/10/89	CCH		Added test for Mac II's when running in RAM that will give
;									GetHardwareInfo a hint that it's running on an 020 machine, so
;									it will not twiddle VIA bits which turn off the MMU. Also figure
;									out memory size in startinit when running out of RAM.
;	   <5.8>	 4/30/89	GGD		Implemented new improved table driven, universal, SetupTimeK
;									routine. Reworked InitSlots to remove calls to routines that
;									were eliminated from SIntCore. Removed hardware dependencies,
;									and called universal routines to enable and disable various
;									interrupt sources. VIA and hardware base initialization are now
;									done using universal ROM tables and routines The Low memory
;									globals for hardware base addresses are now kept updated
;									throughout StartInit, to allow routines to be more universal.
;									WhichBoard now uses universal rom information. WhichCPU
;									completely re-written to not use low mem exception vectors.
;									Changed MapAddress to preserve some registers across the call,
;									and re-arranged some of the registers that is uses to abtain
;									that. Added call to JumpIntoROM to find the ROM and machine
;									info. Removed old test for hard reset.
;	   <5.7>	 4/28/89	CSL		Initialized Phys2Log for Physical to logical convertion value
;									for MMU table. PhysicalRAM and SystemRAM is renamed to
;									PhysMemTop and RealMemTop.
;	   <5.6>	 4/27/89	CCH		Added changes to make Romulator work.
;	   <5.5>	 4/24/89	MSH		Gave everyone but Mac Plus the latest SCC init table data.
;	   <5.4>	 4/18/89	CCH		Added changes for Rom in Ram to work.
;	   <5.3>	 4/17/89	CSL		Added 2 vectors for A/UX, for Dispatcher and StartSDeclMgr, also
;									initialize two new lo mem PhysicalRAM and SystemRAM.
;	   <5.2>	 4/14/89	GMR		Disable ADB interrupts in BootRetry. Later InitADB is called to
;									set up the handler and re-enable them.
;	   <5.1>	 4/13/89	MSH		InitPmgrVars uses a new power manager command ($21) to clear ADB
;									autopolling.
;	   <5.0>	 4/13/89	GGD		Changed OSS interrupt mask initialization to use new names from
;									hardwareEqu. Added initialization of new VIA2RBVOSS lowmem, and
;									changed various routines to get base addresses from memory
;									instead of using absolute addresses. Started converting to
;									feature based conditionals. Made Foreign OS tables available on
;									all CPUs. Cleaned up comment and code for the 4 bit CPUID field
;									extraction.
;	   <4.9>	  4/7/89	MSH		InitPmgrVars disables auto polling, loads pmgr interrupt
;									handlers, and enables pmgr interrupts. Also backed out change
;									4.8. StartTest will clear warmstart if a hard reset ocurred.
;	   <4.8>	  4/4/89	SES		Added check for PwrMgr reset on HcMac. If PwrMgr reset occurred,
;									then Ram test is run regardless of warmStart value.
;	   <4.7>	  4/3/89	MSH		Clear MMUType if no mmu exists. This area needs work to support
;									all combinations of MMUs, processors, and accelerators.
;	   <4.6>	 3/31/89	SES		Added some BigJSRs & BigLEAs for IoMac & MvMac.
;	   <4.5>	 3/31/89	MSH		Made battery monitor into sound monitor vbl task.
;	   <4.4>	 3/28/89	SES		Moved MapAddress above first call to RAMtest. For hcMac, hafMac
;									and mvMac StartInit is once again making the calls to RAMtest,
;									but BootBeep is still called in StartTest.
;	   <4.3>	 3/24/89	CCH		Added RomLoc location in Rom Header to hold information on where
;									ROM is executing from (i.e. Ram, Emulator).
;	   <4.2>	 3/22/89	CSL		Turn on Burst mode for I/D cache, also ROMmap is now a 32 bit
;									heap, also fix slimy RockWell VIA bug by saving output reg. A in
;									WhichBoard routine. New code to replace SwapMMUmode with
;									SwapMMU32only for pure 32 bit only addressing.
;	   <4.1>	 3/14/89	MSH		Added Esprit ASIC register init that was pulled for starttest.
;	   <4.0>	  3/9/89	MSH		Updated an equte in init pmgr vars.
;	   <3.9>	  3/6/89	GGD		Modified InitIWM to force SWIM chip to switch into IWM mode to
;									prevent looping if SWIM did not get reset properly (HcMac does
;									not do a RESET on restart, and has problems) Added deferred task
;									manager for onMacPP. Moved InitXVectTables to
;									InterruptHandlers.a, and renamed it InitIntHandler. Added
;									conditional support for Ram based onMacPP rom image. Added an
;									extra entry in the ROM header for HiRam to use to insert the ROM
;									Size. Contimued effort to make the ROM position independent,
;									allowing for an initial PC that assumes the ROM is mapped to
;									zero at start time, and the jumps into the real ROM space.
;									Changed RBV register usage now that equates are offsets from
;									RBVBase, instead of being absolute addresses.
;	   <3.8>	  3/3/89	CCH		Now initializes expandMem and Gestalt.
;	   <3.7>	  3/3/89	MSH		Initialize LastAct and LastHd to 1.
;	   <3.6>	  3/2/89	jwk		Adding "BigJSR INITADB" so that IoMac will build.
;	   <3.5>	  3/1/89	MSH		Cleaned up topanga support.
;	   <3.4>	 2/28/89	CSL		Added support for 32 bit clean memory manager.
;	   <3.3>	 2/27/89	CSL		changed RBV on board video from slot E to slot 9 for DVT and
;									later machines.
;	   <3.2>	 2/21/89	CSL		changed movea to movea.l in MapAddress.
;	   <3.1>	 2/16/89	rwh		added support for Fitch Memory Controller rev 1, which has a
;									split memory model like MDU. WHen FMC2 arrives (contiguous
;									memory), remove these changes. Removed conditionals for
;									non-working Vias.
;	   <3.0>	 2/16/89	SES		Jumped around the remaining Ram test for hafMac. Will revisit
;									later.
;	   <2.9>	 2/14/89	SES		Jumped around a memory test and bootbeep for HafMac since they
;									are currently being done by the StartTest files.
;	   <2.8>	 2/14/89	rwh		made some lea's & bsr's into BigLea's and BigJsr's to fix link
;									problems. Fixed
;	   <2.7>	 2/10/89	rwh		Oops! Appletalk checks for ROM version ³ 76 for presence of
;									Start Manager (with
;	   <2.6>	  2/9/89	CCH		Made version numbers of HafMac, HcMac, and MvMac all $01, since
;									this is the first iteration of each ROM.
;	   <2.5>	  2/8/89	SGS		Added support for SCC IOP
;	   <2.4>	  2/8/89	MSH		dded support for Topanga video interface converter. NTSC
;									monitors require a narrowed
;	   <2.3>	  2/6/89	rwh		Fix MapAddress: on 4Mb 4Square, 1st entry in 1st level 32 bit
;									mode table 2nd
;	   <2.2>	 1/30/89	cv		Added Spin as a CPU type
;	   <2.1>	 1/28/89	GGD		Added scratch register to new BigLEA/JMP/JSR macros to be
;									position independent. Fixed assembly error, and logic errors in
;									Mac II class board id routine.
;	   <2.0>	 1/25/89	rwh		rewrote parts of WhichBoard to generalize for newer 4 bit id
;									machines. Fixed two bugs in MapAddress for MDU machines w/o
;									onboard video.
;	   <1.9>	 1/23/89	CSL		put conditional around setting MMU24Info
;	   <1.8>	 1/23/89	CSL		Initialize MMU24Info to point to the physical address of the MMU
;									table
;	   <1.7>	 1/20/89	CSL		Generate MMU tables for any RAM configurations, for both 24 bit
;									and 32 bit mode.
;	   <1.6>	12/15/88	GGD		Added initialization of TimeVIADB and VIA2RBV low mems.
;	   <1.5>	12/14/88	MSH		Changed VIA interrupts to be independent active negative edge.
;	   <1.4>	12/13/88	rwh		added startup of IOP Scc in InitSCC. Must be done before
;									calculating TimeSccDb. Even though IOP is in bypass at reset,
;									timing differs when it is running.
;	   <1.3>	11/23/88	rwh		Added cache enables after last call to RamTest.
;	   <1.2>	11/17/88	GGD		Deleted code for InitDispatcher and BadTrap, they are now
;									located in Dispatch.a Changed GoofyDoEject to do a BigJMP so
;									that TFS code can move away some more.
;	   <1.1>	11/10/88	CCH		Fixed Header.
;	   <1.0>	 11/9/88	CCH		Adding to EASE.
;	   <3.1>	 11/6/88	GGD		Ported to IoMac.
;	   <3.0>	 11/1/88	MSH		Moved the init of the deferred task manager out of slot init.
;									Now anyone can use it.
;	   <2.9>	10/24/88	CSL		added temporary address translation table for RBV RAM based
;									screen buffer.
;	   <2.8>	 10/7/88	rwh		changed some MvMac, MMU, ADB and generic 020/030 stuff to
;									feature based conditionals. Made sound, IWM base addr name
;									uniform on all machines.
;	   <2.7>	 10/5/88	CSL		Added support for RBV and MDU.
;	   <2.6>	 9/29/88	MSH		Flagged time outs to be dirty when allocated so they get updated
;									later.
;	   <2.5>	 9/24/88	rwh		oops - fix 2.4's missing ENDIF in non-onMvMac builds.
;	   <2.4>	 9/24/88	rwh		roll in onMvMac changes. Note that InitADB moved to after
;									InitIOMgr to support Gary's IOP based ADB implementation.
;	  <¥2.3>	 9/23/88	CCH		Got rid of inc.sum.d and empty nFiles
;	   <2.2>	 9/12/88	rwh		Fix WhichBoard so it builds for onHcMac.
;	   <2.1>	 9/10/88	rwh		Roll in of Mac IIx changes: New WhichCPU routine.
;									InitHiMemGlobals pegs BufPtr to 8 Meg or less. CompBootStack
;									uses BufPtr, not MemTop, for ALL machines. Ensure RAM tests are
;									done in 32 bit mode for >8 Meg machines. Add WhichBoard routine,
;									BoxFlag global for identification of logic board. Turn off 030
;									MMU at start of HW Init sequence. Remove obsolete Rev8Chk
;									routine & calls to it.
;	   <2.0>	  9/9/88	MSH		Added initialization of lomem value screenbytes for hcmac.
;	  <1.15>	  9/8/88	MSH		Moved allocation and initialization of Pmgr vars. Added read of
;									sleep and hard disk time outs from pram into pmgr locals.
;	  <1.14>	 8/16/88	GGD		Moved Time Manager initialization into TimeMgr.a.
;	  <1.13>	  8/5/88	MSH		Removed useless Speedometer setting
;	  <1.12>	 6/24/88	MSH		New equate used for turning off everything at end of init for
;									HcMac.
;	  <1.11>	 6/15/88	MSH		Removed ram testing and boot beep, now done in StartTest for
;									HcMac. StartTest returns start of RAM Disk in A5 in on HcMac.
;									Use instead of MemTop. Removed the eyebrows from the startup
;									gray screen.
;	  <1.10>	 5/27/88	MSH		Restored video ram test temporarily and fixed stack
;									initialization.
;	   <1.9>	 5/26/88	MSH		Moved NMInit IMPORT to MyROM PROC.
;	   <1.8>	 5/26/88	MSH		Took out redundant ram testing and fixed the ASC interrupt clear
;									for HcMac.
;	   <1.7>	 5/25/88	MSH		Added EDisk driver open for Laguna.
;	   <1.6>	 5/23/88	BBM		Put NMgr init code in proper place (after traps inited).
;	   <1.5>	 5/23/88	BBM		added code to initialize the Notification Manager.
;	   <1.4>	 5/19/88	BBM		Fixed reference to GNEFilter.
;	   <1.3>	 5/16/88	BBM		Use alarm code from Notification Manager. cleaned up comments.
;	   <1.2>	 4/25/88	MSH		Clear pending ASC interrupt for HcMac
;	   <1.1>	 4/18/88	CSL		Need to turn off serial drivers at end of boot. Initialize
;									speedometer to 16 mhz.
;	   <1.0>	 2/10/88	BBM		Adding file for the first time into EASEÉ
;__________________________________________________________________________________________________

			PRINT		OFF
			LOAD	'StandardEqu.d'
			INCLUDE	'HardwarePrivateEqu.a'
			INCLUDE	'MemoryMgrPriv.a'
			INCLUDE	'SCSI.a'
			INCLUDE	'MMUequ.a'
			INCLUDE	'BootEqu.a'						; Must appear after MMUEqu.a

			INCLUDE	'ROMEqu.a'
			INCLUDE	'SlotMgrEqu.a'
			INCLUDE	'Video.a'
			INCLUDE	'DepVideoEqu.a'

			INCLUDE	'ColorEqu.a'
			INCLUDE	'UniversalEqu.a'
			INCLUDE	'ReliabilityEqu.a'
		IF hasEgret THEN
			INCLUDE	'EgretEqu.a'
		ENDIF
			INCLUDE	'EDiskEqu.a'
			INCLUDE	'SCSIEqu96.a'
		IF hasPwrControls THEN
			INCLUDE	'PowerPrivEqu.a'
		ENDIF
			INCLUDE	'PSCEqu.a'						;														<SM16>
			INCLUDE	'IOPrimitiveEqu.a'						;														<SM16>
			INCLUDE	'GrandCentralPriv.a'
			
			INCLUDE 'GestaltEqu.a'					;														<SM41>
			INCLUDE 'GestaltPrivateEqu.a'			;														<SM59>

		IF hasNetBoot THEN
			INCLUDE 'AppleTalk.a'					; 														<SM65>
			INCLUDE	'AtalkPrivateEQU.a'
		ENDIF
		
			PRINT	ON
			BLANKS	ON
			STRING	ASIS

		
;----------------------------------------------------------------
; Equates
;----------------------------------------------------------------

dsGNLoadFail	EQU			20011		
MBProcHndl		EQU			$D54					;put it here until we're rid of nFiles

;	During startup, the system heap is growable (since it masquerades in appÕs clothing).  This constant
;	specifies how much space we need beyond the suite of drivers and before the final size is specified.

MinSysExtra		EQU		128*1024						; was 16K		<SM117> CCH & joe												<SM75>

;	The boot time stack size depends on quickdraw, since thereÕs no significant nesting of start routines.
;	WARNING -- cross-defined in StartBoot.a

BootStackSize	EQU		8*1024

;	While drawing HorstÕs BeepScreen, a QD world is required just below the area where the boot blocks are
;	loaded.  BootGlobalsSize gives the amount below the boot blocks buffer where the stack can begin.
;	QDBootGlobalsSize gives the amount above the stack that the A5 world can begin.  We err on the big side
;	here for slackÕs sake.  For example, on a megabyte machine, MemTop is $100000.  Boot blocks will arrive
;	at $80000.  Allowing $400 for boot globals and $190 (400 decimal) for QD globals, SP would be at $7FC00,
;	and A5 at $7FD90.  The utter clarity of it all!

BootGlobalsSize		EQU		$400						; 1K for QD and other globals
QDBootGlobalsSize	EQU		$190						; a mere 400 bytes for QD

; <60>, move this constants to hardwareprivateequ later...

nuBusTTxlat		EQU		$807FC040					; nubus space $8-$F with serialized writes 
;ioNuBusTTxlat	EQU		$403FC040					; ROM, I/O space and nuBus $6-$7 with serialized writes	<T19>
ioNuBusTTxlat	EQU		$500FC040					; I/O space and nuBus $6-$7 with serialized writes		<T19>			
			


			MACRO
			SETMACHINE
	IF CPU = 020 THEN
			MACHINE		MC68020
	ELSEIF CPU = 030 THEN
			MACHINE		MC68030
	ELSEIF CPU = 040 THEN
			MACHINE		MC68040
	ELSE
			AERROR		'Unknown CPU type'
	ENDIF
			ENDM


			SETMACHINE



;---------------------------------------------------
; EXPORTs and IMPORTs
;---------------------------------------------------

;	labels from other files

			IMPORT	BaseOfRom

			IMPORT	BadTrap							; Dispatch.a
			IMPORT	BlockMove68040					; BlockMove.a											<SM9>
			IMPORT	BootBeep						; BootBeep.a
			IMPORT	BootMe							; StartBoot.a
			IMPORT	CritErr							; StartFail.a
			IMPORT  CrsrDevHandleVBL				; CrsrDev.a
			IMPORT	DisableIntSources				; InterruptHandlers.a
			IMPORT	DispTable						; DispTable.a
			IMPORT	DoEject							; TFS.a
		IF hasEgret THEN
			IMPORT	EgretDFACandPDM					; EgretMgr.a											<SM16>
		ENDIF
			IMPORT	ElsieTranslate24To32			; QDUtil.a
			IMPORT	EMT1010							; Dispatch.a
			IMPORT	Enable60HzInts					; InterruptHandlers.a
			IMPORT	EnableExtCache					; HWPriv.a
			IMPORT	EnableOneSecInts				; InterruptHandlers.a
			IMPORT	EnableSlotInts					; InterruptHandlers.a
		IF hasIopSwim THEN
			IMPORT	EnableSwimIopInts				; InterruptHandlers.a
		ENDIF
			IMPORT	EraseMyIcon						; StartSearch.a
			IMPORT	FSIODneTbl						; DeviceMgr.a
			IMPORT	GetExtHardwareInfo				; Universal.a
			IMPORT	GetHardwareInfo					; Universal.a
			IMPORT	InitADB							; ADBMgr.a
			IMPORT	InitCrsrDev						; CrsrDev.a
			IMPORT	InitCrTable						; CCrsrCore.a
			IMPORT	InitDispatcher					; Dispatch.a
			IMPORT	InitDTQueue						; DeferredTaskMgr.a
		IF hasEgret THEN
			IMPORT	InitEgretOrCuda					; EgretMgr.a
		ENDIF
			IMPORT	InitFasterInvals				; WindowMgrExtensions.a
			IMPORT	initGestalt						; GestaltFunction.a
			IMPORT	initGlobals						; SoundMgrPriv.c
			IMPORT	InitIntHandler					; InterruptHandlers.a
		IF IopADB | hasIopScc | hasIopSwim THEN
			IMPORT	InitIOPMgr						; IOPMgr.a
		ENDIF
			IMPORT	InitMemMgr						; MemoryMgr.a
			IMPORT	InitMemoryDispatch				; HWPriv.a
			IMPORT	InitMemVect						; MemoryMgr.a
			IMPORT	InitMMU							; MMUTables.a
			IMPORT	InitMMUGlobals					; MMU.a
			IMPORT	InitMMUTrap						; MMU.a
			IMPORT	InitOverPatch					; Overpatch.a
			IMPORT	InitPmgrVars					; PowerManager.a
			IMPORT	InitQueue						; Queue.a
			IMPORT	InitReliability					; SysUtil.a
			IMPORT	InitRomVectors					; VectorTableInit.a
			IMPORT	InitRSRCMgr						; ResourceMgr.a
			IMPORT	InitSCSIHW						; SCSIMgrInit.a
			IMPORT	InitSCSIMgr						; SCSIMgrInit.a
			IMPORT	InitSDTbl						; SlotInterrupts.a
			IMPORT	InitSndDispatch					; SoundDispatch.a
			IMPORT	InitSndHW						; SndPrimitives.a
			IMPORT	InitSndNoRAM					; SndPrimitives.a
			IMPORT	InitTimeMgr						; TimeMgr.a
			IMPORT	InitVBLQs						; VerticalRetraceMgr.a
			IMPORT	InitVIAs						; Universal.a
		IF has040MMU THEN							;														<SM91>
			IMPORT	InstallFPSP						; FPEmulation.a
		ENDIF										;														<SM91>
			IMPORT	InstallPrivTrap					; FPPrivTrap.a
			IMPORT	InstallSoundIntHandler			; SoundInterrupts.c
			IMPORT	JumpIntoROM						; Universal.a
		IF hasPwrControls THEN
			IMPORT	LCDScreenChk					; PowerMgr.a
		ENDIF
			IMPORT 	MARIOBOOTSOUND					; BootBeep.a
			IMPORT	MDJGNEFILTER					; ?														<SM22>
			IMPORT	MMUCleanupFor8Mb				; MMU.a
			IMPORT	NMGNEFilter						; NotificationMgr.c
			IMPORT	NMInit							; NotificationMgr.c
		IF hasPwrControls THEN
			IMPORT	PortableCheck					; PowerMgr.a
			IMPORT	PowerDownAll					; PowerMgr.a											<SM84>
		ENDIF
			IMPORT	ReadXPRam						; Clock.a
		IF hasIopScc THEN
			IMPORT	SCCIOPByPass					; IOPMgr.a
			IMPORT	SCCIOPHwInit					; IOPMgr.a
		ENDIF
			IMPORT	SCSIDiskMode					; SCSIDiskMode.a										<SM16><SM68>
			IMPORT	SetupDockBases					; DockingMgr.a
			IMPORT	StartSDeclMgr					; SlotMgrInit.a
			IMPORT	StartTest1						; USTStartup.a
			IMPORT	SysErrInit						; StartErr.a
			IMPORT	SwitchMMU						; MMU.a
			IMPORT	TEGlobalInit					; TextEditInit.a
			IMPORT	ValidatePRAM					; Clock.a

			IMPORT	INSTALLBASSCOMMON				; BassExtensions.a <SM112>
			IMPORT	FORCEINITFONTSCALL				; BassExtensions.a <SM112>

			IMPORT	GetCPUIDReg						; Universal.a
			IMPORT	InitSys7Toolbox					; StartBoot.a
			IMPORT	Ck4LimitPRAMClear				; StartSearch.a
			
		IF hasAsyncSCSI THEN
			IMPORT	ISITT
			IMPORT	INITSCSIBOOT
		ENDIF  


MyROM		MAIN	Export

			EXPORT	AddVidDevice
			EXPORT	BootRetry
			EXPORT	Critical
			EXPORT	DispOff
			EXPORT	InitDefGamma
			EXPORT	InitSCC
			EXPORT	OpensDrvr
			EXPORT	PMSPSwOS
			EXPORT	RomLoc
			EXPORT	StartBoot
			EXPORT	StartInit1
			EXPORT	WDCBSwOS
			EXPORT	TCOff
			EXPORT	SetUpTimeK						; <SM142>

			EXPORT	DynamicBoxFlag

*************************************************************************************************
*																								*
*									S T A R T   O F   R O M										*
*																								*
*************************************************************************************************

			DC.L	numTbTrap+numOsTrap-1			; [ 0] number of traps for postlinker (HiRam stuffs checksum here)
StartPC		DC.L	ResetEntry-BaseOfRom			; [ 4] RESET vector
ROMVersion	DC.B	Machine							; [ 8] machine number
													;		NOTE: until Appletalk changes the way it checks for existence of
													;		TimeDBRA, ROM version numbers must be between $76 and $7F inclusive
			DC.B	$7D								; [ 9] Universal, Mac II class, 32 bit machines

;---------------------------------------------------
; ROM vectors & entry points
;---------------------------------------------------

StBoot		JMP 	StartBoot						; [ A] jump to start code for a restart
BadDisk		JMP 	StartBoot						; [ E] eject disk, and reboot
			DC.W	ROMRelease						; [12] ROM release version
PatchFlags	DC.B	0								; [14] ROM overpatch basis for Horror (unused in SuperMario)
			DC.B	0								;¥[15] UNUSED
			DC.L	ForeignOS-BaseOfRom				; [16] offset to foreign OS vector table
RomRsrc		DC.L	0								; [1A] ROMStart -> HiRam -> offset to ROM resource header
Eject		JMP 	GoofyDoEject 					; [1E] jump to utility to eject and notify Bruce
DispOff		DC.L	DispTable-BaseOfRom				; [22] offset to the dispatch table
Critical	JMP		CritErr							; [26] jump to critical error handler
ResetEntry	JMP 	StartBoot						; [2A] RESET entry point
RomLoc		DC.B	0								; [2E] ROM Loc (Bit 0: In Ram, Bit 1: In Emulator)
			DC.B	0								;¥[2F] UNUSED
			DC.L	0								; [30] ROM checksum byte 0
			DC.L	0								; [34] ROM checksum byte 1
			DC.L	0								; [38] ROM checksum byte 2
			DC.L	0								; [3C] ROM checksum byte 3
			DC.L	1								; [40] HiRam -> Size of ROM in bytes						<SM132>
			DC.L	EraseMyIcon-BaseOfRom			; [44] erase the happy mac
			DC.L	InitSys7Toolbox-BaseOfRom		; [48] Offset to Sys 7 Toolbox init code. (used by Boot3.a & Gibbly)
			DC.W	SubRelease						; [4C] version number of SuperMario based ROMs				<SM132>

;--- End of official ROM header --------------------


;---------------------------------------------------
;	Foreign OS table - exports offsets of interesting ROM stuff to other OS's like Aux or Pink
;---------------------------------------------------

ForeignOS	DC.L	InitDispatcher-BaseOfRom		; [4E] initializes A-trap dispatch tables
			DC.L	EMT1010-BaseOfRom				; [52] A-trap dispatcher
			DC.L	BadTrap-BaseOfRom				; [56] handler for unimplemented traps
			DC.L	StartSDeclMgr-BaseOfRom			; [5A] initializes the Slot Manager
			DC.L	InitMemVect-BaseOfRom			; [5E] initializes the Memory Manager jump tables
			DC.L	SwitchMMU-BaseOfRom				; [62] MMU switch code
			DC.L	InitRomVectors-BaseOfROM		; [66]


;---------------------------------------------------

GOOFYDoEject
			BRA.L	DoEject							; branch island to eject code



*************************************************************************************************
*																								*
*						R E S E T / R E B O O T   E N T R Y   P O I N T							*
*																								*
*************************************************************************************************

TCOff		dc.l	0								; for turning off MMU below

Start
StartBoot	MOVE	#$2700,SR						; Disable processor interrupts.

	IF NOT ROMinRAM THEN							; 														<SM52>
			sub.l	d0,d0							; D0 = 0
			bset	#CACR_DE_040,d0					; set Data Cache Enable bit on 040s						<T22>
			movec	d0,CACR							; attempt to enable data cache (temporarily)
			movec	CACR,d0							; check and see if it's still there
			btst	#CACR_DE_040,d0					; see if the bit exists in CACR							<T22>
			beq.s	@not040							; IF we're on a 68040 THEN
			
			MACHINE	MC68040							;	need this for the MOVEC D0,TC below

			cinva	bc								;	make sure caches are invalidated
			sub.l	d0,d0							;	clear d0
			movec	d0,CACR							;	disable both instruction and data caches
			movec	d0,TC							;	make sure that the MMU is disabled
			move.l	#nuBusTTxlat,D0					;	get value to translate upper nuBus space			<T18>
			movec	d0,DTT0							;	use serialized writes on this space 				<T18>
			move.l	#ioNuBusTTxlat,D0				;	get value to translate i/o and nuBus space			<T18>
			movec	d0,DTT1							;	use serialized writes on this space 				<T18>
			bra.s	@not030							;	step around the rest of the 020/030 cache/tc stuff

			MACHINE	MC68030							;	set it back to what works for 020/030
@not040												; ELSE
			move.l	#(1<<CACR_WA_030),d0			;	CACR value w/WA bit for 030
			movec	d0,CACR							;	disable both instruction & data caches
			movec	CACR,d0							;	hmmm, maybe we are an 030
			tst.l	d0								;	see if WA bit is still on
			beq.s	@not030							;	IF we are an 030 processor
			lea		TCOff,a0						;     point to TC value that disabled the MMU
			pmove	(a0),tc							;     turn off MMU
													;	ENDIF
@not030

		  IF	forRomulator THEN
			TestInRam	A0
			bne.s	@dontReset						; don't reset if running in RAM
		  ENDIF

;	NOTE: The MMU must be disabled before doing a RESET if the MMU tables are in RAM, especially
;	on machines with Overlay bits.  RESET will cause the hardware to enter Overlay Mode, and RAM
;	will go away, and ROM data will be returned instead, so the MMU will not be able to access
;	the translation tables.

			RESET									; ***** Reset The World *****
@dontReset
	ENDIF											; 														<SM52>

; <60>, check what WakeUp does, does it return here again after changing clock ?




*************************************************************************************************
*																								*
*						H A R D W A R E   I N I T I A L I Z A T I O N							*
*																								*
*************************************************************************************************
			
			BSR6	JumpIntoROM						; init the hardware
	
		IF hasPwrControls THEN						; If we're on a portable,
			BigBSR6	PortableCheck					; check to see if we are coming out of sleep
		ENDIF
			BRA.L	StartTest1						; run new universal diagnostics
StartInit1											; Jumped to from StartTest1. <C11>

;-----
;	here, after running the diagnostics, we have:
;
;		a6 ->	memory chunk table near top of highest RAM bank found by the diagnostics.
;		  		Each table entry is a pair of longwords giving the physical start address
;				and size of a RAM bank.  The table is terminated by a single longword of
;				$FFFFFFFF.  The end of the highest bank is 3 longwords after the terminator.
;
;				For instance, a two bank Mac 2 with 4 meg in bank A and 1 Meg in Bank B:
;
;					--- top of bank B ---
;						<filler 3>	- last longword of Bank B
;						<filler 2>	- next to last longword
;						<filler 1>	- next to last longword
;						$FFFFFFFF	- RAM chunk table terminator
;						$00100000	- size bank B
;						$04000000	- physical address bank B
;						$00400000	- size bank A
;					a6->$00000000	- physical address Bank A
;
;		a5 ->	top of useable memory, given RAM disk.  This is only used on contiguous
;				memory systems that support RAM disks, such as the Portable.
;
;		sp ->	a little bit (32k) above the bottom of the lowest bank of RAM found.
;
;		vbr ->	(020/30/.. only) exception vectors set up by the diagnostics at the bottom
;				of the lowest bank found.
;
;		On 68000 machines, exception vectors set up by the diagnostics are in RAM at address zero.
;-----

			WITH	StartGlobals

			moveq.l	#0,d2							; no hint about configuration
getHInfo	move.l	a6,-(sp)						; save regs												<SM44>
			BSR6	GetHardwareInfo					; figure out what we are running on						<SM52>

			movem.l	d0-d1/d7,-(sp)					; save universal regs									<SM44>	
			BSR6	GetExtHardwareInfo				; Get extended universal information
				
			move.l	12(sp),a6						; get pointer to bootglobs
			movem.l	d0-d1/d3-d4,sgScratch(a6)		; save extended info in scratch space in BootGlobs
			movem.l	(sp)+,d0-d1/d7					; restore valid and ext feature flags #0-31

;-----
;	Here, after running GetHardwareInfo we have:
;
;  		a0 - Pointer to table of base addresses
;		a1 - Pointer to ProductInfo record for this machine
;		d0 - Flags indicating which base addresses are valid
;		d1 - Flags indicating which external features are valid
;		d2 - Bits 31..16, hwCfgFlags info (possibly unknown)
;		d2 - Bits 15..8, BoxFlag info (possibly unknown)
;		d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
;-----

			BSR6	InitVIAs,a2						; initialize the VIAs and RBV

			BSR.L	ValidatePRAM					; make sure PRAM is checked for reasonable values

			move.l	(sp)+,a6						; restore regs											<SM44>

;----------------------------------------------------------------
; Get logical: set up RAM, address translation tables
;----------------------------------------------------------------

			bsr		ConfigureRam					; set up RAM, move sp to middle of 1st bank

;----------------------------------------------------------------
; D7 <- CPU type in low word, logic board type in hi word
;----------------------------------------------------------------
			BSR		WhichCPU						; get CPU type in low word of d7
			bsr		WhichBoard						; get logic board type in hi word of d7

			btst.l	#hwCbMMU+16,d2					; HwCfgFlags in high word of d2
			bne.s	@hasMMU							;  yes, InitMMU
													;  no,  InitNonMMU
			bsr		InitNonMMU						; init a4,a5,a6 for non MMU based machines
			bra.s	@done

@hasMMU		bsr.l	InitMMU							; generate MMU tables, enable MMU						<SM15>
													; returns a4 -> BootGlobs
			
			move.l	sgTotalRAM(a4),a6				; get top of memory
			move.l	a4,a5							; get ptr to BootGlobs
			add.l	sgAllocOff(a4),a5				; top useable memory = ptr + allocation offset
@done
	

;-----
; Now that we have low memory, set up some globals.  We may nuke some of them later if its
; a cold boot, but we will re-set them up.
;
;	At this point:
;		'Universal ROM' registers
;  			a0 - Pointer to table of base addresses in physical space
;			a1 - Pointer to ProductInfo record for this machine in physical space
;			d0 - Flags indicating which base addresses are valid
;			d1 - Flags indicating which external features are valid
;			d2 - Bits 15..8, BoxFlag info (possibly unknown)
;			d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
;			d7 - bits 31-16: logic board type
;			d7 - bits 15-0: cpu type (0 = 68000, 1 = 68010, etc)
;
;		a4  - points to BootGlobs in logical space
;		a5	- top of useable memory
;		a6	- top of memory
;		sp	- in the middle of the useable logical space
;
;-----

			MOVEM.L	sgScratch(A4),D3-D6				; get the extended Universal info						<SM82>
			ENDWITH									; {StartGlobals}

			MOVEM.L	D0-D6/A0-A1,-(SP)				; save all Universal info								<SM82>

		IF forRomulator THEN						;														<T5>
			TestInRam	a0							; are we in RAM?
			beq.s	@notInRam						; IF we are in RAM THEN
			LEA		$300,A0							;	use $300 so we don't blow away nub vars
			bra.s	@cont							; 	continue
@notInRam											;
		ENDIF										; ELSE
			LEA		SysCom,A0						; 	A0 <- pointer to start of system globals
@cont												; ENDIF
			LEA		HeapStart,A1					; A1 <- pointer to end of system globals.
			BSR		FillWithOnes					; Fill system globals with ones.

			BSR		InitRomVectors					; initialize ROM vectorization

			MOVEM.L	(SP)+,D0-D6/A0-A1				; restore Universal info								<SM82>

			swap	d2								; get high word for flags
			move.w	d2,HwCfgFlags					; store in the low mem global
			swap	d2								; restore d2 to original value

			move.l	d0,AddrMapFlags					; save Universal info
			move.l	d1,UnivROMFlags					;
			move.l	a1,UnivInfoPtr					;
			move.l	d3,AddrMapFlags1				;  and extended universal info
			move.l	d4,UnivROMFlags1				;
			move.l	d5,AddrMapFlags2				;
			move.l	d6,UnivROMFlags2				;

			MOVE.B	D7,CpuFlag						; save type of CPU we have
			swap	d7								;

			bsr		DynamicBoxFlag					; Calculate the Boxflag based on Family type and CPU speed <mc2>
			
@StoreBox	move.b	d7,BoxFlag						; ... and save it in lomem

			move.l	a4,BootGlobPtr					; save the pointer to the boot globals (near top of RAM)
			MOVE.L	A5,BufPtr						; save the top of useable memory
			MOVE.L	A6,MemTop						;  and the top of available memory

			; Here, we check to see if a special bit is set on PRAM, which tells us							<SM99> rb, start
			; that the user want's his ROM to run from RAM for a slightly faster machine.
			; We copy the ROM image into RAM and then re-initialize vectorization with the new RAM/ROM.
	
			IMPORT	PramIO
			
			MOVEM.L	D0-D6/A0-A4,-(SP)				; save Universal info
			CLR.W	-(SP)							; make buffer space in stack for PRAM data
			MOVE.L	SP,A3							; set buffer pointer
			MOVE.L	#(0<<31)|\						; read PRAM command
					 (1<<16)|\						; 1 byte please
					 (11<<0),D3						; from address X
			BSR.L	PramIO							; read PRAM
			MOVE.W	(SP)+,D0						; get the byte read from PRAM
			ANDI.W	#$0100,D0						; let's see if bit 1 was set in our byte
			BEQ.W	NoROMinRAM						; if bit is clear, don't use RAM for the ROM <SM99>
			
			LEA		BaseOfRom,A0					; set source address
			MOVE.L	A0,ROMBase						; save in ROMBase since it's not setup yet
			MOVE.L	$40(A0),D3						; get the ROM size in D3
			SUBA.L	D3,A5							; Subtract the ROM size from BufPtr
			MOVE.L	A5,D0							; let's make sure A5 is aligned
			ANDI.L	#$0000000F,D0					; mask up to 15 bytes of mis-alignement
			SUBA.L	D0,A5							; and adjust A5 for 16 byte alignment
			MOVE.L	A5,BufPtr						; and set the new BufPtr
			MOVE.L	A5,A1							; set Destination address
			
			MOVE.L	D3,D0							; set count
			MOVEQ.L	#16,D2							; set copy amount per loop (16 for non 040)
			CMPI.B	#cpu68040,CPUFlag				; are we in an 040 ?
			BNE.S	@CopyLongs						; if not, then copy longs only
			MOVEQ.L	#32,D2							; set copy amount per loop
			BRA.S	@Copy16							; do the copy thing, based on BlockMove040
			NOP										; no warnings please
			
			ALIGN	16								; align with a cache line
			MACHINE MC68040							; for move 16
@Copy16
			MOVE16	(A0)+,(A1)+						; copy 16 bytes
			SUB.L	D2,D0							; decrement our count by 32 bytes
			MOVE16	(A0)+,(A1)+						; copy another 16...
			BHI.S	@Copy16							; and keep copying until we have 2 Meg
			
@JumpIntoRAM
			LEA		InRAM,A0						; get our address in RAM (almost)
			MOVE.L	ROMBase,D5						; save old ROMBase in D5								<SM104> rb
			SUBA.L	ROMBase,A0						; get rid of the ROM offset
			MOVE.L	BufPtr,A5						; get BufPtr (ROMBase soon) in a5
			MOVE.L	A5,ROMBase						; set the new ROM base
			ADDA.L	A0,A5							; add offset to InRAM routine
			JMP		(A5)							; and go there !
			NOP										; fill me in
			
@CopyLongs
			MOVE.L	(A0)+,(A1)+						; copy 4 bytes
			MOVE.L	(A0)+,(A1)+						; copy 8 bytes
			MOVE.L	(A0)+,(A1)+						; copy 12 bytes
			MOVE.L	(A0)+,(A1)+						; copy 16 bytes
			SUB.L	D2,D0							; decrement our count by 16 bytes
			BHI.S	@CopyLongs						; and copy more if nessesary
			BRA.S	@JumpIntoRAM					; now jump into RAM
			NOP										; just for the fun of it.
			
			ALIGN	16
			
InRAM
			BSR		InitROMVectors					; re - initialize vectorization with new ROM addr
			; Now that the ROM vectors have been re-initialized from RAM, the actual table entries still	<SM104> rb, start
			; point to ROM since these were created at compile time.  So now we need to adjust every entry
			; in the RAM copy of the tables so that it points to its RAM equivalent.  From then on
			; InitROMVectors can be called and the RAM table entries will be used, as expected.
			
			MOVE.L	#$2010,D0						; get start address for ROM vector adjustments			
			SUB.L	ROMBase,D5						; adjust our saved ROMBase, D5 is now the difference
@WalkList	
			MOVE.L	D0,A0							; get vector address in a0
			MOVE.L	(A0),D1							; get the table address
			CMPI.L	#-1,D1							; is it an empty table ?
			BEQ.S	@NextTable						; if so, try the next table
			
			MOVE.L	D1,A1							; get the table address in a1
			MOVE.L	(A1),A2							; get decription table in a2
			MOVE.L	8(A2),D3						; get vector count for this table in D3
			
@AdjustEntry
			SUB.L	D5,(A1)+						; adjust this entry so it points in the RAM copy of ROM
			DBRA	D3,@AdjustEntry					; fix all entries in this table
			
@NextTable	
			ADDI.L	#4,D0							; add offset to next vector address
			CMPI.L	#$2104,D0						; have we reached the current limit ?
			BNE.S	@WalkList						; if not the limit, keep looking
			
			SUB.L	D5,UnivInfoPtr					; adjust the info record so int handlers are in RAM		<SM108> rb
			
NoROMinRAM											;														<SM104> rb, end
			MOVEM.L	(SP)+,D0-D6/A0-A4				; restore Universal info
													; DONE, WE ARE RUNNING FROM A RAM COPY OF ROM			<SM99> rb, end
			move.l	UnivInfoPtr,a1					; reload a1 in case the info record was adjusted in RAM	<SM108> rb
			
			bsr		SetupHWBases					; setup the hardware base address low mems

			BSR		InitSCC							; init the SCC

			move.w	d2,-(sp)						; save D2 around this call								<T28>
			BSR		InitIWM
			move.w	(sp)+,d2						; restore D2											<T28>

		IF NOT hasAsyncSCSI THEN	; we do HW init later with new SCSI Manager
			bsr.l	InitSCSIHw						;
		ENDIF
		
			BSR.L	InitSndHW						; go initialize the sound hardware

			bsr.l	InitMMUGlobals					; set up MMU globals

			BSR6	 SysErrInit						; Init exception vectors.
			clr.l	DockingGlobals					; flag for EnableExtCache to know traps don't exist	<H15>
			
	IF has040MMU THEN								;														<SM54><SM91> rb
			cmpi.b	#cpu68040,CPUFlag				; check if we're running on an 040/050					<T12>
			bne.s	@notAn040						; IF we are running on an 040/050 THEN					<T12>
			BSR.L	InstallFPSP						;    Initialize 040/050 FP emulation package			<T12>
@notAn040											; ENDIF													<T12>
	ENDIF											;														<SM54><SM91> rb


;----------------------------------------------------------------
; Enable Caches, if any.
;----------------------------------------------------------------

; turn on Bursting for Instruction and Data cache before TimeDBRA and TimeSCCDB

	IF forRomulator THEN
			Moveq.l	#$0,D0							; Set up to disable the caches if weÕre debugging.
	ELSE
			cmp.b	#cpu68040,CpuFlag				; check if we're on an 040
			bne.s	@not040							; NO  ... enable 020/030 cache(s)

			move.l	#(1<<CACR_IE_040),d0			; YES ... turn on IE		  
			Ori.l	#(1<<CACR_DE_040),D0			; and the DE.
			bra.s	@EEC							; enable any external caches (?)
@not040
			MOVE.L	#(1<<CACR_EI_020_030|\			; WA=1, DBE=1, CD=1, ED=1, IBE=1, CI=1, EI=1
					  1<<CACR_CI_020_030|\			;
					  1<<CACR_IBE_030|\				;
					  1<<CACR_ED_030|\				;
					  1<<CACR_CD_030|\				;
					  1<<CACR_DBE_030|\				;
					  1<<CACR_WA_030),D0			;
@EEC												; nothing to do with Europe or Eric Clapton
	ENDIF		
			Movec	D0,CACR							; set up the CACR as desired from above
			BSR.L	EnableExtCache					; enable external cache

			BSR.L	DisableIntSources				; mask all interrupts
			BSR		SetUpTimeK						; Initialize TimeDBRA and TimeSCCDB.

			BSR		InitHiMemGlobals				; set up high memory.  If > 8 meg RAM and 24-bit OS,
													; BufPtr clipped at 8 meg and stack at 4 meg


*************************************************************************************************
*																								*
*										B O O T   R E T R Y										*
*																								*
*	Come back here if we fail to mount a volume, get a System file, or get memory.				*
*																								*
*	The only variables we don't reset at this time are:											*
*																								*
*		BootMask - needed to avoid continually trying to boot off a hard disk with bad blocks	*
*		MemTop, PWMBuf1, PWMBuf2, PWMValue, SoundBase, BufPtr									*
*		CPUFlag, TimeDBRA, TimeSCCDB, TimeSCSIDB												*
*		all Universal variables (i.e., UnivInfoPtr, UnivROMFlags, AddrMapFlags, etc)			*
*																								*
*************************************************************************************************

BootRetry	MOVE	#$2700,SR						; disable interrupts

;	initialize enough to get the Memory Manager going for InitIntHandler

			BSR		InitGlobalVars					; initialize a bunch of global variables
			BSR.L	DisableIntSources				; mask all interrupts

			BSR.L	InitDispatcher					; initialize the trap dispatcher
			BSR.L	InitMMUTrap						; set up SwapMMUMode trap
			BSR.L	InitMemMgr						; initialize the memory manager
			BSR		SetUpSysAppZone					; setup the system/application heap zone

; 	Move Stack to halfway through RAM and set new system heap limit.

			BSR		CompBootStack					; A0 <- the location of the stack at boot time
			MOVE.L	A0,SP							; Set the stack pointer there
			SUBA.W	#BootStackSize,A0				; Give ourselves some stack space

			BSET.B	#MMStartMode,MMFlags			; set for 32 bit system heap
			_SetApplLimit							; Don't let the System Heap crash our stack

			BSR.L	InitMemoryDispatch				; go set up the MemoryDispatch globals

;	initialize the expanded low-mem area (really in the system heap)

			WITH	ExpandMemRec					;														<SM40>
			Move.l	#emRecSize,d0					; size of ext to old low-mem							<SM40>
			_NewPtr	sys,clear						; get a blob											<SM40>
			Move.l	a0,ExpandMem					; stuff global ptr										<SM40>
			Move.w	#emCurVersion,(a0)+				; version number										<SM40>
			Move.l	#emRecSize,(a0)					; size													<SM40>
			ENDWITH									;														<SM40>

			BSR.L	InitIntHandler					; initialize interrupt vectors and dispatch tables
			BSR.L	InstallPrivTrap					; setup FPPriv if there's an FPU						<T15>

			BSR.L	InitPmgrVars					; initialize Power Manager variables if on a portable	<T10>
													; (otherwise disable all of its traps)

			BSR		CheckForEgretOrCuda				; Do we have an Egret/Caboose/Cuda?						<mc2>
			BNE.S	@EInitDone						; -> Nope, don't be callin' shit
			BSR.L	InitEgretOrCuda					; Initialize Egret or Cuda Manager
@EInitDone


*************************************************************************************************
*																								*
*							W E L C O M E   T O   M A C I N T O S H								*
*																								*
*	At this point, all the machine/feature specific stuff should be setup, so we should be		*
*	able to take off as if we were a generic Macintosh.											*
*																								*
*************************************************************************************************

			
			BSR		InitSwitcherTable				; initialize Switcher's table (do we still need this?)

			BSR		GetPRAM							; get 20 bytes PRAM, and TIME
			BSR		SetPRAM32						; Always set PRAM to 32bit								<SM50><SM62>
			BSR.L	InitRSRCMgr						; initialize the Resource Manager
			BSR.L	NMInit							; Initialize the Notification Manager
			BSR.L	InitTimeMgr						; Initialize the Time Manager
		
			CLR.W	-(SP)							; pass the INIT message to ShutDown
			_ShutDown								;  to initialize the queue

			BSR		InitSlots						; inits slot cards, grays the screen(s)

			BSR.L	InitDTQueue						; initialize the Deferred Task Manager Queue

			BSR.L	EnableOneSecInts				; allow the clock interrupts
			BSR.L	Enable60HzInts					; allow vbl interrupts

;----------------------------------------------------------------
; Enable processor interrupts, after which we can start wanging real hw
;----------------------------------------------------------------

			MOVE	#$2000,SR						; supervisor state, interrupts on

;------------------------------------------------------------------------									<SM39>
; Gestalt must now be initialized before IO drivers															<SM39>																<SM39> RLM
;------------------------------------------------------------------------									<SM39>

			BSR.L	initGestalt						; initialize Gestalt									<SM39>

			moveq	#10,D0
			_NewHandle	,Sys,Clear					; Get space for a Heap utilities list
			move.l	A0,D0							; Did we get it?
			beq.s	@noHU							; -> Nope
			move.l	D0,$1E0C						; Stuff it in the magic location
@noHU
			
			Cmpi.b	#cpu68040,CPUFlag				; Are we less than an 040?								<T7><SM9>
			Blo.s	@no040BM						; Yes? Then use original BlockMove.						<T7><SM9>
			Move.w	#$A02E,D0						; BlockMove trap.										<T7><SM9>
			BigLea	BlockMove68040,A0				; New routine.											<T7><SM9>
			_SetTrapAddress							; Set new routine.										<T7><SM9>
@no040BM

;ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	<SM101> SAM
; Install Code Fragment Mangaer (GoNative)								<tcn>
;ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ

			MOVE.L	#gestaltSysArchitecture,d0		; Are we running on a PowerPC machine?					<SM101> SAM
			_Gestalt
			BNE.S	@NoPower						; Error, assume 68k
			CMP.W	#gestaltPowerPC,A0				; PowerPC?
			BNE.S	@NoPower						; -> Nope, assume 68k
			
		CASE	ON
		IMPORT 	GoNative
			BSR.L	GoNative						; Load all those NCODs!
		CASE	OFF
			BPL.S	@noPower						; -> No errors.  Keep booting							<SM132> SAM
			
			MOVE.W	#dsGNLoadFail,D0				; Fatal GoNative load error.							
			_SysError								; Put up a dialog and die.
@noPower

;----------------------------------------------------------------
; Install Drivers (Disk, Sound, Video).
;----------------------------------------------------------------

			LEA 	DrvQHdr, A1 					; Initialize the drive queue.
			BSR.L 	InitQueue

			BSR		InitIOPStuff					;
			BSR 	InitDeviceMgr					; Init unit I/O table and install the drivers.
			BSR		LoadDrivers						; load the standard drivers

			BSR.L	InitSCSIMgr						; Init old and new SCSI Mgrs

			BSR.L	INSTALLBASSCOMMON				; Init Bass before anyone calls _InitFonts (like _InitGraf) <SM112>
			BSR.L	FORCEINITFONTSCALL				; More Bass init stuff										<SM112>

			BSR.L	InitCrsrDev						; initialize Cursor globals								<H9>
													; (InitCrsrDev must preceed InitADB)
			BSR.L	InitADB							; initialize ADB interface

			BSR		InitCrsrMgr						; Initialize cursor variables

;----------------------------------------------------------------
; Initialize Reliability Manager
;----------------------------------------------------------------

			BSR.L	InitReliability					; initialize the Reliability Manager

			BSR		CheckForEgretOrCuda				; call check routine									<T2>
			BNE.S	@NoEgret						; Egret not installed
			BSR.L	EgretDFACandPDM					; install additional Egret features						<SM16>
@NoEgret
			BSR		CheckForResetPRAM				; see if PRAM needs to be nuked

			BSR.L	TEGlobalInit					; initialize TextEdit vectors

;----------------------------------------------------------------
; Create a temporary application heap.  Load boot block buffer
; ptr into A6 and phoney A5 global world.  Note these are based
; on an SP pointing to an EMPTY stack, whose location was earlier
; computed to be at (MemTop/2 - BootGlobalsSize).
;
; Historically, there was a _SetAppBase here after the system zone had been grown during
; initialization so far.  We continue with the coincident zones, but run the _SetAppBase anyway
; for the sake of its internal side-effects.  After the call, ApplZone, HeapEnd, and HiHeapMark
; must be reset.  ApplLimit is set to BufPtr-DefltStack, which is fine for boot time.
;----------------------------------------------------------------

			MOVE.L	SysZone,A0						; Point to System Heap
			MOVE.L	bkLim(A0),A0					; Point to end of System Heap
			ADDA.L	#MinSysExtra,A0					; Make sure we have enough System Heap space
			_SetAppBase								; Set up the start of the application heap
			MOVEA.L	SysZone,A0						; the one true zone
			MOVE.L	A0,TheZone						; We still want the System Heap to be the default
			MOVE.L	A0,ApplZone						; revert to coincident zones
			MOVE.L	bkLim(A0),HeapEnd				; end of dynamic sys/appl zone
			LEA		BootGlobalsSize(SP), A6			; boot blocks load pt
			LEA 	QDBootGlobalsSize(SP),A5		; leaving room for globals

			BSR.L	EnableSlotInts					; enable NuBus slot interrupts

			BSR.L	InitFasterInvals				; init the expandmem variable for WindowMgr

		IF hasPwrControls THEN
			BSR.L	PowerDownAll					; power down all peripheral subsystems
		ENDIF
	
			BSR		DrawBeepScreen					; Horst BeepmanhÕs patented gray screen
			
; On machines with Civic, check to see if we want to boot off the composite out      						<SM63>

			TestFor	CivicExists
			Beq.s	@NoCivic						; don't do it for Non-Civic Based cpu's
			bsr		CheckForTV						; see if we need to set the "Drive CompOut Flag"
@NoCivic
			
			MOVE.L	#WmStConst,WarmStart			; write warm start constant to indicate warm start

			MOVEA.L	BootGlobPtr,A0							; point to bootGlobals
			move.l	#WmStConst,StartGlobals.sgWarmStart(A0)	; flag warm start in a
															; place where StarTest can see it w/o an MMU

;----------------------------------------------------------------
; Initialize the Sound Manager
;----------------------------------------------------------------

			MOVEM.L	A0-A2/A6/D0-D2,-(SP)			; save our important Address

			case	obj
			import	InitSoundMgr
			bsr.l	InitSoundMgr
			case	off

			MOVEM.L	(SP)+,A0-A2/A6/D0-D2			; restore our important Address


;----------------------------------------------------------------
; Initialize the File System.
;----------------------------------------------------------------

			MOVE	#40,D0							; Inital number of file control blocks
			_InitFS

;----------------------------------------------------------------
; <65>, Other Terror changes...
;----------------------------------------------------------------

			BSR.L	SetupDockBases					; initialize docking bar base addresses					<H3><SM16>
*			BSR.L	SCSIDiskMode					; check if we should be in SCSI Disk Mode				<SM16>

		IF hasAsyncSCSI THEN						; <SM162> \/  
			BSR.L	ISITT							; check if we're running SCSI 4.3
			TST.B	D0								; are we?
			BEQ.S	@noAsyncSCSI					; -> no, don't don't initialize for new
													; 	 style boot.
			BSR.L	INITSCSIBOOT					; allocate some memory for SCSI booting
													; and load third party SIMs (SCSI Interface
													; modules
@noAsyncSCSI
			ENDIF									; <SM162> /\   


*************************************************************************************************
*																								*
*				Everything's ready to go, so go look for a disk to boot from					*
*																								*
*************************************************************************************************

			BRA		BootMe								; Exit Stage Right



*************************************************************************************************
*																								*
*						M I S C E L L A N E O U S   U T I L I T I E S							*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	WhichCPU
;
; Inputs:	none
;
; Outputs:	D7.L-	0, 1, 2, 3, or 4 for 68000, 68010, 68020, 68030, 68040 respectively
;
;			020 - icache flushed & enabled
;			030 - both caches flushed, icache enabled, dcache set up for write allocate
;			      but not enabled
;			040 - both caches invalidated, icache enabled.
;
; Trashes:	none
;
; Function:	determines which sibling of the 68K is running by looking at exception stack
;			frames, addressing modes, and at instruction/data cache enables
;
; Technical details:
;
;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)
;			+------------------------------------------------+
;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |
;			+------------------------------------------------+
;			  31                  4    3      2     1     0
;
;				C   =  Clear Cache
;				CE  =  Clear Entry
;				F   =  Freeze Cache
;				E   =  Enable (Inst.) Cache
;
;
;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)
;			+------------------------------------------------------------------------------------+
;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |
;			+------------------------------------------------------------------------------------+
;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0
;
;				WA  =	Write Allocate
;				DBE =	Data Burst Allocate
;				CD	=	Clear Data Cache
;				CED	=	Clear Entry in Data Cache
;				FD	=	Freeze Data Cache
;				ED	=	Enable Data Cache
;				IBE	=	Instruction Burst Enable
;				CI	=	Clear Instruction Cache
;				CEI	=	Clear Entry in Instruction Cache
;				FI	=	Freeze Instruction Cache
;				EI	=	Enable Instruction Cache
;
;
;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)
;			+-------------------------------------+
;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |
;			+-------------------------------------+
;			   31    30     16    15    14     0
;
;				DE	=	Enable Data Cache
;				IE	=	Enable Instruction Cache
;
;
;			The assumption made here (and other places where the CACR is manipulated) are
;			that if the bits specified in the CACRs above specified as having a value of
;			zero are written, those bits are ignored. All bits documented in the CACR as
;			zero are ALWAYS read as zeroes.  Given the placement of the various bits,
;			setting a bit that is valid in one of the MC68xxx processors that is undefined
;			(reserved, or zero) on others will be the method of CPU detection.
;________________________________________________________________________________________

WhichCPU
			MACHINE	MC68020

			moveq.l	#2,d7							; setup index to see if index scaling works
			jmp		@CheckIndexScale-2(d7.w*2)		; decide if scaling works

@CheckIndexScale
			bra.s	@NoIndexScale					; 68000/68010 don't have index scaling

@HasIndexScale										; 68020/68030/68040 do have index scaling
			sub.l	d7,d7							; D7 = 0 (testing for 040)

			bset	#CACR_DE_040,d7					; set DE (data cache enable) in CACR
			movec	d7,CACR							; enable data cache
			movec	CACR,d7							; IF CACR != 0 THEN we're on an 040
			bclr	#CACR_DE_040,d7					; see if the bit exists in CACR
			movec	d7,CACR							; put it back in cache reg
			beq.s	@notAn040						; NO  ... check for 020/030

			MACHINE	MC68040							; YES ... needed to execute a 040 CINVA inst.

			cinva	bc								; invalidate both caches, dont push data from d-cache
													; NOTE - I-cache is still enabled here
			moveq	#cpu68040,d7					; return that we're running on an 040
			rts

			MACHINE	MC68020
@notAn040
			move.w	#(1<<CACR_EI_020_030|\			; set EI, (enable inst. cache)
					  1<<CACR_CI_020_030|\			;     CI, (flush inst cache)
					  1<<CACR_CD_030|\				;     CD, (flush data cache)
					  1<<CACR_WA_030),d7			; ... in 020/030 CACR
			movec.l	d7,cacr							; and go for it
			movec.l	cacr,d7							; read back the actual CACR
			lsl.w	#3,d7							; ccr.x := write allocate bit (68030 only)
			moveq.l	#2>>1,d7						; setup to shift in ccr.x
			addx.l	d7,d7							; d7 := 2 if 68020, d7 := 3 if 68030
			rts										; all done

@NoIndexScale										; 68000/68010 don't have index scaling
			move.l	sp,d7							; mark the stack
			clr.w	-(sp)							; fake a 68010 exception format word
			bsr.s	@doRTE							; push a return address, sr, and RTE back
			exg.l	d7,sp							; restore the stack
			sub.l	sp,d7							; d7 := -2 if 68000, d7 := 0 if 68010
			addq.l	#2,d7							; d7 :=  0 if 68000, d7 := 2 if 68010
			lsr.l	#1,d7							; d7 :=  0 if 68000, d7 := 1 if 68010
			rts										; all done

@doRTE		move.w	sr,-(sp)						; push the SR to complete exception frame
			rte										; pop the exception frame and return

			SETMACHINE


;________________________________________________________________________________________
;
; Routine:	WhichBoard
;
; Inputs:	D7.B-	CPU type
;
; Outputs:	D7.L-	[ 0 ] [logic board type, i.e., boxFlag] [ 0 ] [CPU type]
;
; Trashes:	none
;
; Function:	figures out what logic board we are running on
;________________________________________________________________________________________

WhichBoard	swap	d7								; get CPU type in hi word
			clr.w	d7								; be defensive, prepare a word...
			move.b	ProductInfo.ProductKind(a1),d7	; get the BoxFlag value
			swap	d7								; put BoxFlag into hi word
			rts


;________________________________________________________________________________________
;
; Routine:	SetUpTimeK
;
; Inputs:	D7.B-	CPU type
;
; Outputs:	D7.L-	[ 0 ] [logic board type, i.e., boxFlag] [ 0 ] [CPU type]
;
; Trashes:	D0-D2, A0-A4
;
; Function:	sets up timing constants in low memory:
;
;			TimeDBRA	-	empty DBRA iterations/millisecond
;			TimeSCCDB	-	TST SCC + DBRA iterations/millisecond (used by AppleTalk)
;			TimeSCSIDB	-	TST SCSI 5380 + DBRA iterations/millisecond (used by SCSI Manager)
;
;			NOTE: VIA1 Timer 2 must not be in use, and there must be no sources of
;				  processor interrupts (although processor interrupts will be enabled)
;________________________________________________________________________________________

SetUpTimeK	
			cmpi.b	#cpu68040,CPUFlag		; check if running on one of those nasty 040s
			blt.s	@doIt

;	If we are 040'ish, check if the Cache Switch has requested to disable processor
;	caches.  The Cache Switch CDEV sets PRAM location $8A bit 7 if caches will be
;	disabled.  We are taking the initiative here and THIS is the place we will turn
;	OFF caches for the duration.  We want to make sure that we do this BEFORE we
;	calculate the timing values, as they will change depending on whether caches are
;	on or off.

			movem.l	d0-d3/a0-a3,-(sp)		; save registers before mucking around				<H22>
			move.l	UnivInfoPtr,a1			; retrieve ProductInfo record pointer				<H22>
			move.l	a1,a2					; leave A1 alone - call the routine with A2			<H22>
			move.l	a1,a0					; leave A1 alone - get pointer in A0 for call		<H23>
			adda.l	ProductInfo.ClockPRAMPtr(a2),a2; get pointer to primitives table			<H22>
			move.l	4*cpXPRAMIO(a2),d0		; get the offset to the routine						<H22>
			beq.s	@restore				; if no trap-less routine, then run with caches ON	<H22>
			add.l	ProductInfo.DecoderInfoPtr(a1),a0; required for the PramIO call				<H23>
			adda.l	d0,a2					; form trapless _ReadXPram subroutine address		<H22>
			clr.w	-(sp)					; make room on the stack
			movea.l	sp,a3					; set up for call to _ReadXPRam						<H22>
			move.l	UnivROMFlags,d1			; D1, A0, A1, A3 need to set for StandardXPramIO	<H22>
			move.l	#$0001008A,d3			; 1 byte at $8A
			jsr		(a2)					; dont have traps yet. go there directly			<H22>
			move.w	(sp)+,d0				; get the byte
			tst.w	d0						; check if top bit is set
			bpl.s	@restore				; top bit not set - run with caches on

			MACHINE	MC68040
			CPUSHA	BC						; make sure return addresses make it to memory
			MACHINE	MC68020

			moveq.l	#0,d0
			movec	d0,CACR					; turn OFF all caches
@restore
			movem.l	(sp)+,d0-d3/a0-a3		; restore registers after mucking around			<H22>
@doit		
			move.l	AutoInt1,-(sp)					; Save current auto interrupt vector.
			move.w	sr,-(sp)						; Save current interrupt level.
			ori.w	#HiIntMask,sr					; disable interrupts

			TestFor	GrandCentralExists				; Do we have a Grand Central
			beq.b	@viaIntsEnabled					; Nope, so carry on
			movea.l	UnivInfoPtr,a0					; Get the GC base address from
			adda.l	ProductInfo.DecoderInfoPtr(a0),a0	; the universal info
			movea.l	DecoderInfo.GrandCentralAddr(a0),a0	; and then
			ori.l	#1<<gcifDevVia,gcInterruptMask(a0)	; enable Lvl 1 interrupts
@viaIntsEnabled
			movea.l	VIA,a1							; Point to the VIA.
		eieioSTP
			bclr.b	#5,vACR(a1)						; Set Timer 2 to Timed Interrupt mode.
		eieioSTP
			move.b	#$FF,vT2CH(a1)					; Make sure timer won't accidentally trigger.
		eieioSTP
			move.b	#(1<<ifIRQ)+(1<<ifT2),vIER(a1)	; Enable Timer 2 interrupts.
		eieioSTP

;	Load timer with number of VIA ticks per millisecond - 3.  There are 3 clocks of overhead
;	because it takes 1 clock for the timer to load, and 2 extra clocks because it has to count
;	through -1, instead of down to 0.

			moveq.l	#(NTicks-3)**$FF,d1				; low byte of value to load into timer
			moveq.l	#(NTicks-3)>>8,d2				; high byte of value to load into timer

			movea.l	sp,a3							; mark the stack
			lea		TimerInt,a0						; point to the interrupt handler
			move.l	a0,AutoInt1						; setup the interrupt handler
			lea		TimingTable,a4					; point to table of routines to time

@nextRoutine
			movea.l	a4,a0							; point to table entry
			adda.w	(a4),a0							; get routine address
			moveq.l	#2,d0							; make a quick run to get it into the cache
			lea		@cacheLoaded,a2					; setup return address
			jmp		(a0)							; call the routine to time
@cacheLoaded
			movea.l	a4,a0							; point to table entry
			adda.w	(a4)+,a0						; get routine address
			moveq.l	#-1,d0							; run until the timer interrupts
			lea		@timedOut,a2					; setup return address
			andi.w	#$F8FF,sr						; enable interrupts
			jmp		(a0)							; call the routine to time
@timedOut	not.w	d0								; convert to number of loop executions.
			movea.w	(a4)+,a0						; get the address of the lowmem
			move.w	d0,(a0)							; store the result
			tst.w	(a4)							; see if any more routines to time
			bne.s	@nextRoutine					; time all routines in the table
		eieioSTP
			move.b	#(0<<ifIRQ)+(1<<ifT2),vIER(a1)	; Disable Timer 2 interrupts.
		eieioSTP
			move.w	(sp)+,sr						; Restore previous interrupt level.
			move.l	(sp)+,AutoInt1					; Restore previous auto interrupt vector.
			rts

TimerInt	nop
			tst.b	vT2C(a1)						; Reset the timer interrupt.
			nop
			movea.l	a3,sp							; restore the stack pointer
			jmp		(a2)							; just jump to the return address

TimingTable	dc.w	DbraTime-*,TimeDBRA				; simple DBRA loop timing
			dc.w	SCCTime-*,TimeSCCDB				; SCC access timing
			dc.w	SCSITime-*,TimeSCSIDB			; SCSI access timing
			dc.w	VIATime-*,TimeVIADB				; VIA access timing
			dc.w	0								; end of list


DbraTime	
		eieioSTP
			move.b	d1,vT2C(A1)						; load low order byte
		eieioSTP
			move.b	d2,vT2CH(A1)					; load high order byte & go.
		eieioSTP
@loop		
			dbra	d0,@loop						; time an empty DBRA loop
			jmp		(a2)							; return if loop expires


SCCTime		
			movea.l	SCCRd,a0						; point to SCC base read address
		eieioSTP
			move.b	d1,vT2C(A1)						; load low order byte
		eieioSTP
			move.b	d2,vT2CH(A1)					; load high order byte & go.
		eieioSTP
@loop		
			btst.b	#0,(A0)							; typical SCC access
			dbra	d0,@loop						; time the SCC DBRA loop
			jmp		(a2)							; return if loop expires


SCSITime	
			movea.l	SCSIBase,a0						; point to SCSI base address
			move.b	d1, vT2C(a1)					; load low order byte
		eieioSTP
			move.b	d2, vT2CH(a1)					; load high order byte & go.
		eieioSTP
			TestFor	SCSI96_1Exists					; use macro to check if we have
			beq.s	@loop80							;   SCSI96. Bra. if not
@loop96		
			btst.b	#0, rSTA(a0)					; typical SCSIMgr96 loop
			dbra	d0, @loop96						; time the SCSI DBRA loop
			jmp		(a2)							; return if loop expires

@loop80		
			btst.b	#0,sCSR(A0)						; typical SCSIMgr loop
			dbra	d0,@loop80						; time the SCSI DBRA loop
			jmp		(a2)							; return if loop expires


; ----------------------------------------------------------------------------------------------------- 	<H11>
;
;	VIATime, in the IIci/IIfx/TERROR/HORROR ROMs, lives at 40x008BC.										<H11>
;														 --------
;	This means that the @loop    btst.b  #0,(A0)    is at 40x008C8, and the    dbra   d0,@loop				<H11>
;	is at 40x008CC.  This code, "half cache-line aligned, when run on an 040 and above, will execute		<H11>
;	in an on-chip cache SEPARATE FROM THE I-CACHE, called (appropriately), the DBRA-CACHE (not to be		<H11>
;	confused with the Zebra-cache, or any other African equine).  Why this is so important is that the		<H11>
;	memory address the BTST.B is referencing is a VIA (not surprising, since this is a loop that			<H11>
;	calculates Time-VIA-DB), and on 040s and above I/O space ($5xxxxxxx) is marked as non-cached and		<H11>
;	serialized.  At 20MHz and below, 040s will encounter a 'beat frequency' between the CPU and VIA			<H11>
;	clocks, which will cause the CPU to miss both edges of the VIA clock on the first pass.  This causes	<H11>
;	the CPU to have to wait an extra VIA clock cycle (1.2µs * 2 = 2.4µs) to access the register on the		<H11>
;	VIA about 21% of the time when running out of the DBRA CACHE.  However, if the loop is unaligned and	<H11>
;	does not run from the DBRA-cache and CPU = 040 @ ² 20MHz, it will synchronize with the VIA clock		<H11>
;	on the first VIA clock cycle ZERO percent of the time.  So, just to perform sadistic, saddalistic		<H11>
;	necroequinia, ALL unaligned loop VIA accesses at 20MHz and below will take 2.4µs.  This is important	<H11>
;	(you knew I'd get to this part eventually, right?) when using TimeVIADB as an EXACT time instead of		<H11>
;	a "minimum" type of timing constant.  Poignant example - {Drivers}Sony:SonyMFM.a in mWrData uses		<H11>
;	TimeVIADB to wait EXACTLY a certain amount of time (~ 235µs).  However, the constant generated from		<H11>
;	this loop when it is aligned is $2B0.  But 1ms/$2B0 ~= 1.45µs, which indicates the bias of 79% of the	<H11>
;	VIA accesses taking 1.2µs (1.2µs * (0.79 * $2B0) = 652µs) and 21% taking 2.4µs							<H11>
;	(2.4µs * (0.21 * $2B0) = 346µs), giving (652+346 = 998µs.  The loop in mWrData is unaligned so 100%		<H11>
;	of the VIA accesses will take 2.4µs.  So instead of the loop waiting 235µs (040 @ 20MHz = 162 times		<H11>
;	thru the loop; 162 * 1.45 = ~235), it actually waits 162 * 2.4 = ~389 µs.  This is bad since the		<H11>
;	reason why this loop is waiting is for the floppy drive head to reach the correct place at the start	<H11>
;	of a sector to begin writing and since that loop waits so long, sectors are written late and the		<H11>
;	floppy is trashed.																						<H11>
;
;	So by unaligning this loop it calculates a smaller number since each VIA access will then take 2.4µs	<H11>
;	and mWrData will work correctly.
;
;	In the case of 25MHz and above 040 processors, the rate that CPU and VIA clocks don't synchronize		<H11>
;	drops to ~ 1% and above that the CPU clock rate is fast enough that it always guarantees that it		<H11>
;	NEVER misses the first synchronization with the VIA clock.  Unaligning the loop has no effect on		<H11>
;	³ 25MHz 040 processors.																					<H11>
;
; ----------------------------------------------------------------------------------------------------- 	<H11>

VIATime		
			lea		vIER(a1),a0						; <40x008BC> point to a VIA register					<H11>
		eieioSTP
			move.b	d1,vT2C(A1)						; <40x008C0> load low order byte						<H11>
		eieioSTP
			move.b	d2,vT2CH(A1)					; <40x008C4> load high order byte & go.					<H11>
		eieioSTP
@loop		
			btst.b	#0,(A0)							; <40x008CA> typical VIA access loop					<H11>
			dbra	d0,@loop						; <40x008CE> time the VIA DBRA loop						<H11>
			jmp		(a2)							; <40x008D2> return if loop expires						<H11>


;________________________________________________________________________________________
;
; Routine:	JmpTblInit, JmpTbl2
;
; Inputs:	A0	-	pointer to table of routine word offsets (A0-relative)
;			A1	-	pointer to destination jump table in RAM
;			D1	-	number of vectors to install - 1
;
; Outputs:	A0	-	pointer to next entry in offset table
;			A1	-	pointer to next jump table entry in RAM
;
; Trashes:	D0-D2
;
; Function:	sets up RAM-based jump tables from ROM-routine offset tables
;________________________________________________________________________________________

JmpTblInit	MOVE.L	A0,D0							; remember its address
JmpTbl2		MOVEQ	#0,D2							; clear high part for arithmetic
			MOVE.W	(A0)+,D2						; get the next offset
			ADD.L	D0,D2							; compute the address
			MOVE.L	D2,(A1)+						; install it in the jump table
			DBRA	D1,JmpTbl2						; loop for all vectors
			RTS


;________________________________________________________________________________________
;
; Routine:	FillWithOnes
;
; Inputs:	A0	-	pointer to starting RAM location (must be longword aligned)
;			A1	-	pointer to ending RAM location (must be longword aligned)
;
; Outputs:	A0	-	pointer to next entry in offset table
;			A1	-	pointer to next jump table entry in RAM
;
; Trashes:	D0-D2
;
; Function:	fills a longword-aligned memory range with all 1's
;________________________________________________________________________________________

FillWithOnes
			MOVEQ	#-1,D1							; what to fill memory with								<SM84>
@FillLoop	MOVE.L	D1,(A0)+						; fill next longword									<SM84>
			CMPA.L	A1,A0							; have we reached the end of the range?					<SM84>
			BLO.S	@FillLoop						; -> no, keep looping until done						<SM84>
			RTS										;														<SM84>


;________________________________________________________________________________________
;
; Routine:	CompBootStack
;
; Inputs:	none
;
; Outputs:	A0	-	location of stack pointer at boot time
;
; Trashes:	D0
;
; Function:	computes the boot time stack pointer = sysZone + (BufPtr-sysZone)/2 - space for QD
;________________________________________________________________________________________

CompBootStack
			move.l	BufPtr,d0						; get top useable memory
			move.l	sysZone,a0						; get start system heap
			sub.l	a0,d0							; get (top useable - sys heap start)
			lsr.l	#1,d0							; divide by two
			andi.w	#$FFFE,d0						; force it to be even									<SM81>
			add.l	d0,a0							; get sys heap + (top - sysHeap)/2
			suba.w	#BootGlobalsSize,a0				; leave room for QuickDraw stuff.
			rts


;________________________________________________________________________________________
;
; Routine:	ConfigureRAM
;
; Inputs:	D2.B-	address decoder kind (from Universal)
;			A0	-	pointer to machine's DecoderInfo table (from Universal)
;			A6	-	pointer to RAM chunk table
;
; Outputs:	A6	-	pointer to RAM chunk table
;						RAM chunk table pointed to by A6 reflects current RAM h/w setup
;						'offset to top of bank' field in boot globals is set up
;			SP	-	initialized to value as described below
;			Universal ROM registers (A0-A1/D0-D6) unchanged
;
; Trashes:	D7, A2-A5
;
; Function:	sets up the stack to point at 1.5 meg into the first bank if it's ³2 meg,
;			otherwise it points at 3/4 of the first bank's size.  It also changes the
;			chunk table so there is one entry per contiguous block of physical RAM. (ie
;			it merges two or more adjacent physical entries into one with a size equal to
;			the sum of the adjacent chunks).
;________________________________________________________________________________________

ConfigureRAM
			WITH	StartGlobals					;														<SM45>

			move.l	(sp)+,sp						; save return address
			move.l	4(a6),d7						; get size 1st chunk
			cmp.l	#$200000,d7						; at least two meg of RAM in first bank?				<T16>
			bhs.s	@plentyORam						; IF we have less than two meg THEN						<T16>
			lsr.l	#2,d7							;   divide amt useable logical memory by 4				<T16><SM116>
			mulu.l	#3,d7							;	multiply by 3 to get 3/4 of useable memory			<T16><T32>
			bra.s	@stakOk							;	go set stack										<T16>
@plentyORam											; ELSE													<T16>
			move.l	#defStackAddr,d7				;	use default stack addr 								<T16>
@stakOk												; ENDIF
			exg.l	d7,sp							; set stack at increment
			add.l	(a6),sp							; add in base 1st chunk
			move.l	d7,-(sp)						; restore return address
		
			move.l	a6,a3							; ptr into chunk table
@newBank	move.l	a3,a2							; keep ptr to bank size
			move.l	(a3)+,d7						; init size
@loop		add.l	(a3)+,d7						; add in length
			cmp.l	(a3)+,d7						; does next start = start of next bank?
			beq.s	@loop							; yes, continue merging

			sub.l	(a2)+,d7						; subtract off start to get size
			move.l	d7,(a2)+						; write back the total
			subq.l	#4,a3							; no, back up to start of that bank

			cmpi.l	#-1,(a3)						; any more banks?
			bne.s	@newBank						; and start merging again with that bank...

			move.l	(a3)+,(a2)+						; write the terminator									<SM116>		
			move.l	(a3)+,(a2)+						; copy the 1st dig long			
			move.l	(a3)+,(a2)+						; copy the 2nd dig long				
			move.l	(a3)+,(a2)+						; copy the 3rd dig long				
;			move.l	(a3)+,(a2)+						; copy the last diag sig long		

			sub.l	a6,d7
			move.l	d7,sgTopOff(a6)					; save offset to top of RAM
			rts										;
			
			ENDWITH									; {StartGlobals}


;________________________________________________________________________________________
;
; Routine:	SetUpSysAppZone
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0,A0
;
; Function:	Creates the system heap weÕll use till rebooting.  ItÕs handy to fool the
;			Memory Manager into thinking itÕs both system and application heaps in order
;			to allow the heap to grow as drivers, buffers, etc. are loaded.  One subtlety
;			is that HeapEnd (which applies to the app heap) must be set up along with ApplZone.
;________________________________________________________________________________________

SetUpSysAppZone
			lea 	SysHeap,a0						; point at normal system heap template

			move.b	MMFlags,-(sp)					; save the memory Manager flag
			btst.b	#MMSysHeap,MMFlags				; check type of System Heap
			beq.s	@do24							; IF we want a 32 bit heap
			bset.b	#MMStartMode,MMFlags			;   set for 32 bit system heap
			btst.b	#mmHighSysHeap,MMFlags			;   check for the 'black hole'
			beq.s	@knowHeap						;   IF we have 'black hole' between lowmem & sysHeap
			lea		SysHoleHeap,a0					;     get addr 'black hole' zone template
			bra.s	@knowHeap						;   ENDIF
@do24		bclr.b	#MMStartMode,MMFlags			;   set for 24 bit system heap
@knowHeap											; ENDIF

			_InitZone								; set up initial system heap
			Move.L	theZone,SysZone 				; save pointer to the new zone
			Move.L	SysZone,RamBase					; setup RamBase to system heap

; Make the System Heap growable by making it look like the Application Heap
			MOVE.L	SysZone,A0						; Point to the System Heap
			MOVE.L	A0,ApplZone						; Make it the Application Heap as well
			MOVE.L	bkLim(A0),A0					; Point to the end of the System Heap
			MOVE.L	A0,HeapEnd						; Set it as the end of the Application Heap

; Set ApplLimit (really, ÔSysLimitÕ) based on having a real qd-capable stack smack in the middle of RAM.

			BSR.S	CompBootStack					; A0 <- the future location of our stack
			CMPA.L	SP,A0							; Future - Current stack ptrs (want A0 = lower value)
			BLS.S	@3								; Future <= Current means use Future (be pessimistic)
			MOVE.L	SP,A0							; Use the current sp when itÕs lower
@3			SUBA.W	#BootStackSize,A0				; Give ourselves some stack space
			_SetApplLimit							; Don't let the System Heap crash our stack
			MOVE.B	(SP)+,MMFlags					; restore memory manager flag
			
			_MoreMasters							; Create 768 master pointers at the bottom of			<SM132> SAM
			_MoreMasters							; the heap.  This is approximately the number of
			_MoreMasters							; relocatable objects in the system heap for
			_MoreMasters							; System 7.1 and a set of standard inits.
			_MoreMasters							; (We need 6 calls to MoreMasters to get 768 of them.
													; _InitZone will create one block of "4*dfltMasters"
			RTS										; MPs for us.)

SysHeap		DC.L	HeapStart
			DC.L	HeapStart+SysZoneSize
			DC.W	4*dfltMasters					; Master Pointer allocation size = 128 (MPs)
			DC.L	0

SysHoleHeap	dc.l	HoleSysHeap						; start address
			dc.l	HoleSysHeap+SysZoneSize			; size
			dc.w	2*dfltMasters					; # master ptrs
			dc.l	0								; no growzone proc


;________________________________________________________________________________________
;
; Routine:	CheckForResetPRAM
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0, A0, A1
;
; Function:	if the cmd-option-R-P keys are down, it resets PRAM and then reboots the machine
;
; If the byte 76 contains a value of 2 in it then some of the PRAM information will be saved.
; If the value is any other value (0,1,3) then the value will be set to zero.
; The information which is saved is:
;	all PassWord information (address/size)
;								04/04		PSWD
;								0E/02		pswd checksum and flags
;								AB/03		PSWD
;	All AUX information			40/06		A/UX
;	Sensitive Boot Parms		76/01		Reserved for StartMgr
;	Default OS Type				77/01		Default OS
;	Default Boot Device			78/04		Default Boot Device
;________________________________________________________________________________________

CheckForResetPRAM

ck4rpRegs	REG		D1-D2

; hi-byte == size, lo-byte == address
PSWDPRAM	equ		$00040004						; 4 bytes at password location $04
PSWDChkFlg	equ		$0002000E						; 2 bytes at password location $0E ($0E = Checksum, $0F = Flags)
AUXPRAM		equ		$00060040						; 6 bytes at A/UX location $40
OSTypePRAM	equ		$00020076						; 2 bytes at Default OS $76 ($76 = reserved/save PRAM or not, $77 = Default OS)
ClearPRAM	equ		$00010076						; 1 byte at reserved byte (used if value is 1 or 3)
DefBoot		equ		$00040078						; 4 bytes at Default Boot Device $78
PSWDspace	equ		$000400AB						; 4 bytes at password location $AB (only use 3, but I alocate 4 on the stack)
PSWDmore	equ		$000300AB						; the actual 3 bytes which I use at location $AB

			movem.l	ck4rpRegs, -(sp)				;					<SM139> \/ \/ \/
			
			bsr		Ck4LimitPRAMClear				; supposed to allow bypassing security with reset?
			sne		D2								; D2=true if limit clear
													;					<SM139> /\ /\ /\
			lea		@Keys,a1						; keys to check for
			lea		KeyMap,a0						; compare to the Key Down Map
			moveq.l	#4-1,d0							; compare loop count
@loop		cmpm.l	(a0)+,(a1)+						; check for exactly this combo
			dbne	d0,@loop						; examine the entire key map
			bne.s	@noMatch						; if not equal, don't reset PRAM
			
			tst.b	D2
			beq.s	@normNuke
			bra.s	@savesome
@noMatch
			movem.l	(sp)+, ck4rpRegs
			rts										; otherwise, just return


; \/ \/ \/ \/  Save security-related items (mainly for AIX)				<SM138> thru next

@savesome
			subq.w	#PSWDPRAM>>16,sp				; allocate buffer on stack
			movea.l	sp,a0							; get buffer ptr
			move.l	#PSWDPRAM,d0					; get #, addr PRAM bytes
			_ReadXPram								; read the PSWD info
			
			subq.w	#PSWDChkFlg>>16,sp				; 
			movea.l	sp,a0							; 
			move.l	#PSWDChkFlg,d0					; 
			_ReadXPram								; read the PSWD checksum & Flags
			
			subq.w	#PSWDspace>>16,sp				; 
			movea.l	sp,a0							; 
			move.l	#PSWDmore,d0					; 
			_ReadXPram								; read the PSWD info

			subq.w	#AUXPRAM>>16,sp					; 
			movea.l	sp,a0							; 
			move.l	#AUXPRAM,d0						; 
			_ReadXPram								; read the AUX info
			
			subq.w	#OSTypePRAM>>16,sp				; 
			movea.l	sp,a0							; 
			move.l	#OSTypePRAM,d0					; 
			_ReadXPram								; read the Default OS
			
			subq.w	#DefBoot>>16,sp					; 
			movea.l	sp,a0							; 
			move.l	#DefBoot,d0						; 
			_ReadXPram								; read the Default Boot Device
			
; /\ /\ /\ /\  															<SM138> from prev

@normNuke	subq.w	#RelPram>>16,sp					; 
			movea.l	sp,a0							; 
			move.l	#RelPram,d0						; 
			_ReadXPram								; read the reliability MGR info
			
		; kill signatures in extended and old PRAM so that InitUtil writes default values out

			movea.l	a1,a0							; point to table data
			move.l	(a0)+,d0						; get PRAM len/addr, point to data
			_WriteXPRam								; kill the extended PRAM signature
			lea		SysParam,a0						; standard PRAM buffer address
			moveq.l	#-1,d0							; mask/data to write
			move.b	d0,(a0)							; kill the signature in the buffer
			_WriteParam								; write the buffer to PRAM
			
			_InitUtil								; Init PRAM
			
			movea.l	sp,a0							; 
			move.l	#RelPram,d0						; 
			_WriteXPram								; restore the reliability MGR info
			adda.w	#RelPram>>16,sp					; clean up the stack

			tst.b	D2								; flag set telling us not to clear everything?	<SM139>
			beq.s	@normNuke3						; no-> don't restore them (we didn't save them earlier)
			
; \/ \/ \/ \/  Restore security-related items							<SM138> thru next

			movea.l	sp,a0							; get buffer ptr
			move.l	#DefBoot,d0						; get #, addr PRAM bytes
			_WriteXPram								; restore the Default Boot Device
			adda.w	#DefBoot>>16,sp					; clean up the stack
			
			movea.l	sp,a0							; 
			move.l	#OSTypePRAM,d0					; 
			_WriteXPram								; restore the Default clean of OS
			adda.w	#OSTypePRAM>>16,sp				; 
			
			movea.l	sp,a0							; 
			move.l	#AUXPRAM,d0						; 
			_WriteXPram								; restore the AUX info
			adda.w	#AUXPRAM>>16,sp					; 
			
			movea.l	sp,a0							; 
			move.l	#PSWDmore,d0					; 
			_WriteXPram								; restore the PSWD info
			adda.w	#PSWDspace>>16,sp				; 
			
			movea.l	sp,a0							; 
			move.l	#PSWDChkFlg,d0					; 
			_WriteXPram								; restore the PSWD Checksum & Flags
			adda.w	#PSWDChkFlg>>16,sp				; 
			
			movea.l	sp,a0							; 
			move.l	#PSWDPRAM,d0					; 
			_WriteXPram								; restore the PSWD info
			adda.w	#PSWDPRAM>>16,sp				; 

; /\ /\ /\ /\  															<SM138> from prev

@normNuke3	bra		Start							; re-boot the machine


@Keys		dc.l	$00800000						; R
			dc.l	$08008004						; P, Cmd, Opt
			dc.l	$00000000
			dc.l	$00000000

			dc.l	$0004000C						; XPRAM signature len/addr
			dc.l	'Gone'							; invalidate XPRam signature with this


;________________________________________________________________________________________
;
; Routine:	GetPRAM
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D2, A0-A1
;
; Function:	reads in the original 20 bytes of PRAM, and sets up globals based on the saved state
;________________________________________________________________________________________

GetPRAM		_InitUtil								; seed low memory PRAM buffer

; Initialize the keyboard repeat parameters from system parameter memory.

			MOVEQ	#0,D1
			MOVE.B	SPKbd,D1						; Get keyboard rate and threshold info.
			MOVEQ	#$0F,D0
			AND.W	D1,D0							; Mask out the keyboard repeat rate.
			BNE.S	@1								; Branch if rate is valid.
			MOVEQ	#$48,D0							; If invalid, use default rate.
@1			ADD.W	D0,D0							; Convert to ticks.
			MOVE.W	D0,KeyRepThresh					; Save keyboard repeat rate.

			LSR.W	#4,D1							; Get keyboard repeat threshold.
			BNE.S	@2								; Branch if valid.
			MOVE.W	#$1FFF,D1						; If invalid, use default rate.
@2			LSL.W	#2,D1							; Convert to ticks.
			MOVE.W	D1,KeyThresh					; Save keyboard repeat threshold.

; Note: double click (dddd) and caret blink (cccc) times are stored as (ddddcccc),
; where dddd and cccc are each in fifteenths of a second.

			MOVE.B	SPClikCaret,D1					; Get double click & caret times (ddddcccc)
			MOVEQ	#$F,D0							; Caret time is in low nibble
			AND.B	D1,D0							; Compute caret time
			LSL.B 	#2,D0							; Convert to ticks
			MOVE.L	D0,CaretTime					; Save caret time (in ticks)

			LSR.B 	#2,D1							; D1 <- xxddddxx (where dddd is dbl click time)
			MOVEQ	#$3C,D0							; Double click mask
			AND.B	D1,D0							; Compute double click time in ticks
			MOVE.L	D0,DoubleTime					; Save double click time
			RTS


;________________________________________________________________________________________
;
; Routine:	SetPRAM32
;
; Inputs:	none
; Outputs:	none
; Trashes:	none
;
; Function:	force Memory Manager start mode to 32-bit mode
;________________________________________________________________________________________

SetPRAM32	movem.l	a0/d0,-(sp)						; save a0 and d0
			subq.l	#4,sp							; create space on stack
			move.l 	sp,a0 							; get pointer to useful buffer							<SM50>

			MOVE.L	#$1008a,d0						; Command to read 1 byte at addr 8a 					<SM50>
			_ReadXPRam								;														<SM50>
			
			move.l 	sp,a0 							; get pointer to useful buffer							<SM50>
			ori.b	#5,(a0)							; set PRAM to 32 bit mode	
			MOVE.L	#$1008a,d0						; Command to write 4 bytes at addr 8a					<SM50>
			_WriteXPRam 							;														<SM50>
			addq.l	#4,sp							; dispose space on stack
			movem.l	(sp)+,a0/d0						; restore a0/d0
			rts

;________________________________________________________________________________________
;
; Routine:	InitNonMMU
;
; Inputs:	A6	-	pointer to memory table in high memory
;
; Outputs:	A4	-	points to memory table
;			A5	-	points to top of useable RAM
;			A6	-	points to top of total RAM
;
; Trashes:	none
;
; Function:	sets up A4, A5, A6 for non-MMU based machines and points jSwapMMU to an RTS.
;________________________________________________________________________________________

InitNonMMU 	move.l	a6,a4							; get ptr to memory table
			move.l	(a4),a6
			add.l	4(a4),a6						; calculate top of all memory
			move.l	a6,a5							; top useable memory = top all memory
			rts



*************************************************************************************************
*																								*
*				G L O B A L   I N I T I A L I Z A T I O N   R O U T I N E S						*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	InitHiMemGlobals
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D1, A0-A2
;
; Function:	sets up globals peculiar to the BufPtr world, which may be set by a
;			diagnostic ROM, if any
;________________________________________________________________________________________

InitHiMemGlobals
			MOVE.W	#-1,PWMValue					; set current pwm speed invalid

			move.l	BufPtr,a0						; get top of useable memory
			move.l	MemTop,A1						; get the top of total memory							<H7>

			move.l	A1,PhysMemTop					; Save top of total memory.								<H7>
			move.l	a0,RealMemTop					; Save top of available memory
			move.l	([BootGlobPtr],StartGlobals.sgPhys2Log),Phys2Log
													; <SMx> CSS get physical->logical conversion factor
			SUBA.W	#bufWorldSize,A1				; maximum BufPtr location allowed						<H7>
			CMPA.L	A1,A0							; is BufPtr still too high in memory?					<H7>
			BLS.S	@BufPtrOK						; -> no, leave it alone									<H7>
			MOVEA.L	A1,A0							; yes, move it down a bit								<H7>
@BufPtrOK	MOVE.L	A0,BufPtr						; save pointer to top of usable RAM.
			RTS										; ENDIF


;________________________________________________________________________________________
;
; Routine:	InitGlobalVars
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D1, A0-A1
;
; Function:	presets a bunch of system and toolbox globals (the Memory Manager sets up
;			a few others)
;________________________________________________________________________________________

InitGlobalVars
			Lea		BaseOfRom,A0					; point to RomBase
			MOVE.L	A0,ROMBase

			movea.l	UnivInfoPtr,a0					; get pointer to product info record
			move.w	ProductInfo.Rom85Word(a0),ROM85	; Set the Rom85 and PowerOffInt bits appropriately

			MOVE.L	#$00010001, OneOne				; set up magic constants
			MOVEQ	#-1,D0
			MOVE.L	D0, MinusOne					; set up MinusOne
			MOVE	D0,FSFCBLen 					; mark that FS needs (re)initialization
			MOVE.L	D0,SMGlobals					; no Sound Manager yet

			bsr		SetupHWBases					; Init some I/O and driver base addresses
			CLR.L	PollProc						; no proc to handle SCC poll data

			CLR.L	DSAlertTab						; no deep shit alerts yet

			BigLea 	FSIODneTbl,A0					; point to the offset table
			LEA 	JFetch,A1						; point to 1st jump table entry
			MOVEQ	#2,D1							; there are 3 vectors
			BSR 	JmpTblInit

; Initialize some system booleans so we can initialize the system properly.

			CLR.B	DskVerify						; no disk verify
			CLR.B	LoadTrap						; no trap before launch
			CLR.B	MmInOK							; initial memory mgr checks
			CLR.W	SysEvtMask						; don't allow any events to be posted
			CLR.L	JKybdTask						; no keyboard task yet
			CLR.L	StkLowPt						; set stack low at this time (turn off check during VBL)

; SoundBase really truely is an OUT-OF-DATE lowmem.  However, there's glue code, linked into
; apps/drvrs, out there that still references this guy.   Sooooo, we'll set SoundBase=ASCBase
; on ASC machines.  On non-asc machines, ie. cyclone, we'll set SoundBase to a ROM address
; so apps/drvrs will write to ROM.  We must carefully choose our ROM address.  If
; its close to a ROM jump table.  Apps/drvrs writing to @SoundBase can corrupt a ROM jump table
; in the DATA CACHE.  We'll choose the starting address of the bootbeep since its not code or
; jump table.
;
			Move.l	ROMBase,A0						; Get ROMBase
			TestFor	ASCExists						; Do we really have an ASC?
			Beq.s	@noASC							; -> No. Set SoundBase = ROMBase
			Move.l	ASCBase, A0						; We do have an ASC. Get its base from universal
@noASC
			Move.l	A0,SoundBase					; Set up SoundBase

	IF ROMinRAM THEN
			CMPI.L	#$40800000,SoundBase			; if running from RAM, Set sound base to ROM		<LW5> rb
			BHI.S	@BaseOK							; if SoundBase points to higher than 40800000		<LW5> rb
			MOVE.L	#$40800000,SoundBase			; is ok, otherwise point to real ROM				<LW5> rb
@BaseOK												;													<LW5> rb
	ENDIF
;--------------------------------------

			LEA 	VBLQueue,A1
			BSR.L 	InitQueue						; initialize VBL queue header

			CLR.L	Ticks							; clear system tick count

			MOVE.B	#$80,MBState					; set current mouse button state to UP
			CLR.L	MBTicks 						; set timestamp for mouse button

;--------------------------------------
; Font Manager Globals

			CLR.L	SysFontFam						; clear SysFontFam and SysFontSize
			CLR.L	WidthTabHandle					; clear global width table handle
			CLR.W	teSysJust						; clear default Text justification
			CLR.B	WordReDraw						; don't draw words in RecalDraw
			CLR.L	SynListHandle					; clear handle to synthesized fonts
			MOVE.W	MinusOne,FMExist				; no InitFonts call yet

;--------------------------------------
; Clear out the nominally QD but mostly cursor variables

			BSR.S	InitCrsrVars

; leave DSAlertRect =-1 (disabled)
; leave DSDrawProc = -1 (disabled)

			CLR.W	SysVersion						; zero ram-patch version in low memory
			BCLR	#AlrmFlEnable,AlarmState		; disable alarm flashing

			BigLea 	MDJGNEFILTER,A0					; hook in our GNE filter  								<SM22>
			MOVE.L	A0,JGNEFilter					;		
			CLR.L	IAZNotify						; no InitApplZone notify proc
			MOVE.W	#$FF7F, FlEvtMask				; init for disable of DIP flushes (move to InitEvents??)

			MOVEQ	#-1,D0 							; Get -1
			MOVE.W	D0,ChunkyDepth					; no pixel depth yet
			MOVE.L	D0,CrsrPtr	 					; no cursor save area
			MOVE.L	D0,PortList	 					; no grafport list
			LEA		RGBWhite,A0						; init for color manager
			MOVE.L	D0,(A0)+						; 6 bytes for white value
			MOVE.W	D0,(A0)
			LEA		RGBBlack,A0						; init for color manager
			CLR.L	(A0)+							; 6 more bytes for black value
			CLR.W	(A0)

			CLR.L	LockMemCt						; initialize Lock Memory Count

			RTS


;________________________________________________________________________________________
;
; Routine:	InitCrsrVars
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0,A1
;
; Function:	initializes cursor globals
;________________________________________________________________________________________

InitCrsrVars
			LEA 	GrafBegin,A0					; start of global vars
			LEA 	GrafEnd,A1						; end of global vars
@ZeroLoop	CLR.W	(A0)+
			CMPA.L	A1,A0
			BCS.S	@ZeroLoop 						; clear out cursor globals area
			RTS


;________________________________________________________________________________________
;
; Routine:	InitCrsrMgr
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0,A1
;
; Function:	initializes cursor globals
;________________________________________________________________________________________

; ugly, but put here for now!
ADBCount	equ	0									; word: number of valid error deltas
MaxCnt		equ	ADBCount+2							; word: limit on number of error deltas
Err7		equ	MaxCnt+2							; word: time-7 error magnitude
Err6		equ	Err7+2								; word: time-6 error magnitude
Err5		equ	Err6+2								; word: time-5 error magnitude
Err4		equ	Err5+2								; word: time-4 error magnitude
Err3		equ	Err4+2								; word: time-3 error magnitude
Err2		equ	Err3+2								; word: time-2 error magnitude
Err1		equ	Err2+2								; word: time-1 error magnitude
Error		equ	Err1+2								; word: accumulated error
GSize		equ	Error+2								; size of globals
TotalSize	equ	GSize+8								; size of globals + size of mickey bytes

InitCrsrMgr	MOVE.L	#$000F000F,D0
			LEA 	MTemp,A0						; point to the temp mouse variable
			MOVE.L	D0,(A0)+						; put MTemp AT 15,15
			MOVE.L	D0,(A0)+						; put RawMouse AT 15,15 TOO
			MOVE.L	D0,(A0)+						; put Mouse AT 15,15 TOO
			CLR.L	(A0)+							; CrsrPin: top = 0, left = 0

			MOVE.W	ColLines,(A0)+					; set bottom
			MOVE.W	RowBits,(A0)					; set left

			moveq	#TotalSize,d0					; allocate space for mouse tracking ptr
			_NewPtr	,SYS							; put in in system heap
			move.l	a0,MickeyBytes					; save globals ptr

													; initialize some of the ADB Globals
			move.w	#1,ADBCount(a0)					;   Count = 1
			move.w	#8,MaxCnt(a0)					;   MaxCnt = 8
			clr.w	Error(a0)						;   Error = 0

													; stuff in 8 bytes to initialize tracking
			lea		MouseBytes,a1					;   source = default bytes
			add		#GSize,a0
			move.l	(a1)+,(a0)+						;   move the bytes in
			move.l	(a1),(a0)

			LEA 	GrafEnd,A1						; end of cursor globals
			BigLea	CrsrDevHandleVBL,A0				; install cursor VBL task							<H9>
			MOVE.L	A0,-(A1)						; JCrsrTask
			MOVE.W	#$0006,-(A1)					; CrsrThresh

; Init the cursor jump table.  The offsets are obtained from a table in CrsrCore.

			BigLea 	InitCrTable,A0					; point to the offset table
			LEA 	JHideCursor,A1					; point to 1st jump table entry
			MOVEQ	#8-1,D1							; there are 8 vectors
			BSR 	JmpTblInit						; init vectors (destroys D0-D2)

			; A0 points to next entry in offset table
			LEA 	NewCrsrJTbl,A1					; point to 1st new jump table entry
			MOVEQ	#NewCrsrJCnt,D1					; get number of vectors
			BSR 	JmpTbl2							; init vectors (destroys D0-D2)
			LEA		HiliteRGB,A0
			MOVE.L	#$00060082,D0
			_ReadXPRam

			MOVEQ	#-1,D0							; Useful constant for cursor init
			MOVE.W	D0,CrsrNew						; flag cursor as changed, turn on tracking
			MOVE.L	D0,MouseMask					; No jerkiness with $FFFFFFFF mask

		IF forTNTDebug THEN
; set up a Time Manager task to call jVBLTask
			
initDummyVBL
			moveq.l	#tmXQSize, d0					; allocate a block in the system heap
			_NewPtr	,SYS,CLEAR						;  to hold the Time Manager task structure
			lea		dummyVBL, a1
			move.l	a1, tmAddr(a0)
			move.l	#'eada', (a0)					; identify queue type to VM
			_InsXTime
			move.l	#-16626, d0
			move.l	jPrimeTime, a1
			jmp		(a1)
			
			RTS

dummyVBL	
			movea.l a1, a0
			move.l	#-16626,d0			; 60.15 Hz
			movea.l jPrimeTime, a1
			move.l	jCrsrTask,-(sp)		; return address from PrimeTime to CrsrTask
			jmp		(a1)				; restart time manager task
		ENDIF
			
			RTS

MouseBytes	dc.b		4,10,15,255,255,83,77,72


;________________________________________________________________________________________
;
; Routine:	InitSwitcherTable
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0,A1
;
; Function:	Installs a table telling Switcher what low memory locations to save/restore
;			between applications in addition to the Switcher's own table (but always
;			including the dispatch table).  The Switcher's table:
;
;				$100:	$02 bytes		(monkey lives)
;				$108:	$14 bytes		(MemTop, BufPtr, StkLowPt, HeapEnd, TheZone)
;				$130:	$04 bytes		(ApplLimit)
;				$15C:	$04 bytes		(SEvtEnb, DSWndUpdate, FontFlag, IntFlag)
;				$2AA:	$04 bytes		(ApplZone)
;				$31E:	$22 bytes		(MinStack, DefltStack, mmDefFlags, GZRootHnd, GZRootPtr,
;											GZMoveHnd, DSDrawProc, EjectNotify, IAZNotify).
;				$800:	$2FC bytes		(ToolBox globals)
;
;			Table defining our additional switchables
;
;			Format is:
;				address (word), byte count (word)	; save bytecount bytes at address
;				.
;				.
;				0 (longword)						; terminates list
;________________________________________________________________________________________

OurSwitch	DC.W	OSTable,	4*numOStrap			; OS dispatch table
			DC.W	ToolTable,	4*numTBtrap			; Toolbox dispatch table
			DC.W	$0B80,		$26					; new switchables
			DC.W	$0BAE,		$52					; new switchables
			DC.W	HFSFlags,	2					; TFS flags (PMSP status) & Cache flags
			DC.W	DefVRefNum,	2					; Default VRefNum/WDRefNum
			DC.W	DefVCBPtr,	4
			DC.W	ScrDmpEnb,	2
			DC.W	CurDirStore,4
			DC.W	MBProcHndl,	4

			DC.W	$0100,		$0002				; SysCom//MonkeyLives
			DC.W	$0108,		$0014				; memtop,bufptr,stklowpt,etc.
			DC.W	$015C,		$0004				; SEvtEnb,DSWndUpdate,FontFlag,IntFlag
			DC.W	$031E,		$0022				; MinStack,DefltSTack,mmDefFlags,etc.
			DC.W	$0800,		$02FC				; toolbox globals,etc.
			DC.W	ApplLimit,	$0004
			DC.W	ApplZone,	$0004
			DC.W	AuxWinHead,	$0004
			DC.W	AuxCtlHead,	$0004
			DC.W	BNMQHd,		$0004
			DC.W	MenuCInfo,	$0004
			DC.W	MenuDisable,$0008
			DC.W	theGDevice,	$0004

WDCBSwitch	DC.W	0,0,0 							; WDCB table
PMSPSwitch	DC.W	0,0,SPHdrSize-2					; PMSP hook
			DC.W	0,0 							; terminate with a long of zeroes
SwitchLen	EQU 	*-OurSwitch

;----------------------------------------------------------------
; These constant values are stored in ROM rather than defined as EQUs for
; use at compile time simply because we have a brain-damaged (c.f. Jobs on HP)
; development system.
;----------------------------------------------------------------
WDCBSwOS	DC.W	WDCBSwitch-OurSwitch
PMSPSwOS	DC.W	PMSPSwitch-OurSwitch


InitSwitcherTable
			MOVEQ	#SwitchLen,D0					; allocate a switcher table in
			_NewPtr ,SYS,CLEAR						;  the system heap
			MOVE.L	A0,A1							; make it the destination
			LEA 	OurSwitch,A0					; template table
			MOVEQ	#SwitchLen,D0					; copy it - needs to be updated with
			_BlockMove								;  WDCBSwitch, PMSPSwitch later

			MOVE.L	A1,SwitcherTPtr 				; Set the pointer up for Switcher
			RTS


;________________________________________________________________________________________
;
; Routine:	SetupHWBases
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0, D3, A0, A2, A3
;
; Function:	sets up the hardware base address low memory globals
;________________________________________________________________________________________

SetupHWBases
			with	DecoderInfo

			movem.l	d1/d2,-(sp)						; save these
			
			move.l	AddrMapFlags,d0
			move.l	AddrMapFlags1,d1				; get new bits 32-63
			move.l	AddrMapFlags2,d2				; and bits 64-96
			movea.l	UnivInfoPtr,a0
			adda.l	ProductInfo.DecoderInfoPtr(a0),a0
			lea		@BaseInitTable,a2				; point to the table
@loop		move.w	(a2)+,d3						; get the bit number
			bmi		@exit							; exit if end if table
			movea.w	(a2)+,a3						; get the low mem address

			cmpi.w	#32,d3							; above low 32 bits?
			bge.s	@chkmid32						; yes, branch
			btst.l	d3,d0							; see if the base is valid
			beq.s	@loop							; if not, skip it
			lsl.w	#2,d3							; setup index into bases table
			move.l	(a0,d3.w),(a3)					; initialize the low mem
			bra.s	@loop							; go on to next low mem

@chkmid32	sub.w	#32,d3							; it's in 32-63 range
			cmpi.w	#32,d3							; above low 32 bits?
			bge.s	@chkhigh32						; yes, branch
			btst.l	d3,d1							; see if the base is valid
			beq.s	@loop							; if not, skip it
			lsl.w	#2,d3							; setup index into bases table
			move.l	(4*32,a0,d3.w),(a3)				; initialize the low mem
			bra.s	@loop							; go on to next low mem
			
@chkhigh32	sub.w	#32,d3							; it's in 64-95 range
			btst.l	d3,d2							; see if the base is valid
			beq.s	@loop							; if not, skip it
			lsl.w	#2,d3							; setup index into bases table
			move.l	(4*64,a0,d3.w),(a3)				; initialize the low mem
			bra.s	@loop							; go on to next low mem
			
@BaseInitTable
			dc.w	VIA1Exists,VIA					; init VIA1 base address
			dc.w	SCCRdExists,SCCRd				; init SCC read base address
			dc.w	SCCWrExists,SCCWr				; init SCC write base address
		IF hasIopScc THEN
			dc.w	SCCIOPExists,SCCRd				; init SCC IOP read base address
			dc.w	SCCIOPExists,SCCWr				; init SCC IOP write base address
		ENDIF
			dc.w	IWMExists,IWM					; init IWM base address
		IF hasIopSwim THEN
			dc.w	SWIMIOPExists,IWM				; init SWIM IOP base address
		ENDIF
		IF hasSwim3 THEN
			dc.w	SWIM3Exists,IWM					; init SWIM3 base address
		ENDIF
			dc.w	PWMExists,PWMBuf1				; init primary PWM buffer
			dc.w	PWMExists,PWMBuf2				; init secondary PWM buffer
			dc.w	SoundExists,SoundBase			; init sound buffer base address
			dc.w	SCSIExists,SCSIBase				; init SCSI base
			dc.w	SCSIDackExists,SCSIDMA			; init SCSI Dack base
			dc.w	SCSIHskExists,SCSIHsk			; init SCSI Dack base
		IF hasMac2VIA2 | hasEclipseVIA2 THEN
			dc.w	VIA2Exists,VIA2					; init VIA2 base address
		ENDIF
		IF hasASC THEN
			dc.w	ASCExists,ASCBase				; init ASC base address
		ENDIF
		IF hasRBV THEN
			dc.w	RBVExists,RBV					; init RBV base address
		ENDIF
			dc.w	SCSIDMAExists,SCSIBase			; init SCSI DMA base addresses
			dc.w	SCSIDMAExists,SCSIDMA			; init SCSI DMA base addresses
			dc.w	SCSIDMAExists,SCSIHsk			; init SCSI DMA base addresses
		IF hasOSS THEN
			dc.w	OSSExists,OSS					; init OSS base address
		ENDIF
			dc.w	-1								; end of list


@exit

; Setup miscellaneous low mem SCSI addresses
; Existing Mac SCSI systems are either 80-base or 96-based
;
; a0 -> base of address table
; d0 -> Addresses Map Flags, which system addresses are valid

SetupMiscSCSI
		IF hasSCSI96 THEN
			btst.l	#SCSI96_1Exists, d0				; see if we have 1st SCSI96
			beq.s	@2ndSCSI96						; bra. if not
			move.l	SCSI96Addr1(a0), SCSIBase		; initialize the low mem								<SM82>
@2ndSCSI96			
			btst.l	#SCSI96_2Exists, d0				; see if we have 2nd SCSI96
			beq.s	@80based						;
			move.l	SCSI96Addr2(a0), SCSI2Base		; initialize the low mem								<SM82>
			bra.s	@SCSIHskDone
@80based
		ENDIF
			btst.l	#SCSIDackExists,d0				; see if we have SCSI Dack
			bne.s	@SCSIDackDone					; if we do, it's setup ok
			move.l	SCSIHsk,SCSIDMA					; if not, use hsk instead
@SCSIDackDone

			btst.l	#SCSIHskExists,d0				; see if we have SCSI Hsk
			bne.s	@SCSIHskDone					; if we do, it's setup ok
			move.l	SCSIDMA,SCSIHsk					; if not, use Dack instead
@SCSIHskDone

			movem.l	(sp)+,d1/d2
			
			rts										; all done
			endwith



;________________________________________________________________________________________
;
; Routine:	InitSlots
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0, A0
;
; Function:	initializes the slot dispatch table, gives the Slot Manager its wakeup call,
;			and grays the screen for devices with video cards
;________________________________________________________________________________________

InitSlots	BSR.L	InitSDTbl						; init slot int dispatch table
			BSR.L	InitVBLQs						; init VBLqueues for all slots

			BSR.L	StartSDeclMgr					; init the slot manager
			BNE.S	@SlotError						; branch if an error occurred
			RTS

@SlotError	MOVE.L	D0,D6							; save error code
			MOVEQ	#$1F,D7							; NuMac Error
			BRA		Critical						; Critical error


;________________________________________________________________________________________
;
; Routine:	InitIOPStuff
;
; Inputs:	none
; Outputs:	none
; Trashes:	???
;
; Function:	initializes the I/O system by building the Unit Table and issuing initialization
;			calls to all the component drivers.
;________________________________________________________________________________________

InitIOPStuff
		IF IopADB | hasIopScc | hasIopSwim THEN
			BSR.L	InitIOPMgr						; fire up the IOP manager
		  IF hasIopSWIM THEN
			TestFor	SWIMIOPExists					; see if we have a SWIM IOP
			beq.s	@noSwimIOP						; if not, skip it
			BSR.L	EnableSwimIOPInts				; Enable SWIM IOP interrupts
@noSwimIOP
		  ENDIF
		  IF hasIopScc THEN
			TestFor	SCCIOPExists					; see if we have a SCC IOP
			beq.s	@noSCCIOP						; if not, skip it
			BSR.L	SCCIOPBypass
@noSCCIOP
		  ENDIF
		ENDIF
			rts


;________________________________________________________________________________________
;
; Routine:	InitDeviceMgr
;
; Inputs:	none
; Outputs:	none
; Trashes:	???
;
; Function:	initializes the I/O system by building the Unit Table 
;________________________________________________________________________________________

InitDeviceMgr	; Compute the size of the unit table and allocate it.

			MOVEQ	#UnitEntries,D0 				; get number of entries in unit table
			MOVE.W	D0,UnitNtryCnt					; save for IOCore checking

			MOVE.L	#MaxUTEntries*4,D0				; reserve more memory so table can grow					<SM84>
			_NewPtr ,SYS,CLEAR						; allocate it and zero out the memory
			MOVE.L	A0,UTableBase					; and save its address

			rts
			
			
;________________________________________________________________________________________
;
; Routine:	LoadDrivers
;
; Inputs:	none
; Outputs:	none
; Trashes:	???
;
; Function:	issues initialization calls to all the component drivers.
;________________________________________________________________________________________

LoadDrivers
;
;ÑÑÑÑÑÑÑÑÑ  Floppy Driver  ÑÑÑÑÑÑÑÑÑ
;
			LEA 	-IOQElSize(SP),SP				; allocate parameter block for device manager calls
			MOVE.L	SP,A0
			CLR.B	IOPermssn(A0)					; r/w permissions

		IF hasNewAge THEN
			TestFor	NewAgeExists					; do we have a NewAge?									<SM16>
			Beq.S	@NoNewAge						; no ? then try old floppy								<SM16>

			move.l	SP,A0							; iopb on stack
			clr.b	IOPermssn(A0)					; clear r/w permissions
			lea		NewAgeName,a1					; get new age driver name								<SM16>
			move.l	a1,IOFileName(a0)				; set it up												<SM16>
			_Open									; and open the driver									<SM16><SM21>
@NoNewAge
		ENDIF

			TestFor	IWMExists						; do we have an IWM or SWIM?
		IF hasIopSwim THEN
			BNE.S	@OpenSony						; -> yes, open the driver
			TestFor	SWIMIOPExists					; how about an IOP-based version?
		ENDIF

		IF hasSwim3 THEN
			BNE.S	@OpenSony						; -> yes, open the driver
			TestFor	SWIM3Exists						; how about a SWIM3 based version?
		ENDIF
			BEQ.S	@NoFloppy						; -> nope, no floppy controller

@OpenSony
			MOVE.L	SP,A0							; iopb on the stack
			CLR.B	IOPermssn(A0)					; r/w permissions
			LEA 	DiskName,A1						
			MOVE.L	A1,IOFileName(A0)				
			_Open									;OPEN Floppy disk driver

;
;ÑÑÑÑÑÑÑÑÑ  NetBoot Driver  ÑÑÑÑÑÑÑÑÑ
;
@NoFloppy	
		IF hasNetBoot	THEN
			SUBQ.W	#4,SP
			MOVE.L	#'DRVR',-(SP)					; resource type
			PEA		NetBootName						; resource name
			_GetNamedResource						; try to get the handle to the .netBoot driver
			TST.L	(SP)+							; does the driver exist?
			BEQ.S	@NoNetBoot						; -> no, try don't open it

			LEA		NetBootName, A1
			MOVE.W	#49,D2							;  and resource ID										<SM84>
			BSR		InstallDriver					; go install the driver									<SM84>
@NoNetBoot
		ENDIF

;
;ÑÑÑÑÑÑÑÑÑ  RAM Disk Driver  ÑÑÑÑÑÑÑÑÑ
;
; if we don't have an EDisk driver, this will not affect anything
; to enable the EDisk, make sure that it is included in the rom resources

		IF hasEDisk THEN
			LEA 	EDiskName,A1					
			MOVE.W	#48,D2							;  and resource ID										<SM84>
			BSR		InstallDriver					; go install the driver									<SM84>
		ENDIF

	IF NOT forTNTDebug THEN
;
;ÑÑÑÑÑÑÑÑÑ  Sound Driver  ÑÑÑÑÑÑÑÑÑ
;
		IF hasDSP THEN
			TestFor	DSPExists						; If we have a DSP, we assume we're doing sound through it. <SM57>
			BNE.s	@DoneSoundDriver				; if we have a Cyclone/DSP then don't load sound driver	<SM53>
		ENDIF

			MOVE.L	SP,A0							; iopb on the stack
			CLR.B	IOPermssn(A0)					; r/w permissions
			LEA 	SndName,A1
			MOVE.L	A1,IOFileName(A0)
			_Open									; OPEN sound driver
@DoneSoundDriver
	ENDIF

			MOVE.L	SP,A0							; iopb on the stack <sm125>
			CLR.B	IOPermssn(A0)					; r/w permissions   <sm125>
			BSR		FROVideo						; open the default video driver and setup video globals	<SM19>
			LEA	 	IOQElSize(SP),SP				; deallocate parameter block for device manager calls.

		IF hasPwrControls THEN
			TestFor	hwCbPwrMgr						; <61>, is this a Power Mgr mac ?
			beq.s	@noBacklight					; <61>, if not, skip
			LEA		BacklightName,A1				; get the backlight driver's name						<SM84>
			MOVE.W	#-16511,D2						;  and resource ID										<SM84>
			BSR		InstallDriver					; go install the driver									<SM84>
@noBacklight
		ENDIF
	

;
;ÑÑÑÑÑÑÑÑÑ  Serial Drivers  ÑÑÑÑÑÑÑÑÑ
;
; The ROM serial driver is stored in a resource of type 'SERD'. The classic serial driver
; is 'SERD' (0) and the SerialDMA serial driver is 'SERD' (1). Which serial driver to use
; is indicated by a bit in Universal ProductInfo. A 'SERD' resource is a code resource
; whose entry point is an installation procedure. A 'SERD' installs itself into the unit
; table, remaining closed and inactive until opened by a client.

			subq	#4,sp							; allocate space for return value
			move.l	#'SERD',-(sp)					; push serial driver resource type

			TestFor	SerialDMA
			bne.b	@SerialDMA
			clr.w	-(sp)							; classic serial driver is 'SERD' (0)
			bra.b	@CallSERD
@SerialDMA	move.w	#1,-(sp)						; SerialDMA driver is 'SERD' (1)

@CallSERD	move.w	#mapTrue,ROMMapInsert			; get resource from ROM
			_GetResource
			move.l	(sp)+,d0						; did it get the handle?
			beq.b	@exitDrivers
			movea.l	d0,a0
			movea.l	(a0),a0
			jsr		(a0)							; call the install code

@exitDrivers
			rts


			STRING	PASCAL

DiskName	DC.W	'.Sony'

SndName 	DC.W	'.Sound'						;														<SM83>

		IF hasEDisk THEN
EDiskName	DC.W	'.EDisk'						;														<SM83>
		ENDIF
		IF hasNewAge THEN
NewAgeName	DC.W	'.NewAge'						;														<SM16>
		ENDIF
		IF hasNetBoot THEN
NetBootName	DC.W	'.netBOOT'
		ENDIF

		IF hasPwrControls THEN
BacklightName
			DC.W	'.Backlight'
		ENDIF

			STRING	ASIS


*************************************************************************************************
*																								*
*									V I D E O   R O U T I N E S									*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	DrawBeepScreen
;
; Inputs:	A5	-	pointer to QuickDraw globals in boot globals space
;
; Outputs:	none
;
; Trashes:	D0-D2, A0-A1
;
; Function:	Grays the screen (with rounded corners on non-LCD screens) using Horst's
;			patented methods.  The use of QuickDraw here forces existance of a temporary
;			app heap during system initialization time.
;________________________________________________________________________________________

DrawBeepScreen
			PEA 	-4(A5)							; set up QuickDraw global area
			_InitGraf

			PEA 	BootGlobals.port(a5)			; let Grafport be above A7, A5							<SM56>
			_OpenCPort								; open default COLOR port (closed in StartBoot)

			MOVE.L	(A5),A2 						; point to QuickDraw globals
			PEA 	arrow(A2)						; show the arrow cursor
			_SetCursor

		IF hasPwrControls THEN						;														<SM81>
;	if built-in video is an LCD screen, use square corners to avoid "eyebrows" on the top ends
;	of the menu bar (because the screen background is white on LCD screens vs black on CRTs)

			BSR.L	LCDScreenChk					; is this an LCD screen ? 								<SM16><SM68>
			BEQ.S	@DoNormalBeepScreen				; -> no, do the normal stuff							<SM16><SM68>
			
			PEA 	ScreenBits+bounds(A2)			;  screen rectangle										<SM84>
			PEA		gray(A2)						;  fill pattern
			_FillRect								; fill the screen with 50% gray
			RTS
@DoNormalBeepScreen
		ENDIF										;														<SM81>

;	for normal screens (CRTs), draw the screen with rounded corners

			LEA		ScreenBits+bounds+8(A2),A0		; make a copy of the screen rectangle
			LEA		TempRect+8,A1
			MOVE.L	-(A0),-(A1)
			MOVE.L	-(A0),-(A1)

			MOVE.L	A0,-(SP)						; push the screen rectangle for FillRoundRect
			MOVE.L	A1,-(SP)						; push the copy for FrameRoundRect
			MOVE.L	A1,-(SP)						;  and for InsetRect
			MOVE.L	#$FFFDFFFD,-(SP)				; make the rectangle bigger by 3 on each side
			_InsetRect

			MOVE.L	#$00030003,-(SP)				; make pen 3 pixels wide.
			_PenSize

			MOVE.L	#$00160016,-(SP)				; rounding factor ($00100010 + 2 * $00030003)
			_FrameRoundRect							; draw black corners without flicker

			_PenNormal								; restore the pen

			MOVE.L	#$00100010, -(SP)				;  rounding factor
			PEA 	gray(A2)						;  fill pattern
			_FillRoundRect							; fill the screen with 50% gray
			RTS


;________________________________________________________________________________________
;
; Routine:	FROVideo
;
; Inputs:	A0	-	pointer to ioParamBlock
;
; Outputs:	none
;
; Trashes:	D0-D2, A0-A2
;
; Function:	finds, reads parameters for, and opens the driver for a video sRsrc
;________________________________________________________________________________________

			WITH	spBlock,seBlock,vpBlock

FROVideo	MOVE.L	A0,A1							; save the param block pointer for _Open

			LINK	A6,#-spBlockSize				; allocate space for a slot parameter block
			MOVE.L	SP,A0							;  and point to it

			BSR.S	OpnVidDeflt						; open the default video device, set video params
			BEQ.S	@End							; -> got it

;	the default video device is bad, so go search for a video sRsrc...

			MOVE.L	#(CatDisplay<<16) ++ TypVideo, spCategory(A0)	;	stuff Category and Type, looking
													;	 for an Apple compatible video card
			MOVE.W	#DrSwApple,spDrvrSw(A0)			;	want Apple driver software interface
			MOVE.B	#1,spTBMask(A0)					;	mark spDrvrHw field as donÕt care
			CLR.B	spSlot(A0)						;	start with slot #0
			CLR.B	spId(A0)						;	start with sResource ID #0
			CLR.B	spExtDev(A0)					;	no external devices

;	keep looking for a video driver until we find one that we can open...

@NextVidsRsrc
			_sNextTypesRsrc							; search for a video sRsrc
			BNE.S	@FakeIt							; -> couldn't find one, so allocate a dummy screen

			BSR		RdVidParam						; read the video parameters
			BNE.S	@NextVidsRsrc					; -> error, so go search some more

			BSR		OpensDrvr						; open the video driver
			BNE.S	@NextVidsRsrc					; -> couldn't do it, so go look some more

			BSR		InitVidDeflt					; initialize the default video device
			BNE.S	@NextVidsRsrc					; -> error during initialization, so go looking

@End		UNLK	A6								; get rid of the slot parameter block
			RTS

@FakeIt		BSR		InitDummyScreen					; allocate a dummy screen, GDevice
			BRA.S	@End							;  and return


;________________________________________________________________________________________
;
; Routine:	OpnVidDeflt
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D2, A2
;
; Function:	opens the default video device
;________________________________________________________________________________________

OpnVidDeflt	MOVE.L	A0,A2							; save A0

			SUBQ.W	#2,SP							; allocate space for parameter RAM info
			MOVE.L	SP,A0							;  and point to it
			_GetVideoDefault						; get the default video info
			MOVE.B	(A0)+,spSlot(A2)				; save the slot number
			MOVE.B	(A0)+,spId(A2)					;  and ID
			ADDQ.W	#2,SP							; (clean up the stack)

			MOVE.L	A2,A0							; restore A0
			CLR.B	spExtDev(A0)					;	no external devices
			_sRsrcInfo								; get the sResource Type
			BNE.S	@Error							; -> error

			CMP.L	#(CatDisplay<<16) ++ TypVideo,spCategory(A0)	; are the category and type correct?
			BNE.S	@Error							; -> no, keep on searching
			CMP.W	#DrSwApple,spDrvrSW(A0)			; does it have an Apple driver interface (software only)?
			BNE.S	@Error							; -> no, keep on searching

			BSR.S	RdVidParam						; a video sRsrc was found, so read the video parameters
			BNE.S	@Error							; -> error during the read

			BSR		OpensDrvr						; open the video driver
			BNE.S	@Error							; -> couldn't do it

			BSR		InitVidDeflt					; initialize the default video device
@Error		RTS


;________________________________________________________________________________________
;
; Routine:	RdVidParam
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0
;
; Function:	Searches the video card ROM for expected video parameters.  These values are
;			then saved in low memory as needed.
;________________________________________________________________________________________

RdVidParam	MOVEM.L	A1-A2/D3,-(SP)
			MOVE.B	spId(A0),D3						; save the ID

			CLR.B	spExtDev(A0)					;	no external devices
			_sRsrcInfo								; get a pointer to the sRsrc list
			BNE		@Error

			_sFindDevBase							; get the device base address
			BNE		@Error							; -> error
			MOVE.L	spResult(A0),ScrnBase			; save it as screen base.

			MOVE.B	#MinorLength,spId(A0)
			_sReadLong								; get the total number of bytes occupied by screen sRsrc
			BEQ  	@gotBase						; got it, save away
			
			MOVE.B	#MajorLength,spId(A0)			; else, try major length (some don't support minor length)	<SM144>
			_sReadLong								; get the total number of bytes occupied by screen sRsrc	<SM144>
			BNE  	@Error							; -> couldn't find it										<SM144>

@gotBase	MOVE.L	spResult(A0),ScreenBytes		; save it

			MOVE.B	D3,spId(A0)						; restore the sRsrc ID
			BSR		GetDefVidMode					; get the default video mode
			MOVE.B	D0,spId(A0)						;  and save it

			_sFindStruct							; go look up the default video mode
			BNE		@Error							; -> default mode is not supported

			MOVE.B	#mVidParams,spId(A0)			;	ID for video sBlock
			_sGetBlock								; go get it
			BNE		@Error							; -> not found
			MOVE.L	spResult(A0),A1					; save the pointer to the parameter block

;	save required parameters in low memory globals:

			MOVE.W	vpBounds+4(A1),ColLines			; screen height
			MOVE.W	vpBounds+6(A1),RowBits			; screen width
			MOVE.W	vpRowBytes(A1),D0				;
			MOVE.W	D0,ScreenRow					; screen rowBytes
			MOVE.W	D0,CrsrRow						; cursor's screen rowBytes
			MOVE.W	vpVRes(A1),ScrVRes				; vertical resolution
			MOVE.W	vpHRes(A1),ScrHRes				; horizontal resolution
			MOVE.L	vpBaseOffset(A1),D0				; update the screen base
			ADD.L	D0,ScrnBase
			MOVE.L	ScrnBase,CrsrBase				;  and the cursor base address

			MOVEQ	#0,D0
			MOVE.B	spSlot(A0),D0					; get the slot number
			_AttachVBL								; setup the VBL connection for the main video card

			MOVE.L	#VideoMagic,VideoInfoOK			; show that the video info is available

			MOVE.L	A1,spsPointer(A0)				;	pointer to parameter block
			_sDisposePtr							; all done, dispose it
			MOVEQ	#0,D0							; no errors

@End		MOVE.B	D3,spId(A0)						; restore ID for caller
			MOVEM.L	(SP)+,A1-A2/D3
			TST.W	D0
			RTS

@Error		MOVEQ	#1,D0							; bad video card (woof)
			BRA.S	@End


;________________________________________________________________________________________
;
; Routine:	OpensDrvr
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D1
;
; Function:	opens a slot driver
;________________________________________________________________________________________

OpensDrvr	MOVE.L	A2,-(SP)

			LEA		-seBlockSize(SP),SP				; allocate an sExec parameter block,
			MOVE.L	SP,A2							;  point to it,
			MOVE.L	A2,spsExecPBlk(A0)				;  and save a copy in the slot PB

			LEA		-256(SP),SP						; allocate space for the driver's name
			MOVE.L	SP,spResult(A0)					;  and save it in the PB
			_sReadDrvrName							; read the name of the driver
			BNE.S	@End							; -> error

			MOVE.L	spResult(A0),seIOFileName(A2)	; name of driver, for seBlock
			MOVE.B	spSlot(A0),seSlot(A2)			; slot,
			MOVE.B	spId(A0),sesRsrcId(A2)			; sRsrc,
			CLR.B	seDevice(A2)					; and device,

			MOVE.L	seIOFileName(A2),ioFileName(A1)	; copy the driver name pointer to ioFileName.
			CLR.L	ioMix(A1)						; this field should be 0
			CLR.W	ioFlags(A1)						; clear the flags
			BSET.B	#fMulti,ioFlags+1(A1)			; set the Multi bit
			MOVE.L	A2,ioSEBlkPtr(A1)				; point to the seBlock (for sLoad record)
			CLR.B	ioPermssn(A1)					; R/W permissions
			EXG.L	A0,A1							; A0=pointer to ioParamBlock, A1=pointer to slot PB
			_Open	,IMMED							; open the video driver, using the extended parameter block
													; (keep error code and CCR through to RTS)
			EXG.L	A0,A1							; restore A0,A1

@End		LEA		256+seBlockSize(SP),SP			; clean up the stack
			MOVE.L	(SP)+,A2
			RTS


;________________________________________________________________________________________
;
; Routine:	InitVidDeflt
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	none
;
; Trashes:	D0-D1
;
; Function:	allocates a GDevice for the default video device
;________________________________________________________________________________________

InitVidDeflt
			MOVEM.L	D1-D2/A0-A1,-(SP)				; save all registers
			CLR.L	-(SP)							; make room for GDevice handle
			MOVE	ioRefNum(A1),-(SP)				; push the device's refNum

			BSR.S	GetDefVidMode					; get the default video mode
			MOVE.L	D0,-(SP)						;  and push it

			_NewGDevice								; allocate a new GDevice (in the system heap)
													;strips refNum and video mode
			MOVE.L	(SP)+,A0						;save current device in A0

;	install default video card as primary display device

			MOVE.L	A0,TheGDevice					; make this the default destination
			MOVE.L	A0,DeviceList					; make this device head of list
			MOVE.L	A0,MainDevice					; make it the main device
			MOVE.L	A0,SrcDevice					; make it the default source for copyBits
			MOVE.L	A0,CrsrDevice					; make it the one owning the cursor
			MOVE.L	(A0),A1							; point to this device
			ORI.W	#$B800,GDFlags(A1)				; set flags: ScrnActive,MainScrn,ScreenDevice,Allinit

			BSR		InitDefGamma					; initialize gamma correction for this device

			MOVEM.L	(SP)+,D1-D2/A0-A1				;restore all registers
			MOVEQ	#0,D0							;no error
			RTS


;________________________________________________________________________________________
;
; Routine:	GetDefVidMode
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;
; Outputs:	D0	-	default video mode
;
; Trashes:	none
;
; Function:	returns the default video mode for the device specified in the slot PB
;________________________________________________________________________________________

GetDefVidMode
			MOVE.L	spsPointer(A0),-(SP)			; save the sPointer,
			MOVE.B	spId(A0),-(SP)					;  the id,
			MOVE.L	A1,-(SP)						;  and registers

			LEA		-SizesPRAMRec(SP),SP			; make room for parameter RAM info
			MOVE.L	SP,A1							;  and point to it

			MOVE.L	A1,spResult(A0)					; pass the pointer to the buffer
			_SReadPRAMRec							; get parameter RAM record
			BNE.S	@OneBit							; -> it's invalid, so default to one bit mode

			CLR.B	spExtDev(A0)					;	no external devices
			_sRsrcInfo								; get a pointer to the sResource list
			BNE.S	@OneBit							; -> error

			MOVE.B	2(A1),spId(A0)					; check for a valid mode
			_sFindStruct
			BNE.S	@OneBit							; -> not valid

			MOVEQ	#0,D0
			MOVE.B	2(A1),D0						; get the default mode

@ValidMode	LEA		SizesPRAMRec(SP),SP				; clean up the stack
			MOVE.L	(SP)+,A1						; restore registers,
			MOVE.B	(SP)+,spId(A0)					;  the id,
			MOVE.L	(SP)+,spsPointer(A0)			;  and the sPointer
			RTS

@OneBit		MOVE.B	#OneBitMode,2(A1)				; Set default to OneBitMode
			MOVE.L	A1,spsPointer(A0)				; Pass pointer to buffer
			_SPutPRAMRec							; Save parameter RAM record
			MOVE.L	#OneBitMode,D0					; Assume one bit mode
			BRA.S	@ValidMode						; Branch if mode is valid


;________________________________________________________________________________________
;
; Routine:	InitDefGamma
;
; Inputs:	A0	-	handle to GDevice
;
; Outputs:	none
;
; Trashes:	D0, A0, A1
;
; Function:	Sets the default gamma correction table for the device.  This routine is
;			updated to look in the video card's gamma directory for the default gamma
;			table.  If a gamma directory is not found, then this routine leaves the
;			gamma table unchanged from its default.  If the card is an original Mac II
;			Video Card (TFB card), then it sets the default gamma from the ROM resource.
;			For all other cards it leaves the gamma table unchanged if a directory is
;			not found.
;________________________________________________________________________________________

IOPBlk		EQU		-IOVQElSize						; [64] parameter blk for I/O calls
VidParms	EQU		IOPBlk-12						; [12] size of mode params
VARSIZE		EQU		VidParms						; size of locals

InitDefGamma
			LINK	A6,#VARSIZE						; allocate local stack frame
			MOVEM.L	A2/A3,-(SP)						; save work registers
			MOVE.L	A0,A2							; save GDevice

; find the video sRsrc list based on the gDevice's gdRefnum.

			MOVE.L	(A2),A1							; de-reference the GDevice handle
			MOVE.W	gdRefNum(A1),D0					;  and get the device's refnum
			NOT.W	D0								; invert it to make an index
			MOVE.L	UTableBase,A1					; get the unit table base
			MOVE.L	(A1,D0*4),A1					; get DCE handle
			MOVE.L	(A1),A1							;  and de-reference it
			LEA		-spBlockSize(SP),SP				; allocate a Slot Manager parm block
			MOVE.L	SP,A0							;  and point to it
			MOVE.B	dCtlSlot(A1),spSlot(A0)			; 	slot number
			CLR.W	spID(A0)						;	zero spID, spExtDev
			MOVE.W	#CatDisplay,spCategory(A0)		;	look for this slot's card
			MOVE.W	#TypVideo,spCType(A0)
			MOVE.W	#DrSwApple,spDrvrSW(A0)
			MOVE.B	#1,spTBMask(A0)					;	mark spDrvrHw field as donÕt care
			_sNextTypesRsrc							; get the spsPointer
			BNE.S	@Error							; -> couldn't get it

			CMP.W	#DrHwTFB,spDrvrHW(A0)			; is this a TFB card?
			BEQ.S	@DoTFB							; -> yup, so get the gamma resource from ROM

; get the default gamma from the video card's gamma directory.  Keep the temp handle in A3

			MOVE.B	#sGammaDir,spID(A0)				; look for the gamma directory
			_sFindStruct							; get that baby
			BNE.S	@Error							; -> not present

			MOVE.B	#128,spID(A0)					; get the default gamma table, (always 128)
			_sReadPBSize							; read the physical block size
			BNE.S	@Error							; -> not present										<SM60>

			MOVE.L	A0,A3							; save the slot parameter block for a second
			MOVE.L	spSize(A0),D0					; get the table size
			_NewHandle								; allocate it
			BNE.S	@Error							; if you couldn't get it, then bail out					<SM60>
			_HLock									; lock it down
			EXG.L	A0,A3							; get handle in A3, spBlock back in A0
			MOVE.L	(A3),A1							; get pointer to the block
			MOVE.L	A1,spResult(A0)					; point slot manager toward this buffer
			SUBQ.W	#4,spSize(A0)					; subtract block header from size
			_sReadStruct							; read the data into the handle
			BNE		@Error							; something went wrong									<SM60>
			MOVE.L	spResult(A0),A0					; get gamma table ptr in A0

; skip over header

			ADDQ.W	#2,A0							; skip resID
@Name		TST.B	(A0)+							; skip over gamma name
			BNE.S	@Name
			MOVE.L	A0,D0
			ADDQ.L	#1,D0							; round up the pointer
			ANDI.B	#$FE,D0							;  and word-align it
			MOVEA.L	D0,A0							;  then put it back in A0

; now call the driver to set this gamma table (handle on stack)

@SetIt		LEA		VidParms(A6),A1					; point to params for SetGamma
			MOVE.L	A0,csGTable(A1)					; gamma table pointer is only param
			LEA		IOPBlk(A6),A0					; point to parameter block
			MOVE.L	A1,csParam(A0)					; move addr of parms into block
			MOVE.W	#4,csCode(A0)					; csc_SetGamma
			CLR.L	ioCompletion(A0)				; no completion routine
			CLR.W	ioVRefNum(A0)					; no volRefNum
			MOVE.L	(A2),A1							; point to gdevice
			MOVE	GDRefNum(A1),ioRefNum(A0)		; set device's refnum
			_Control ,IMMED							; SetGamma(GammaTable);
			MOVE.L	A3,A0							; get handle to gamma table
			_HUnlock								; unlock the gamma table
			_DisposHandle							; and get rid of it

@Error		ADDA	#spBlockSize,SP					; release the slot parameter block
			MOVEM.L	(SP)+,A2/A3						; restore all registers
			UNLK	A6								; strip stack frame
			RTS

; get the default gamma table from ROM

@DoTFB		SUBQ	#4,SP							; make room for function result
			MOVE.L	#'gama',-(SP)					; push gamma table rsrc type
			CLR		-(SP)							; get 'gama' resource 0
			MOVE.W	#MapTRUE,ROMMapInsert 			; get from ROM
			_GetResource							; try to read in gamma table
			MOVE.L	(SP),-(SP)						; push a copy
			_DetachResource							; make it a handle
			MOVE.L	(SP)+,A0						; get handle to gamma table
			_HLock									; lock down the gamma table
			MOVE.L	A0,A3							; remember it in A3
			MOVE.L	(A0),A0							; get gamma table ptr in A0
			BRA.S	@SetIt							; set it


;________________________________________________________________________________________
;
; Routine:	InitDummyScreen
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D2, A0-A1
;
; Function:	allocates all the necessary structures for operation without a screen device
;________________________________________________________________________________________

; First allocate bits for a dummy screen.  Make it 32*32 just for fun!

InitDummyScreen
			MOVEQ	#32,D0							; get height of screen
			MOVE.W	D0,ColLines						; save number of columns
			MOVE.W	D0,RowBits						; save number of rows

			MOVEQ	#4,D0							; get byte width of screen
			MOVE.W	D0,ScreenRow					; save rowbytes of screen
			MOVE.W	D0,CrsrRow						; save rowbytes of cursor

			MOVEQ	#(32*4)/2,D0					; get size of screen
			ADD.L	D0,D0
			MOVE.L	D0,ScreenBytes					; save size of screen
			_NewPtr									; allocate screen memory
			MOVE.L	A0,ScrnBase						; save base of screen
			MOVE.L	A0,IconTLAddr					; save base for icon
			MOVE.L	A0,CrsrBase						; save base for cursor

			MOVEQ	#$0048,D0						; get screen resolution
			MOVE.W	D0,ScrHRes						; save horiz resolution
			MOVE.W	D0,ScrVRes						; save vert resolution

; allocate a dummy GDevice, and set up all devices

			CLR.L	-(SP)							; make room for result
			CLR		-(SP)							; no refNum
			MOVEQ	#-1,D0							; get mode = -1
			MOVE.L	D0,-(SP)						; and push mode -1
			_NewGDevice								; allocate and init GDevice
			MOVE.L	(SP)+,A0						; get gDevice

			MOVE.L	A0,theGDevice					; set theGDevice
			MOVE.L	A0,DeviceList					; set head of device list
			MOVE.L	A0,MainDevice					; set as first device
			MOVE.L	A0,SrcDevice					; set as src device
			MOVE.L	A0,CrsrDevice					; and as cursor device

; initialize the GDevice's pixMap

			MOVE.L	(A0),A1							; point to gdevice
			MOVE	#4,GDResPref(A1)				; set preferred resolution
			MOVE.W	#(1<<screenActive)|\			; flags: in use
					 (1<<noDriver)|\				;		 no driver for this GDevice
					 (1<<screenDevice)|\			;		 screen device [not used]
					 (1<<allInit)|\					;		 all devices initialized
					 (1<<mainScreen)|\				;		 main screen
					 (1<<ramInit),GDFlags(A1)		;		 initialized from 'scrn' resource
			MOVEQ	#32,D0							; get height and width
			MOVE	D0,GDRect+bottom(A1)			; get the device rectangle's bottom and right
			MOVE	D0,GDRect+right(A1)
			MOVE.L	GDPMap(A1),A0					; get handle to pixMap
			MOVE.L	(A0),A0							; point to pixMap
			MOVE.L	scrnBase,baseAddr(A0)			; set base address
			MOVE	screenRow,rowBytes(A0)			; set rowbytes
			MOVE	D0,bounds+right(A0)				; set bounds
			MOVE	D0,bounds+bottom(A0)			; right and bottom
			MOVEQ	#$48,D0							; get resolution
			SWAP	D0								; put in high word for fixed
			MOVE.L	D0,hRes(A0)						; save as horizontal res
			MOVE.L	D0,vRes(A0)						; and as vRes
			MOVEQ	#1,D0							; get a useful number
			MOVE	D0,pixelSize(A0)				; pixelSize = 1
			MOVE	D0,cmpCount(A0)					; cmpCount = 1
			MOVE	D0,cmpSize(A0)					; cmpSize = 1

; set the GDevice's color table to be one bit per pixel

			MOVE.L	pmTable(A0),A0					; get handle to color table
			MOVE.L	(A0),A0							; and point at that puppy
			MOVEQ	#1,D1							; get a useful number
			MOVE.L	D1,(A0)+						; CTSEED := 1
			MOVE.L	D1,(A0)+						; TransIndex := 0, CTSize := 1
			CLR		(A0)+							; entry 0: value := 0
			MOVEQ	#-1,D0							; set entry 0 to white
			MOVE.L	D0,(A0)+						; set R,G
			MOVE	D0,(A0)+						; and B
			SWAP	D1								; D1 = $00010000
			MOVE.L	D1,(A0)+						; entry1: value := 1, R = 0
			CLR.L	(A0)+							; set G, B
			RTS


;________________________________________________________________________________________
;
; Routine:	AddVidDevice
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D1
;
; Function:	allocates a GDevice for a video device and installs it in the device list
;________________________________________________________________________________________

AddVidDevice
			MOVEM.L	D1-D2/A0-A3,-(SP)				; save work registers

; scan for end of chain of grafDevices
; in case already opened, check if this refNum already installed

			MOVE	ioRefNum(A1),D1					; get refNum of the opened device
			MOVE.L	DeviceList,D0					; get head of device list
@NextDev	MOVE.L	D0,A2							; save handle to current device
			MOVE.L	(A2),A3							; point to current device
			CMP		GDRefNum(A3),D1					; does the refNum match?
			BEQ.S	@End							; =>yes, already installed (default device)
			MOVE.L	GDNextGD(A3),D0					; get handle of next device in chain
			BNE.S	@NextDev						; there is one, keep looking

; allocate and initialize a grafDevice for this device

			CLR.L	-(SP)							; make room for GrafDevice handle
			MOVE	ioRefNum(A1),-(SP)				; push the device's refNum

			BSR.S	GetDefVidMode					; D0 <- the default video mode
			MOVE.L	D0,-(SP)						; Push it

			_NewGDevice								; allocate a new GrafDevice (in system heap)
			MOVE.L	(A2),A0							; get pointer to device at end of list
			MOVE.L	(SP),GDNextGD(A0)				; save current device at end of list
			MOVE.L	(SP),A0							; get the new device's handle
			MOVE.L	(A0),A0							; point to the new device
			ORI.W	#(1<<screenDevice),GDFlags(A0)	; set flag: ScreenDevice

			MOVE.L	(SP)+,A0						; device already on stack
			BSR		InitDefGamma					; initialize gamma correction for this device

@End		MOVEM.L	(SP)+,D1-D2/A0-A3				; restore all registers
			MOVEQ	#0,D0							; no error
			RTS

			ENDWITH									; {spBlock,seBlock,vpBlock}


*************************************************************************************************
*																								*
*				M A C H I N E / F E A T U R E   S P E C I F I C   R O U T I N E S				*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	InitSCC
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0, A1
;
; Function:	resets both channels of the SCC
;________________________________________________________________________________________

InitSCC
		IF forRomulator THEN
			TestInRam	a0							; check if we're in RAM									<SM82>
			bne.s	@dontInitSCC					; -> don't initialize the SCC if so						<SM82>
		ENDIF

		IF hasIopScc THEN
			TestFor	SCCIOPExists					; see if we have an SCC IOP
			bz.b	@NoIOP							; if not, donÕt try to initialize it
			bsr.l	SCCIOPHwInit					; initialize the IOP hardware registers
@NoIOP												; fall thru -- IOP boots in bypass mode
		ENDIF
			movea.l	SCCWr,a0						; point to SCC base write address (chan B)
			movea.l	SCCRd,a1						; point to SCC base read address (chan B)
			tst.b	(a1)							; synchronize SCC accesses
			move.b	#9,(a0)							; select write register 9
			move.b	#$C0,(a0)						; hardware reset both channels
@dontInitSCC										;														<SM82>
			rts


;________________________________________________________________________________________
;
; Routine:	InitIWM
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0, D2, A0
;
; Function:	initializes the IWM/SWIM/SWIM2 floppy disk controller
;________________________________________________________________________________________

InitIWM		TestFor	IWMExists						; see if we really have an IWM
			beq		ExitInitIWM						; if not, nothing to init

			MOVEA.L	IWM,A0							; get floppy controller base address

InitSWIM2	MOVE.L	BusErrVct,-(SP)					; save the old bus error vector							<H5>
			PEA		@Resume							;  and point it to ours									<H5>
			MOVE.L	(SP)+,BusErrVct					;														<H5>
			MOVE.L	SP,D2							; save the stack pointer in case we bus error			<H5>

			MOVEQ	#noDriveErr,D0					; assume the chip isn't there							<H5>
			TST.B	q6L|rPhase(A0)					; access the chip (may bus error!)						<H5>
			MOVEQ	#noErr,D0						; if we got here, the chip may be connected				<H5>
			
@Resume		MOVEA.L	D2,SP							; trash the exception frame if we bus errored			<H5>
			MOVE.L	(SP)+,BusErrVct					; restore the previous bus error vector					<H5>
			TST.W	D0								; set the CCR											<H5>
			BNE		ExitInitIWM						; -> IWM/SWIM/SWIM2 is not currently connected			<H5>

;  If we got here, at least we didn't bus error.  That doesn't mean we really have
;  a IWM/SWIM, though, so lets do some more checking...

			MOVE.B	#$F8,wZeroes(A0)				; try to switch to the IWM register set					<H7>
		IF nonSerializedIO THEN						;
			nop										; allow write to complete								<SM55>
		ENDIF
			MOVEQ	#$F5-256,D2						;														<H7>
			MOVE.B	D2,wPhase(A0)					; write a value to the phase register					<H7>
		IF nonSerializedIO THEN						;
			nop										; allow write to complete								<SM55>
		ENDIF
			MOVE.B	D0,rPhase(A0)					; drive the bus in case the chip's not there			<H7>
		IF nonSerializedIO THEN						;
			nop										; allow write to complete								<SM55>
		ENDIF
			CMP.B	rPhase(A0),D2					; did we get back what was originally written?			<H7>
			BEQ.S	ExitInitIWM						; -> yes, we've got a SWIM2								<H7>

;  At this point, we know we don't have a SWIM2 connected.  We either have an IWM/SWIM or no chip...

@NotSWIM2	TST.B	q7L(A0)							; select "Read Handshake"								<H7>
			TST.B	q6L(A0)							;														<H7>
			MOVE.B	D0,q7H(A0)						;														<H7>
			MOVEQ	#%00111111,D2					; mask to just the low 6 bits							<H7>
			AND.B	q6L(A0),D2						;  and read the register								<H7>
			TST.B	q7L(A0)							; back into a read mode									<H7>
			CMPI.B	#%00111111,D2					; did we get what we expected?							<H7>
			BNE.S	ExitInitIWM						; -> no, it's isn't IWM or SWIM							<H7>

			MOVEQ	#IWMInitMode,D0 				; initial mode setting
@1			MOVE.B	#$BE,wZeroes(A0)				; disable enabled if in ISM mode
			MOVE.B	#$F8,wZeroes(A0)				; switch SWIM to the IWM register set
			TST.B	Q7L(A0)							; and get out of write mode
			TST.B	MtrOff(A0)						; change the IWM mode now
			TST.B	Q6H(A0) 						; set IWM to sense state
			MOVE.B	Q7L(A0),D2						; sense the mode register
			BTST	#5,D2							; no disks should be enabled
			BNE.S	@1								; keep waiting

			AND.B	D0,D2							; see if low bits match mode we want
			CMP.B	D0,D2
			BEQ.S	@2								; if so, we are done

			MOVE.B	D0,Q7H(A0)						; set to twiggy mode
			TST.B	Q7L(A0) 						; set IWM back to sense state
			BRA.S	@1								; loop back just to check

@2			TST.B	Q6L(A0) 						; and back to read mode

ExitInitIWM	RTS


;________________________________________________________________________________________
;
; Routine:	InstallDriver
;
; Inputs:	A1	-	pointer to driver name string (pascal)
;			D2	-	driver's resource ID
;
; Outputs:	none
;
; Trashes:	D0-D2, A0-A2
;
; Function:	gets a driver from the ROM, and installs and opens it in the first available
;			slot after entry 48
;________________________________________________________________________________________

InstallDriver
			move.l	a1,a2							; move name ptr to a2 for safe keeping
			bsr.s	GetDetachDRVR					; get and detach resource (d1,d1/a1)
			beq.s	@exit							; exit if no handle

			bsr.s	FirstEntryFree					; get ref num of first free entry (/d0,d1)
			_DrvrInstall							; create dce (d0/d0)
			tst.l	d0								; test for error
			bne.s	@releaseDrvr					; ... exit if error
			
			move.l	UTableBase,a0					; point to utable array
			move.l	(a0,d1),a0						; get handle to dce in a3
			move.l	(a0),a0							; get pointer to dce
			move.l	a1,dCtlDriver(a0)				; load driver

			move.l	(a1),a1							; get pointer to driver
			move.w	drvrFlags(a1),dCtlFlags(a0)		; copy data to dce
			move.w	drvrDelay(a1),dCtlDelay(a0)
			move.w	drvrEMask(a1),dCtlEMask(a0)
			move.w	drvrMenu(a1),dCtlMenu(a0)

			bset.b	#dNeedLock,dCtlFlags+1(a0)		; set the handle bit

@openDrvr	move.l	a2,a1							; load pointer to driver name
			bra.s	OpenDRVR						; open the driver (a1/)

@releaseDrvr	
			move.l	a1,a0							; move handle to a0
			_DisposHandle							; release the memory
@exit		rts


;________________________________________________________________________________________
;
; Routine:	GetDetachDrvr, GetDetachRes
;
; Inputs:	D1	-	resource type (GetDetachRes)
;			D2	-	driver's resource ID
;
; Outputs:	A1	-	handle to resource
;			CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D2, A0-A2
;
; Function:	gets a driver from the ROM and detaches it
;________________________________________________________________________________________

GetDetachDRVR
			MOVE.L	#'DRVR',D1
GetDetachRes
			MOVE.W	#MapTrue,ROMMapInsert			; make sure we can get it from ROM
			SUBQ.L	#4, SP							; For return address
			MOVE.L	D1, -(SP)						; Resource type
			MOVE.W	D2, -(SP)						; Resource ID
			_GetResource
			MOVE.L	(SP), A1						; Get resource handle to return
			BNE.S @NoDetach							; If not found, don't try to detach it
			_DetachResource
			MOVE.L	A1,D0							; Set result code
			RTS
@NoDetach
			ADDA.L	#4,SP							; recover stack
			MOVEQ	#0,D0							; set error
			RTS										; return


;________________________________________________________________________________________
;
; Routine:	FirstEntryFree
;
; Inputs:	none
;
; Outputs:	D0	-	driver refNum
;
; Trashes:	none
;
; Function:	finds the first free entry in the unit table
;________________________________________________________________________________________

StartEntry	equ		(48-1)							; this avoids AppleTalk area
		
FirstEntryFree
			move.l	a0,-(SP)						; save a0

@findEntry	move.l	UTableBase,a0					; point to utable array
			move.l	#(StartEntry*4),d0				; start at entry (48-1)
				
@testEntry	addq.l	#4,d0							; increment to next entry
			tst.l	0(a0,d0)						; test entry
			bne.s	@testEntry						; if != 0, next entry
				
@calcRefnum	move.l	d0,d1
			lsr.l	#2,d0							; divide by 4 to get entry number
			addq.l	#1,d0							; add 1 (refnum is -(entry number + 1)
			neg.l	d0								; negate to get reference number				
				
			move.l	(SP)+,a0						; restore a0
			rts


;________________________________________________________________________________________
;
; Routine:	OpenDRVR
;
; Inputs:	A1	-	pointer to driver name string (pascal)
;
; Outputs:	D0	-	driver refNum in high word, Open result in low word
;			CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	A0
;
; Function:	opens a driver
;________________________________________________________________________________________

OpenDRVR	LEA		-ioQElSize(SP),SP				; Allocate IO stack frame
			MOVE.L	SP,A0							; set a0 to point to the pb
			MOVE.L	A1,ioVNPtr(A0)					; load pointer to name
			MOVE.B	#fsCurPerm,ioPermssn(A0)		; set permission (not used)
			_Open

			MOVE.W	ioRefNum(A0),D0					; return ioRefNum (D0.W:HI)
			SWAP	D0								; move ioRefNum HI
			MOVE.W	ioResult(A0),D0					; return result (D0.W:LO)
			LEA		ioQElSize(SP),SP				; Release stack frame
			RTS										; Sucess returned in status


		IF hasEgret THEN
;________________________________________________________________________________________
;
; Routine:	CheckForEgretOrCuda
;
; Inputs:	none
;
; Outputs:	CCR	-	BEQ if there is an Egret/Caboose/Cuda of some sort
;
; Trashes:	D0
;
; Function:	checks if the Egret chip exists
;________________________________________________________________________________________

			EXPORT	CheckForEgretOrCuda				; so others can use this								<T9>
CheckForEgretOrCuda									;														<T2>
			moveq.l	#ProductInfo.ADBMask,d0			; mask for ADB kind										<T2>
			and.l	UnivRomFlags,d0					; isolate the field										<T2>
			subq.l	#ProductInfo.ADBEgret,d0		; see if we have Egret ADB								<T2>
			beq.s	@checkDone						; if we do, go initialize it							<T2>
			moveq.l	#ProductInfo.ClockMask,d0		; mask for Clock kind									<T2>
			and.l	UnivRomFlags,d0					; isolate the field										<T2>
			cmpi.b	#ProductInfo.ClockEgret,d0		; see if we have Egret Clock + PRAM						<T2>
@checkDone	rts										;														<T2>
		ENDIF


;___________________________________________________________________________								<SM63>		
; CheckForTV: Checks for the Cmd-Option-T-V keys down, and if so, set 
; the PRAM bit that specifies we do that and Re-Boot
;
; Destroys	A0-A1/D0/D1.
;___________________________________________________________________________
		WITH 		spBlock,SP_Params
CheckForTV
			lea		@TVKeys,a1						; keys to check for								
			lea		KeyMap,a0						; compare to the Key Down Map					
			moveq.l	#4-1,d0							; compare loop count
@loop		cmpm.l	(a0)+,(a1)+						; check for exactly this combo
			dbne	d0,@loop						; examine the entire key map
			beq.s	@tvmatch						; if equal, reset PRAM
			rts										; otherwise, just return
			
@tvmatch	SUBA		#spBlockSize,SP				; make an slot parameter block on stack
			MOVE.L		SP,A0						; get pointer to parm block now
			MOVE.B		#0,spSlot(A0)				; put slot in pBlock
			CLR.B		spExtDev(A0)				; external device = 0

; Read the slot pRAM to determine what the currently saved mode is.  
; The flag are in SP_FLAGS, which are in VendorUse5 byte.
			
			SUBA		#SizesPRAMRec,SP			; allocate block for pRAM record
			MOVE.L		SP,spResult(A0)				; point to it
			_sReadPRAMRec							; read it
			Bne			@ErrorReturn				; should not fail, but if so...
			Move.b		SP_Flags(SP),D0				; Get the current flags
			Bset		#spCompOut,D0				; Set it, which means to enable
			Move.b		D0,SP_Flags(SP)				; write out the sp_flags byte
			MOVE.L		SP,spsPointer(A0)			; set up parameter block
			_sPutPRAMRec							; write the new record out
			Bne			@ErrorReturn				; any errors?
			Adda		#SizesPRAMRec+spBlockSize,SP; Deallocate buffer and
			jmp			Start														
@ErrorReturn			
			Adda		#SizesPRAMRec+spBlockSize,SP; Deallocate buffer and
			rts
			
@TVKeys		dc.l	$00020200						; V, T
			dc.l	$00008004						; Cmd, Opt
			dc.l	$00000000
			dc.l	$00000000
		ENDWITH	

;________________________________________________________________________________________	<SM121>
;
; Routine:	DynamicBoxFlag
;
; Inputs:	D7.w	BoxFlag from the Universal tabke
;
; Outputs:	D7.w	Adjusted BoxFlag for this machine
;
; Trashes:	D0-D1, A0-A1
;
; Function:	Calculates the boxflag based on box type and CPU clock rates.
;			Look Ma! We have only one Universal table entry per family!
;
;________________________________________________________________________________________

DynamicBoxFlag
			TestFor	HMCDecoder						; do we have an HMC decoder?
			beq.s	@rts							; -> Nope, just use the boxflag from the uTables.
			
			MOVEM.L	D0-D6/A0-A4/A6,-(SP)			; save Universal info
;			CMPI.B	#boxPDMEvt1,D7					; Is this an Evt1?						; removing evt1 suprt
;			BEQ.S	@Done							; -> Yes, never muck with the boxflag	; <mc2>
	
			BigBSR6	GetCPUIDReg						; Get the CPU id
			BNE.S	@Done							; -> Failed (can't happen)

			AND.W	#%00000011,D0					; Just look at bits 0 & 1

			MOVE.L	([ProcessorInfoPtr],\
					  ProcessorInfo.CPUClockRateHz),D1 ; Get the CPU clock rate
						
			MOVEQ	#-1,D2							; Clear the  counter
			LEA		@SpeedTable,A0					; Point to the list of clock rates
@Lupe		CMP.L	(A0)+,D1						; Is the bus clock rate less than the entry?
			BLS.S	@GotIt							; -> Yes, go with the current delay factor
			ADDQ	#1,D2
			BRA.S	@Lupe
			
@GotIt		LSL.W	#2,D0							; Mult the box bit by the size of the table
			LEA		(@BoxTable,D0),A0
			MOVE.B	(A0,D2),D7						; Get the boxflag

@Done		MOVEM.L	(SP)+,D0-D6/A0-A4/A6			; save Universal info
@rts		RTS										; Return

@SpeedTable											; PDM CPU clock rate mapping table
			DC.L	10000000						; 50.001 MHz
			DC.L	60000000						; 66.001 MHz
			DC.L	73000000						; 80.001 MHz
			DC.L	100000000						; 100.001 MHz
			DC.L	-1								; end of table

@BoxTable	EQU		*
@WLCDboxes	DC.B	boxPDM50WLCD					; QFC
			DC.B	boxPDM66WLCD
			DC.B	boxPDM80WLCD
			DC.B	boxPDM

@notboxes	DC.B	boxPDM50WLCD					; QFC (wlcd post evt1)
			DC.B	boxPDM66WLCD
			DC.B	boxPDM80WLCD
			DC.B	boxPDM

@shitboxes	DC.B	boxPDM50L						; Lego
			DC.B	boxPDM66L
			DC.B	boxPDM80L
			DC.B	boxPDM
			
@FridgBoxes	DC.B	boxPDM							; Fridge
			DC.B	boxPDM66F
			DC.B	boxPDM80F
			DC.B	boxPDM100F

			ENDPROC									; {MyROM}


		END
